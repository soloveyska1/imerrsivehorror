<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>ВОДА</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Courier+Prime:wght@400;700&display=swap');
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            background: #000; 
            color: #fff; 
            font-family: 'Courier Prime', monospace; 
            overflow: hidden; 
            user-select: none;
            -webkit-user-select: none;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
            cursor: none;
        }
        
        /* HYPNOTIC CURSOR */
        #cursor { 
            position: fixed; 
            width: 20px; 
            height: 20px; 
            border: 1px solid rgba(80,0,0,0.4); 
            border-radius: 50%; 
            pointer-events: none; 
            z-index: 10000; 
            transition: all 0.08s ease-out;
            will-change: transform;
            mix-blend-mode: difference;
        }
        #cursor::before {
            content: '';
            position: absolute;
            width: 6px;
            height: 6px;
            background: rgba(139,0,0,0.5);
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: all 0.15s;
        }
        #cursor.watching {
            width: 80px;
            height: 80px;
            border-color: rgba(139,0,0,0.95);
            border-width: 2px;
            animation: watchingBreath 3s infinite;
        }
        #cursor.watching::before {
            width: 35px;
            height: 35px;
            background: rgba(139,0,0,0.8);
            animation: pupilContract 4s infinite;
        }
        @keyframes watchingBreath {
            0%, 100% { transform: scale(1); opacity: 0.6; }
            50% { transform: scale(1.15); opacity: 0.95; }
        }
        @keyframes pupilContract {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            30% { transform: translate(-50%, -50%) scale(0.6); }
            50% { transform: translate(-50%, -50%) scale(1.3); }
            70% { transform: translate(-50%, -50%) scale(0.8); }
        }
        #cursor.forced {
            border-color: rgba(139,0,0,0.9);
            border-width: 2px;
            animation: forcedPulse 0.6s infinite;
        }
        @keyframes forcedPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.4); }
        }
        
        @media (hover: none) and (pointer: coarse) {
            #cursor { display: none; }
        }
        
        /* CURSOR TRAIL */
        .cursor-trail {
            position: fixed;
            width: 3px;
            height: 3px;
            background: rgba(80, 0, 0, 0.5);
            border-radius: 50%;
            pointer-events: none;
            z-index: 9999;
            animation: trailFade 0.8s forwards;
        }
        @keyframes trailFade {
            to { opacity: 0; transform: scale(0); }
        }
        
        /* HYPNOTIC WARNING SCREEN */
        #warning { 
            position: fixed; 
            top: 0; left: 0; 
            width: 100%; height: 100%; 
            background: #000; 
            display: flex; 
            flex-direction: column; 
            justify-content: center; 
            align-items: center; 
            z-index: 10000; 
            padding: 30px 20px;
            animation: warningDistortion 12s infinite;
            overflow-y: auto;
        }
        @keyframes warningDistortion {
            0%, 100% { background: #000; }
            33% { background: #050000; }
            66% { background: #000505; }
        }
        
        #warning::before {
            content: '';
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: repeating-linear-gradient(
                0deg,
                transparent,
                transparent 2px,
                rgba(30, 0, 0, 0.03) 2px,
                rgba(30, 0, 0, 0.03) 4px
            );
            pointer-events: none;
            animation: scanlines 8s linear infinite;
        }
        @keyframes scanlines {
            0% { transform: translateY(0); }
            100% { transform: translateY(20px); }
        }
        
        #warning-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            max-width: 900px;
            width: 100%;
            opacity: 0;
            animation: hypnoticFadeIn 3s forwards;
            padding: 30px 20px;
            position: relative;
            z-index: 1;
        }
        @keyframes hypnoticFadeIn {
            0% { opacity: 0; transform: scale(0.97) translateY(10px); }
            100% { opacity: 1; transform: scale(1) translateY(0); }
        }
        
        #warning h1 { 
            font-size: clamp(36px, 7vw, 72px);
            margin-bottom: 55px; 
            text-align: center; 
            color: #6a0000; 
            letter-spacing: clamp(5px, 1.5vw, 12px);
            animation: titleGlitch 8s infinite;
            text-shadow: 
                2px 2px 0 rgba(90, 0, 0, 0.3),
                -2px -2px 0 rgba(0, 90, 90, 0.1),
                0 0 40px rgba(106, 0, 0, 0.8);
            font-weight: 700;
            line-height: 1.1;
            position: relative;
        }
        @keyframes titleGlitch {
            0%, 90%, 100% { 
                opacity: 1; 
                transform: translate(0, 0);
                text-shadow: 
                    2px 2px 0 rgba(90, 0, 0, 0.3),
                    -2px -2px 0 rgba(0, 90, 90, 0.1),
                    0 0 40px rgba(106, 0, 0, 0.8);
            }
            91% {
                opacity: 0.8;
                transform: translate(-2px, 1px);
                text-shadow: 
                    3px 0 0 rgba(200, 0, 0, 0.6),
                    -3px 0 0 rgba(0, 200, 200, 0.6),
                    0 0 50px rgba(106, 0, 0, 1);
            }
            93% {
                opacity: 0.9;
                transform: translate(2px, -1px);
                text-shadow: 
                    -2px 0 0 rgba(200, 0, 0, 0.6),
                    2px 0 0 rgba(0, 200, 200, 0.6),
                    0 0 50px rgba(106, 0, 0, 1);
            }
            95% {
                opacity: 1;
                transform: translate(0, 0);
            }
        }
        
        .warning-block {
            margin-bottom: 45px;
            width: 100%;
            max-width: 750px;
        }
        
        #warning p { 
            font-size: clamp(15px, 2.3vw, 21px);
            text-align: center; 
            line-height: 2.1; 
            margin-bottom: 18px; 
            color: #5a5a5a; 
            opacity: 0;
            animation: lineAppearGlitch 1.5s forwards;
            animation-delay: var(--delay, 0s);
            max-width: 700px;
            padding: 0 15px;
            position: relative;
        }
        @keyframes lineAppearGlitch {
            0% { 
                opacity: 0; 
                transform: translateX(-5px);
                filter: blur(3px);
            }
            70% {
                opacity: 0.95;
            }
            100% { 
                opacity: 0.92; 
                transform: translateX(0);
                filter: blur(0);
            }
        }
        
        #warning .ominous {
            color: #4a0000;
            font-size: clamp(16px, 2.5vw, 22px);
            margin-bottom: 22px;
            letter-spacing: 1px;
            animation: ominousFlicker 5s infinite;
            text-shadow: 0 0 20px rgba(74, 0, 0, 0.6);
        }
        @keyframes ominousFlicker {
            0%, 94%, 100% { 
                opacity: 0.88;
            }
            95%, 97% {
                opacity: 0.5;
            }
            96%, 98% {
                opacity: 0.95;
            }
        }
        
        #warning .critical {
            color: #7a0000;
            font-size: clamp(19px, 3.5vw, 28px);
            font-weight: 700;
            margin-top: 15px;
            margin-bottom: 18px;
            letter-spacing: 4px;
            animation: criticalStatic 6s infinite;
            line-height: 1.6;
            text-shadow: 0 0 25px rgba(122, 0, 0, 0.9);
            position: relative;
        }
        @keyframes criticalStatic {
            0%, 85%, 100% { 
                opacity: 1;
                transform: translate(0, 0);
            }
            86%, 88%, 90%, 92% {
                opacity: 0.7;
                transform: translate(calc(var(--x, 0) * 1px), 0);
            }
            87%, 89%, 91%, 93% {
                opacity: 0.95;
                transform: translate(calc(var(--x, 0) * -1px), 0);
            }
        }
        
        #warning .epilepsy-warning {
            color: #8a0000;
            font-size: clamp(17px, 3vw, 24px);
            font-weight: 700;
            margin-bottom: 14px;
            opacity: 0;
            animation: epilepsyPulse 3s infinite;
            line-height: 1.6;
            text-shadow: 0 0 30px rgba(138, 0, 0, 0.9);
            letter-spacing: 2px;
        }
        @keyframes epilepsyPulse {
            0%, 100% { 
                opacity: 0.85;
                transform: scale(1);
            }
            50% { 
                opacity: 1;
                transform: scale(1.02);
            }
        }
        
        #warning .subtle-warning {
            font-size: clamp(12px, 1.9vw, 16px);
            color: #3a3a3a;
            margin-top: 35px;
            margin-bottom: 10px;
            opacity: 0.45;
            line-height: 1.9;
            max-width: 600px;
            animation: subtleBreath 7s infinite;
        }
        @keyframes subtleBreath {
            0%, 100% { opacity: 0.4; }
            50% { opacity: 0.6; }
        }
        
        #warning .disclaimer {
            font-size: clamp(10px, 1.6vw, 13px);
            color: #2a2a2a;
            margin-top: 20px;
            margin-bottom: 35px;
            opacity: 0.3;
            line-height: 1.7;
            max-width: 550px;
            font-style: italic;
        }
        
        #warning button { 
            font-family: 'Courier Prime', monospace; 
            font-size: clamp(17px, 3vw, 26px);
            padding: clamp(15px, 3.2vw, 24px) clamp(35px, 7.5vw, 80px);
            background: #0f0000; 
            color: #6a0000; 
            border: 2px solid #4a0000; 
            cursor: pointer; 
            margin-top: 45px;
            transition: all 0.3s ease; 
            letter-spacing: clamp(4px, 1.2vw, 6px);
            min-height: 60px;
            touch-action: manipulation;
            font-weight: 700;
            opacity: 0;
            animation: buttonMaterialize 2.5s forwards 3.5s;
            border-radius: 1px;
            position: relative;
            overflow: hidden;
            text-shadow: 0 0 15px rgba(106, 0, 0, 0.8);
            box-shadow: 
                0 0 20px rgba(106, 0, 0, 0.3),
                inset 0 0 20px rgba(106, 0, 0, 0.1);
        }
        @keyframes buttonMaterialize {
            0% {
                opacity: 0;
                transform: scale(0.95);
                filter: blur(5px);
            }
            70% {
                opacity: 0.9;
                transform: scale(1.01);
            }
            100% { 
                opacity: 0.88; 
                transform: scale(1);
                filter: blur(0);
            }
        }
        
        #warning button::before {
            content: '';
            position: absolute;
            top: 0; left: -100%;
            width: 100%; height: 100%;
            background: linear-gradient(90deg, transparent, rgba(106, 0, 0, 0.3), transparent);
            transition: left 0.5s;
        }
        
        #warning button:hover::before, #warning button:active::before {
            left: 100%;
        }
        
        #warning button:hover, #warning button:active { 
            background: #1a0000; 
            color: #8a0000; 
            border-color: #6a0000;
            box-shadow: 
                0 0 40px rgba(138, 0, 0, 0.7),
                inset 0 0 30px rgba(138, 0, 0, 0.2);
            opacity: 1;
            transform: scale(1.03);
            text-shadow: 0 0 20px rgba(138, 0, 0, 1);
        }
        
        #warning button:active {
            transform: scale(0.98);
        }
        
        /* GLITCH OVERLAY */
        #warning::after {
            content: '';
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: linear-gradient(
                rgba(20, 0, 0, 0) 50%,
                rgba(0, 20, 0, 0.05) 50%
            );
            background-size: 100% 4px;
            pointer-events: none;
            opacity: 0;
            animation: glitchOverlay 13s infinite;
            z-index: 2;
        }
        @keyframes glitchOverlay {
            0%, 96%, 100% { opacity: 0; }
            97%, 98% { opacity: 0.3; }
        }
        
        /* TEXT CORRUPTION EFFECT */
        .warning-block::before {
            content: attr(data-glitch);
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            opacity: 0;
            pointer-events: none;
            animation: textCorrupt 15s infinite;
        }
        @keyframes textCorrupt {
            0%, 94%, 100% { 
                opacity: 0; 
                transform: translate(0, 0);
            }
            95% {
                opacity: 0.5;
                transform: translate(-2px, 0);
                color: #f00;
            }
            96% {
                opacity: 0.4;
                transform: translate(2px, 0);
                color: #0ff;
            }
            97% {
                opacity: 0;
                transform: translate(0, 0);
            }
        }
        
        /* RANDOM STATIC FLASHES */
        @keyframes randomStatic {
            0%, 97%, 100% { opacity: 0; }
            98% { opacity: 0.15; }
            99% { opacity: 0.05; }
        }
        
        #warning-content::after {
            content: '';
            position: absolute;
            top: -50%; left: -50%;
            width: 200%; height: 200%;
            background: repeating-linear-gradient(
                45deg,
                transparent 0,
                transparent 2px,
                rgba(100, 0, 0, 0.1) 2px,
                rgba(100, 0, 0, 0.1) 4px
            );
            pointer-events: none;
            opacity: 0;
            animation: randomStatic 11s infinite;
        }
        
        /* FINAL HORROR - BLOOD WORD SMILE */
        #final-horror-container {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            display: none;
            z-index: 9999;
            background: #000;
        }
        
        .final-word {
            position: absolute;
            font-family: 'Courier Prime', monospace;
            font-size: clamp(12px, 2vw, 18px);
            color: #4a4a4a;
            opacity: 0;
            pointer-events: none;
            white-space: nowrap;
            font-weight: 400;
            transition: all 2s ease-out;
        }
        
        .final-word.bloodify {
            color: #8a0000;
            opacity: 0.9;
            font-weight: 700;
            text-shadow: 0 0 20px rgba(138, 0, 0, 0.9);
            animation: wordPulse 1.5s infinite;
        }
        
        @keyframes wordPulse {
            0%, 100% { 
                opacity: 0.85;
                transform: scale(1);
            }
            50% { 
                opacity: 1;
                transform: scale(1.05);
            }
        }
        
        .final-word.positioned {
            transition: all 3s cubic-bezier(0.68, -0.55, 0.27, 1.55);
        }
        
        /* CREEPY SMILE FACE */
        .smile-container {
            position: absolute;
            top: 45%; left: 50%;
            transform: translate(-50%, -55%);
            width: clamp(300px, 60vw, 600px);
            height: clamp(300px, 60vw, 600px);
            opacity: 0;
            pointer-events: none;
        }
        
        /* SUBLIMINAL FLASH */
        .subliminal-flash {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: #000;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            pointer-events: none;
            z-index: 10000;
        }
        
        .subliminal-flash.active {
            animation: subliminalFlash 0.1s;
        }
        
        @keyframes subliminalFlash {
            0%, 100% { opacity: 0; }
            50% { opacity: 1; }
        }
        
        .subliminal-image {
            font-size: clamp(40px, 15vw, 180px);
            color: #8a0000;
            font-weight: 700;
            text-shadow: 0 0 50px rgba(138, 0, 0, 1);
            opacity: 0.95;
        }
        
        /* FINAL DISTORTION */
        @keyframes finalDistortion {
            0% { 
                filter: blur(0) contrast(1);
            }
            25% {
                filter: blur(3px) contrast(2) saturate(3);
            }
            50% {
                filter: blur(0) contrast(1.5) saturate(2) hue-rotate(10deg);
            }
            75% {
                filter: blur(5px) contrast(3) saturate(0);
            }
            100% {
                filter: blur(0) contrast(1);
            }
        }
        
        /* EXPERIENCE CONTAINER */
        #experience {
            display: none;
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: #000;
            overflow: hidden;
            perspective: 1200px;
        }

        #content {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 90%;
            max-width: 1000px;
            text-align: center;
            padding: 0 15px;
            transform: translate(calc(-50% + var(--focus-pan, 0px)), -50%) scale(var(--focus-scale, 1)) rotate(var(--focus-tilt, 0deg));
            filter: blur(var(--focus-blur, 0px)) contrast(var(--focus-contrast, 1.12)) saturate(1.05);
            transform-origin: center;
            transition: transform 1.8s cubic-bezier(0.25, 0.1, 0.25, 1), filter 1.8s ease;
        }
        
        /* HYPNOTIC TEXT STYLES */
        .line {
            font-size: clamp(22px, 4.5vw, 38px);
            line-height: 2.2;
            color: #e4dcd5;
            opacity: 0;
            margin: 0;
            letter-spacing: clamp(1px, 0.6vw, 3px);
            position: relative;
            text-shadow:
                0 0 22px rgba(0, 0, 0, 0.9),
                0 0 12px rgba(138, 0, 0, 0.35);
            transition: color 0.6s ease, text-shadow 0.6s ease, letter-spacing 0.6s ease;
        }
        .line.active {
            animation: hypnoticAppear 1.2s forwards;
        }
        .line.active::after {
            content: '';
            position: absolute;
            inset: 5% 18%;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(210, 196, 180, 0.22) 0%, rgba(106, 0, 0, 0.05) 60%, transparent 100%);
            filter: blur(18px);
            opacity: 0.35;
            pointer-events: none;
        }
        @keyframes hypnoticAppear {
            0% { 
                opacity: 0; 
                transform: scale(0.92); 
                filter: blur(8px);
            }
            70% {
                opacity: 1;
                transform: scale(1.02);
                filter: blur(0);
            }
            100% { 
                opacity: 1; 
                transform: scale(1); 
                filter: blur(0);
            }
        }
        
        .line.blood { 
            color: #5a0000; 
            font-weight: 700; 
            text-shadow: 0 0 25px rgba(90, 0, 0, 0.7); 
            animation: bloodPulse 3s infinite;
        }
        @keyframes bloodPulse {
            0%, 100% { 
                opacity: 0.8;
                text-shadow: 0 0 20px rgba(90, 0, 0, 0.6);
            }
            50% { 
                opacity: 1;
                text-shadow: 0 0 35px rgba(90, 0, 0, 0.9);
            }
        }
        
        .line .cold { 
            color: #2a4a5a; 
            text-shadow: 0 0 12px rgba(42, 74, 90, 0.5); 
            letter-spacing: clamp(2px, 0.8vw, 5px);
        }
        .line .pain { 
            color: #5a0000;
            animation: painPulseHeart 1.2s infinite;
        }
        @keyframes painPulseHeart {
            0%, 100% {
                color: #5a0000;
                transform: scale(1);
                text-shadow: 0 0 8px rgba(90, 0, 0, 0.5);
            }
            50% {
                color: #8a0000;
                transform: scale(1.04);
                text-shadow: 0 0 22px rgba(138, 0, 0, 0.9);
            }
        }
        
        .line .death { 
            color: #3a3a3a;
            text-shadow: 0 0 12px rgba(0, 0, 0, 0.7);
            letter-spacing: clamp(4px, 1.2vw, 7px);
            opacity: 0.75;
            animation: deathStroopEffect 5s ease-in-out forwards;
        }
        @keyframes deathStroopEffect {
            0% { 
                color: #3a3a3a;
                text-shadow: 0 0 12px rgba(0, 0, 0, 0.7);
            }
            60% {
                color: #2a2a2a;
            }
            100% { 
                color: #4a0000;
                text-shadow: 0 0 18px rgba(74, 0, 0, 0.8);
                opacity: 0.9;
            }
        }
        
        .line .scream { 
            color: #6a0000;
            animation: screamVibrate 0.08s infinite, screamIntensity 0.4s ease-out;
            font-weight: 700;
        }
        @keyframes screamVibrate {
            0%, 100% { 
                transform: translate(0, 0) scale(1);
                letter-spacing: 0.05em;
            }
            20% { transform: translate(-1px, 1px) scale(1.02); }
            40% { transform: translate(1px, -1px) scale(0.99); }
            60% { transform: translate(-1px, -1px) scale(1.01); }
            80% { transform: translate(1px, 1px) scale(1); }
        }
        @keyframes screamIntensity {
            0% { 
                opacity: 0.5; 
                text-shadow: 0 0 5px rgba(106, 0, 0, 0.5); 
            }
            100% { 
                opacity: 1; 
                text-shadow: 0 0 35px rgba(138, 0, 0, 1);
                color: #8a0000;
            }
        }
        
        .line .void { 
            color: #2a2a2a;
            letter-spacing: clamp(5px, 1.4vw, 9px);
            animation: voidDissolve 4s ease-in-out infinite;
        }
        @keyframes voidDissolve {
            0%, 100% { 
                opacity: 0.65;
                letter-spacing: clamp(5px, 1.4vw, 9px);
                filter: blur(0);
                text-shadow: 0 0 15px rgba(0, 0, 0, 0.8);
            }
            50% { 
                opacity: 0.3;
                letter-spacing: clamp(8px, 2vw, 14px);
                filter: blur(1px);
                text-shadow: 0 0 25px rgba(0, 0, 0, 1);
            }
        }
        
        .line .machine-word { 
            color: #4a4a4a;
            letter-spacing: 2px;
            font-weight: 700;
            animation: mechanicalPulse 1.5s ease-in-out infinite;
            font-family: 'Courier Prime', monospace;
        }
        @keyframes mechanicalPulse {
            0%, 100% {
                letter-spacing: 2px;
                opacity: 0.8;
                text-shadow: 0 0 8px rgba(74, 74, 74, 0.5);
            }
            50% {
                letter-spacing: 1px;
                opacity: 0.95;
                text-shadow: 0 0 15px rgba(74, 74, 74, 0.7);
            }
        }
        
        .line .cold {
            color: #3a5a5a;
            animation: freezeEffect 6s ease-in forwards;
        }
        @keyframes freezeEffect {
            0% {
                color: #4a4a4a;
                filter: blur(0);
                letter-spacing: 0;
            }
            100% {
                color: #2a4a5a;
                letter-spacing: 0.35em;
                filter: blur(0.5px);
                opacity: 0.55;
            }
        }
        
        .line .filth {
            color: #3a2a1a;
            text-shadow: 0 0 12px rgba(58, 42, 26, 0.7);
        }

        .line.breathing {
            animation: lineBreath 6s ease-in-out infinite;
        }
        @keyframes lineBreath {
            0%, 100% {
                letter-spacing: clamp(1px, 0.6vw, 3px);
                text-shadow:
                    0 0 28px rgba(0, 0, 0, 0.85),
                    0 0 18px rgba(138, 0, 0, 0.35);
            }
            45% {
                letter-spacing: clamp(2px, 0.9vw, 6px);
                text-shadow:
                    0 0 40px rgba(0, 0, 0, 0.95),
                    0 0 28px rgba(180, 60, 60, 0.35);
            }
        }

        .line.tremor {
            animation: lineTremor 0.35s infinite;
        }
        @keyframes lineTremor {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-3px); }
            50% { transform: translateX(2px); }
            75% { transform: translateX(-1px); }
        }

        .line.active.breathing {
            animation: hypnoticAppear 1.2s forwards, lineBreath 6s ease-in-out 1.2s infinite;
        }

        .line.active.tremor {
            animation: hypnoticAppear 1.2s forwards, lineTremor 0.35s 1.2s infinite;
        }

        .line .focus-word {
            color: #f8f2ea;
            font-weight: 700;
            letter-spacing: clamp(2px, 1vw, 6px);
            text-shadow:
                0 0 28px rgba(255, 240, 220, 0.65),
                0 0 18px rgba(106, 0, 0, 0.35);
        }

        .line .pulse-accent {
            color: #f23d3d;
            font-weight: 700;
            letter-spacing: clamp(2px, 0.9vw, 6px);
            text-transform: uppercase;
            text-shadow:
                0 0 18px rgba(242, 61, 61, 0.75),
                0 0 40px rgba(90, 0, 0, 0.65);
            animation: focusPulse 1.8s ease-in-out infinite;
        }
        @keyframes focusPulse {
            0%, 100% {
                transform: scale(1);
                opacity: 0.9;
            }
            40% {
                transform: scale(1.06);
                opacity: 1;
            }
            65% {
                transform: scale(0.97);
                opacity: 0.8;
            }
        }

        .line .ashen {
            color: #b9b2ac;
            font-style: italic;
            letter-spacing: clamp(3px, 1.1vw, 7px);
            text-shadow: 0 0 18px rgba(120, 110, 102, 0.7);
        }

        .line .ghost-echo {
            color: #aab8d6;
            letter-spacing: clamp(4px, 1.3vw, 9px);
            text-shadow:
                0 0 14px rgba(170, 184, 214, 0.6),
                0 0 35px rgba(40, 50, 80, 0.55);
            animation: ghostEcho 3.8s ease-in-out infinite;
        }
        @keyframes ghostEcho {
            0%, 100% {
                opacity: 0.7;
                filter: blur(0.2px);
            }
            45% {
                opacity: 1;
                filter: blur(0);
            }
        }

        .line .ember {
            color: #ff834d;
            text-shadow:
                0 0 18px rgba(255, 131, 77, 0.8),
                0 0 28px rgba(138, 30, 0, 0.5);
            animation: emberFlicker 2.6s ease-in-out infinite;
        }
        @keyframes emberFlicker {
            0%, 100% { opacity: 0.8; }
            30% { opacity: 1; }
            55% { opacity: 0.6; }
        }

        /* BREAKING FOURTH WALL - INTENSE */
        .line.break-wall {
            color: #ddd !important;
            font-size: clamp(26px, 5.5vw, 52px) !important;
            text-shadow: 0 0 40px rgba(221,221,221,0.4);
            animation: breakWallHypnotic 0.4s forwards, textHypnoticBreath 4s infinite;
            z-index: 1000;
            font-weight: 700;
            letter-spacing: clamp(2px, 1vw, 6px);
        }
        @keyframes breakWallHypnotic {
            0% { 
                opacity: 0; 
                transform: scale(0.85); 
                filter: blur(15px);
            }
            60% {
                opacity: 1;
                transform: scale(1.08);
                filter: blur(0);
            }
            100% { 
                opacity: 1; 
                transform: scale(1); 
                filter: blur(0);
            }
        }
        @keyframes textHypnoticBreath {
            0%, 100% { 
                transform: scale(1); 
                text-shadow: 0 0 30px rgba(221,221,221,0.3);
            }
            50% { 
                transform: scale(1.04); 
                text-shadow: 0 0 50px rgba(221,221,221,0.6);
            }
        }
        
        /* GLITCH - MORE INTENSE */
        .line.glitched {
            animation: textGlitchIntense 0.15s infinite;
        }
        @keyframes textGlitchIntense {
            0% { 
                transform: translate(0);
                text-shadow: -4px 0 #6a0000, 4px 0 #006a6a;
                filter: hue-rotate(0deg) contrast(1.2);
            }
            20% {
                transform: translate(-7px, 4px);
                text-shadow: -8px 0 #8a0000, 8px 0 #008a8a;
                filter: hue-rotate(90deg) contrast(1.4);
            }
            40% {
                transform: translate(7px, -4px);
                text-shadow: 8px 0 #8a0000, -8px 0 #008a8a;
                filter: hue-rotate(180deg) contrast(1.6);
            }
            60% {
                transform: translate(-4px, -3px);
                text-shadow: -6px 0 #8a0000, 6px 0 #008a8a;
                filter: hue-rotate(270deg) contrast(1.3);
            }
            80% {
                transform: translate(4px, 3px);
                text-shadow: 6px 0 #8a0000, -6px 0 #008a8a;
                filter: hue-rotate(360deg) contrast(1.5);
            }
            100% {
                transform: translate(0);
                text-shadow: -4px 0 #6a0000, 4px 0 #006a6a;
                filter: hue-rotate(0deg) contrast(1.2);
            }
        }
        
        /* DISTORTION - MORE ORGANIC */
        .line.distorted {
            animation: distortOrganic 0.5s;
        }
        @keyframes distortOrganic {
            0%, 100% { 
                transform: scale(1, 1) skew(0deg); 
                letter-spacing: clamp(1px, 0.6vw, 3px);
                opacity: 1;
            }
            20% { 
                transform: scale(1.15, 0.85) skew(-2deg); 
                letter-spacing: clamp(6px, 2vw, 10px);
                opacity: 0.8;
            }
            40% { 
                transform: scale(0.85, 1.15) skew(2deg); 
                letter-spacing: clamp(0px, 0.1vw, 0.5px);
                opacity: 0.9;
            }
            60% { 
                transform: scale(1.08, 0.92) skew(-1deg); 
                letter-spacing: clamp(3px, 1.2vw, 6px);
                opacity: 0.85;
            }
            80% { 
                transform: scale(0.92, 1.08) skew(1deg); 
                letter-spacing: clamp(2px, 0.8vw, 4px);
                opacity: 0.95;
            }
        }
        
        /* SHAKE - MORE VIOLENT */
        .shake { 
            animation: shakeViolent 0.5s; 
        }
        @keyframes shakeViolent { 
            0%, 100% { transform: translate(-50%, -50%); } 
            10% { transform: translate(calc(-50% - 30px), calc(-50% + 15px)) rotate(-2deg); } 
            20% { transform: translate(calc(-50% + 35px), calc(-50% - 12px)) rotate(2deg); } 
            30% { transform: translate(calc(-50% - 28px), calc(-50% + 18px)) rotate(-1deg); } 
            40% { transform: translate(calc(-50% + 32px), calc(-50% - 15px)) rotate(1.5deg); } 
            50% { transform: translate(calc(-50% - 25px), calc(-50% + 10px)) rotate(-1.5deg); } 
            60% { transform: translate(calc(-50% + 28px), calc(-50% - 8px)) rotate(1deg); } 
            70% { transform: translate(calc(-50% - 20px), calc(-50% + 12px)) rotate(-1deg); } 
            80% { transform: translate(calc(-50% + 22px), calc(-50% - 10px)) rotate(0.5deg); } 
            90% { transform: translate(calc(-50% - 15px), calc(-50% + 8px)) rotate(-0.5deg); } 
        }
        
        /* VISUAL EFFECTS - ENHANCED */
        .text-trail { animation: trailIntense 1.2s; }
        @keyframes trailIntense { 
            0% { 
                text-shadow: 12px 0 20px currentColor, 
                             24px 0 35px currentColor, 
                             36px 0 50px currentColor; 
                opacity: 1;
            } 
            100% { 
                text-shadow: 0 0 0 transparent; 
                opacity: 1;
            } 
        }
        
        .double-vision { animation: doubleVisionIntense 0.5s; }
        @keyframes doubleVisionIntense { 
            0%, 100% { text-shadow: 0 0 0 transparent; } 
            50% { 
                text-shadow: 15px 0 0 rgba(80,80,80,0.7), 
                             -15px 0 0 rgba(80,80,80,0.7); 
            } 
        }
        
        .time-freeze { animation: freezeIntense 2.5s; }
        @keyframes freezeIntense { 
            0%, 100% { opacity: 1; filter: blur(0) brightness(1) contrast(1); } 
            50% { opacity: 0.15; filter: blur(8px) brightness(0.3) contrast(1.5); } 
        }
        
        /* BLACKOUT - DEEPER */
        .blackout {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: #000;
            opacity: 0;
            pointer-events: none;
            z-index: 500;
        }
        .blackout.active {
            animation: blackoutDeep 0.2s forwards;
        }
        @keyframes blackoutDeep {
            to { opacity: 1; }
        }
        
        /* STROBE - MORE VIOLENT */
        .strobe {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: #fff;
            opacity: 0;
            pointer-events: none;
            z-index: 550;
        }
        .strobe.active {
            animation: strobeViolent 0.03s infinite;
        }
        @keyframes strobeViolent {
            0%, 100% { opacity: 0; }
            50% { opacity: 0.95; }
        }
        
        /* CHROMATIC - MORE INTENSE */
        .chromatic {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            z-index: 560;
            opacity: 0;
            mix-blend-mode: screen;
        }
        .chromatic.active {
            animation: chromaticIntense 0.2s infinite;
            opacity: 0.75;
        }
        @keyframes chromaticIntense {
            0% { 
                background: radial-gradient(circle, rgba(139,0,0,0.5) 0%, transparent 40%);
                transform: translate(-5px, 0);
            }
            50% { 
                background: radial-gradient(circle, rgba(0,139,139,0.5) 0%, transparent 40%);
                transform: translate(5px, 0);
            }
            100% { 
                background: radial-gradient(circle, rgba(139,0,0,0.5) 0%, transparent 40%);
                transform: translate(-5px, 0);
            }
        }
        
        /* WATER/BLOOD DROPS - ENHANCED */
        .water-drop {
            position: fixed;
            width: 3px;
            background: linear-gradient(to bottom, transparent, rgba(42, 74, 90, 0.8), transparent);
            pointer-events: none;
            z-index: 610;
            opacity: 0;
        }
        .water-drop.active {
            animation: dropFallSlow 3s linear forwards;
        }
        @keyframes dropFallSlow {
            0% { 
                opacity: 0;
                top: -10px;
            }
            15% {
                opacity: 0.9;
            }
            100% {
                opacity: 0.4;
                top: 100%;
            }
        }
        
        .blood-drop {
            position: fixed;
            width: 4px;
            background: linear-gradient(to bottom, transparent, rgba(90, 0, 0, 0.95), rgba(90, 0, 0, 0.5));
            pointer-events: none;
            z-index: 620;
            opacity: 0;
        }
        .blood-drop.active {
            animation: bloodDripSlow 4s ease-in forwards;
        }
        @keyframes bloodDripSlow {
            0% { 
                opacity: 0;
                top: -20px;
            }
            12% {
                opacity: 1;
            }
            100% {
                opacity: 0.7;
                top: 100%;
                filter: blur(1.5px);
            }
        }
        
        /* FOG BREATH */
        .breath-fog {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 400px;
            height: 400px;
            background: radial-gradient(circle, rgba(100,100,100,0.08) 0%, transparent 65%);
            border-radius: 50%;
            pointer-events: none;
            opacity: 0;
            z-index: 630;
            filter: blur(30px);
        }
        .breath-fog.active {
            animation: breathFogSlow 5s ease-in-out forwards;
        }
        @keyframes breathFogSlow {
            0% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.4);
            }
            35% {
                opacity: 0.5;
                transform: translate(-50%, -50%) scale(1);
            }
            100% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(1.8);
            }
        }
        
        /* SCREEN CRACK */
        .screen-crack {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            opacity: 0;
            z-index: 640;
            background: 
                linear-gradient(45deg, transparent 48%, rgba(90,90,90,0.25) 49%, rgba(90,90,90,0.25) 51%, transparent 52%),
                linear-gradient(-45deg, transparent 48%, rgba(80,80,80,0.2) 49%, rgba(80,80,80,0.2) 51%, transparent 52%),
                linear-gradient(23deg, transparent 48%, rgba(70,70,70,0.15) 49%, rgba(70,70,70,0.15) 51%, transparent 52%);
        }
        .screen-crack.active {
            animation: crackAppearSlow 0.4s forwards;
        }
        @keyframes crackAppearSlow {
            0% {
                opacity: 0;
                transform: scale(0.85);
            }
            60% {
                opacity: 1;
                transform: scale(1.1);
            }
            100% {
                opacity: 0.4;
                transform: scale(1);
            }
        }
        
        /* WET STAINS */
        .wet-stain {
            position: fixed;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(30,30,50,0.4) 0%, transparent 65%);
            pointer-events: none;
            opacity: 0;
            z-index: 650;
            filter: blur(8px);
        }
        .wet-stain.active {
            animation: stainSpreadSlow 4s ease-out forwards;
        }
        @keyframes stainSpreadSlow {
            0% {
                opacity: 0;
                transform: scale(0);
            }
            35% {
                opacity: 0.7;
            }
            100% {
                opacity: 0.4;
                transform: scale(1);
            }
        }
        
        /* OVERLAYS - OPPRESSIVE */
        .breath-overlay { 
            position: fixed; 
            top: 0; left: 0; 
            width: 100%; height: 100%; 
            background: radial-gradient(circle, transparent 10%, #000 100%); 
            pointer-events: none; 
            animation: breatheOppressive 7s infinite; 
            z-index: 100; 
            opacity: 0.3;
        }
        @keyframes breatheOppressive { 
            0%, 100% { 
                opacity: 0.2; 
                transform: scale(1); 
            } 
            50% { 
                opacity: 0.85; 
                transform: scale(1.05); 
            } 
        }
        
        .vignette { 
            position: fixed; 
            top: 0; left: 0; 
            width: 100%; height: 100%; 
            box-shadow: inset 0 0 500px rgba(0,0,0,0.95); 
            pointer-events: none; 
            z-index: 50; 
            transition: box-shadow 4s; 
        }
        
        .static { 
            position: fixed; 
            top: 0; left: 0; 
            width: 100%; height: 100%; 
            pointer-events: none; 
            opacity: 0.12; 
            z-index: 200; 
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 400 400' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)'/%3E%3C/svg%3E"); 
            animation: staticMoveErratic 0.15s steps(12) infinite; 
            transition: opacity 4s; 
        }
        @keyframes staticMoveErratic { 
            0% { transform: translate(0, 0); } 
            20% { transform: translate(-6%, 6%); } 
            40% { transform: translate(6%, -6%); } 
            60% { transform: translate(-5%, -5%); }
            80% { transform: translate(5%, 5%); } 
            100% { transform: translate(-3%, 3%); } 
        }
        
        .blood-screen { 
            position: fixed; 
            top: 0; left: 0; 
            width: 100%; height: 100%; 
            background: radial-gradient(circle at center, transparent 0%, rgba(90,0,0,0.6) 100%); 
            pointer-events: none; 
            opacity: 0; 
            z-index: 150; 
            transition: opacity 2.5s; 
        }
        .blood-screen.active { opacity: 1; }
        
        .red-flicker { 
            position: fixed; 
            top: 0; left: 0; 
            width: 100%; height: 100%; 
            background: rgba(90, 0, 0, 0.3); 
            pointer-events: none; 
            opacity: 0; 
            z-index: 80; 
        }
        .red-flicker.active { animation: redFlickerIntense 0.06s infinite; }
        @keyframes redFlickerIntense { 
            0%, 100% { opacity: 0; } 
            50% { opacity: 0.35; } 
        }
        
        /* PERIPHERAL HORROR */
        .peripheral-horror {
            position: fixed;
            width: 180px;
            height: 100%;
            pointer-events: none;
            opacity: 0;
            z-index: 130;
            background: radial-gradient(circle, rgba(15,0,0,0.98) 0%, transparent 75%);
        }
        .peripheral-horror.left { left: 0; top: 0; }
        .peripheral-horror.right { right: 0; top: 0; }
        .peripheral-horror.active {
            animation: peripheralFlashIntense 0.15s;
        }
        @keyframes peripheralFlashIntense {
            0%, 100% { opacity: 0; }
            50% { opacity: 0.95; }
        }
        
        /* SHADOWS */
        .shadow { 
            position: fixed; 
            width: 300px; 
            height: 100%; 
            background: radial-gradient(circle, rgba(0,0,0,0.99) 0%, transparent 65%); 
            pointer-events: none; 
            opacity: 0; 
            z-index: 120; 
        }
        .shadow.left { left: 0; top: 0; }
        .shadow.right { right: 0; top: 0; }
        .shadow.active { animation: shadowPassSlow 3s; }
        @keyframes shadowPassSlow { 
            0%, 100% { opacity: 0; } 
            50% { opacity: 0.98; } 
        }
        
        /* GRAIN */
        .grain { 
            position: fixed; 
            top: 0; left: 0; 
            width: 100%; height: 100%; 
            pointer-events: none; 
            opacity: 0; 
            z-index: 210; 
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='grainFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='3' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23grainFilter)' opacity='0.4'/%3E%3C/svg%3E"); 
            animation: grainMoveErratic 0.08s steps(10) infinite; 
            transition: opacity 4s; 
        }
        @keyframes grainMoveErratic { 
            0% { transform: translate(0, 0); } 
            25% { transform: translate(-4%, 4%); } 
            50% { transform: translate(4%, -4%); } 
            75% { transform: translate(-4%, -4%); } 
            100% { transform: translate(4%, 4%); } 
        }
        
        /* WATCHING YOU */
        .watching-overlay {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            opacity: 0;
            z-index: 600;
            background: radial-gradient(circle at var(--x, 50%) var(--y, 50%), 
                transparent 0%, 
                transparent 10%,
                rgba(90,0,0,0.15) 20%,
                rgba(0,0,0,0.95) 50%);
        }
        .watching-overlay.active {
            animation: watchingPulseSlow 5s;
        }
        @keyframes watchingPulseSlow {
            0%, 100% { opacity: 0; }
            50% { opacity: 1; }
        }
        
        /* SCREEN TEAR */
        .screen-tear {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            opacity: 0;
            z-index: 570;
        }
        .screen-tear.active {
            animation: tearIntense 0.6s;
        }
        @keyframes tearIntense {
            0% { 
                opacity: 0;
                transform: translateY(0);
            }
            12% {
                opacity: 1;
                transform: translateY(-25px);
                background: linear-gradient(transparent 46%, #ddd 46%, #ddd 54%, transparent 54%);
            }
            25% {
                transform: translateY(20px);
                background: linear-gradient(transparent 66%, #ddd 66%, #ddd 74%, transparent 74%);
            }
            38% {
                transform: translateY(-15px);
                background: linear-gradient(transparent 26%, #ddd 26%, #ddd 34%, transparent 34%);
            }
            100% {
                opacity: 0;
                transform: translateY(0);
            }
        }
        
        /* TIME DISTORTION */
        .time-distortion {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            opacity: 0;
            z-index: 580;
        }
        .time-distortion.active {
            animation: timeWarpIntense 4s;
        }
        @keyframes timeWarpIntense {
            0%, 100% { 
                opacity: 0;
                filter: blur(0);
            }
            25% {
                opacity: 0.4;
                filter: blur(15px);
            }
            50% { 
                opacity: 0.7;
                filter: blur(8px);
                background: radial-gradient(circle, transparent 30%, rgba(0,0,30,0.6) 100%);
            }
            75% {
                opacity: 0.4;
                filter: blur(20px);
            }
        }
        
        /* SUBLIMINAL */
        .subliminal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: clamp(36px, 9vw, 84px);
            color: rgba(80, 80, 80, 0.08);
            pointer-events: none;
            opacity: 0;
            z-index: 590;
            font-weight: 700;
            letter-spacing: clamp(3px, 1.5vw, 10px);
        }
        .subliminal.active {
            animation: subliminalFlashQuick 0.04s;
        }
        @keyframes subliminalFlashQuick {
            0%, 100% { opacity: 0; }
            50% { opacity: 0.2; }
        }
        
        /* HEARTBEAT */
        .heartbeat {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(90, 0, 0, 0.15);
            pointer-events: none;
            opacity: 0;
            z-index: 85;
        }
        .heartbeat.active {
            animation: heartbeatPulseSlow 1.4s infinite;
        }
        @keyframes heartbeatPulseSlow {
            0%, 100% { opacity: 0; transform: scale(1); }
            12% { opacity: 0.4; transform: scale(1.015); }
            24% { opacity: 0; transform: scale(1); }
            36% { opacity: 0.5; transform: scale(1.02); }
            48% { opacity: 0; transform: scale(1); }
        }
        
        /* REALITY GLITCH */
        .reality-glitch {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            opacity: 0;
            z-index: 595;
            mix-blend-mode: difference;
        }
        .reality-glitch.active {
            animation: realityBreakIntense 0.4s;
        }
        @keyframes realityBreakIntense {
            0%, 100% { 
                opacity: 0;
                background: transparent;
            }
            20% {
                opacity: 0.9;
                background: repeating-linear-gradient(0deg, #8a0000 0px, #8a0000 2px, #008a8a 2px, #008a8a 4px);
            }
            40% {
                opacity: 0.7;
                background: repeating-linear-gradient(90deg, #008a00 0px, #008a00 3px, #8a008a 3px, #8a008a 6px);
            }
            60% {
                opacity: 0.95;
                background: repeating-linear-gradient(45deg, #8a8a00 0px, #8a8a00 2px, #00008a 2px, #00008a 4px);
            }
        }
        
        /* OBSESSION FIELD */
        #obsessive-words {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            overflow: hidden;
            z-index: 68;
            mix-blend-mode: screen;
            filter: contrast(0.95) saturate(0.85);
        }
        #obsessive-words::before {
            content: '';
            position: absolute;
            inset: 0;
            background: radial-gradient(circle at 50% 40%, transparent 0%, rgba(0,0,0,0.35) 65%, rgba(0,0,0,0.85) 100%);
            opacity: 0.35;
            pointer-events: none;
            transition: opacity 6s ease;
        }
        #obsessive-words[data-phase='2']::before {
            opacity: 0.55;
        }
        #obsessive-words[data-phase='3']::before {
            opacity: 0.75;
        }
        #obsessive-words[data-phase='0'] {
            mix-blend-mode: normal;
        }

        /* OBSESSIVE WORDS */
        .obsessive-word {
            position: absolute;
            font-family: 'Courier Prime', monospace;
            font-size: clamp(12px, 2.2vw, 20px);
            color: #3a3a3a;
            pointer-events: none;
            opacity: 0;
            z-index: 70;
            letter-spacing: 0.18em;
            font-weight: 700;
            transform: translate(-50%, -50%);
            transition: color 3s ease, text-shadow 3s ease;
            will-change: transform, opacity;
            filter: blur(1.4px);
        }
        .obsessive-word.active {
            animation: wordFadeInSlow 3s forwards;
        }
        @keyframes wordFadeInSlow {
            0% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.6);
                filter: blur(5px);
            }
            100% {
                opacity: 0.55;
                transform: translate(-50%, -50%) scale(1);
                filter: blur(1.1px);
            }
        }

        .obsessive-word.swarm {
            color: rgba(70, 70, 70, 0.55);
            text-shadow: 0 0 25px rgba(30, 30, 30, 0.4);
        }

        .obsessive-word.rorschach {
            color: rgba(90, 90, 90, 0.7);
            text-shadow:
                0 0 25px rgba(80, 0, 0, 0.4),
                0 0 55px rgba(0, 0, 0, 0.45);
            filter: blur(1px);
        }

        .obsessive-word.pulse {
            animation: obsessionPulse 4.5s ease-in-out infinite;
        }
        @keyframes obsessionPulse {
            0%, 100% {
                letter-spacing: 0.16em;
                text-shadow:
                    0 0 18px rgba(90, 0, 0, 0.35),
                    0 0 35px rgba(0, 0, 0, 0.6);
                filter: blur(0.9px);
            }
            45% {
                letter-spacing: 0.22em;
                text-shadow:
                    0 0 30px rgba(120, 0, 0, 0.6),
                    0 0 60px rgba(0, 0, 0, 0.7);
                filter: blur(0.4px);
            }
        }

        .obsessive-word.blood-sigil {
            color: rgba(138, 0, 0, 0.85);
            text-shadow:
                0 0 12px rgba(138, 0, 0, 0.8),
                0 0 38px rgba(180, 20, 20, 0.6);
            animation: bloodSigilPulse 3.6s ease-in-out infinite;
        }
        @keyframes bloodSigilPulse {
            0%, 100% {
                opacity: 0.75;
                filter: blur(0.6px) saturate(1.1);
            }
            50% {
                opacity: 1;
                filter: blur(0.2px) saturate(1.45);
            }
        }

        .obsessive-word.whisper {
            color: rgba(40, 40, 40, 0.4);
            text-shadow: 0 0 18px rgba(0, 0, 0, 0.55);
            letter-spacing: 0.24em;
            filter: blur(1.6px);
        }

        .obsessive-word.face-phase {
            color: rgba(210, 178, 162, 0.8);
            letter-spacing: 0.08em;
            text-shadow:
                0 0 12px rgba(255, 230, 210, 0.35),
                0 0 35px rgba(90, 0, 0, 0.45);
            filter: blur(1.4px);
            animation: faceBreath 5.5s ease-in-out infinite;
        }
        @keyframes faceBreath {
            0%, 100% {
                opacity: 0.65;
                letter-spacing: 0.08em;
            }
            45% {
                opacity: 0.92;
                letter-spacing: 0.14em;
            }
        }
        
        /* PAREIDOLIA WORDS - формируют образы */
        .obsessive-word.pareidolia {
            filter: blur(3px);
            opacity: 0;
            animation: pareidoliaForm 8s ease-in-out forwards;
        }
        @keyframes pareidoliaForm {
            0% {
                opacity: 0;
                filter: blur(8px);
            }
            40% {
                opacity: 0.4;
                filter: blur(3px);
            }
            60% {
                opacity: 0.6;
                filter: blur(2px);
            }
            100% {
                opacity: 0.35;
                filter: blur(3px);
            }
        }
        
        /* PERIPHERAL SHADOW MOVEMENT - замена курсора */
        .peripheral-shadow {
            position: fixed;
            width: 250px;
            height: 400px;
            background: radial-gradient(ellipse, rgba(20, 0, 0, 0.4) 0%, transparent 60%);
            pointer-events: none;
            opacity: 0;
            z-index: 150;
            filter: blur(40px);
            transition: all 0.8s ease-out;
        }
        .peripheral-shadow.active {
            opacity: 1;
            animation: shadowDrift 12s ease-in-out infinite;
        }
        @keyframes shadowDrift {
            0%, 100% {
                transform: translate(0, 0);
                opacity: 0.5;
            }
            25% {
                transform: translate(15vw, -10vh);
                opacity: 0.7;
            }
            50% {
                transform: translate(-10vw, 12vh);
                opacity: 0.6;
            }
            75% {
                transform: translate(12vw, 8vh);
                opacity: 0.8;
            }
        }
        
        /* FORGOTTEN WORDS */
        .forgotten-word { 
            position: fixed; 
            font-family: 'Courier Prime', monospace; 
            font-size: clamp(11px, 2vw, 16px);
            color: #1a1a1a; 
            pointer-events: none; 
            opacity: 0; 
            z-index: 65; 
            letter-spacing: 1px; 
            filter: blur(8px); 
        }
        .forgotten-word.active { animation: forgottenFadeInSlow 4s forwards; }
        @keyframes forgottenFadeInSlow { 
            0% { 
                opacity: 0; 
                filter: blur(15px); 
                transform: scale(0.7); 
            } 
            100% { 
                opacity: 0.4; 
                filter: blur(8px); 
                transform: scale(1); 
            } 
        }
        
        /* EMERGENCY EXIT - SUBTLE */
        #emergency-exit {
            position: fixed;
            bottom: 10px;
            right: 10px;
            padding: clamp(8px, 1.5vw, 12px) clamp(12px, 2.5vw, 20px);
            background: rgba(30, 0, 0, 0.15);
            color: rgba(80, 80, 80, 0.25);
            border: 1px solid rgba(80, 80, 80, 0.15);
            font-family: 'Courier Prime', monospace;
            font-size: clamp(9px, 1.5vw, 11px);
            cursor: pointer;
            z-index: 11000;
            opacity: 0.2;
            transition: all 0.4s;
            min-height: 40px;
            touch-action: manipulation;
        }
        #emergency-exit:hover, #emergency-exit:active {
            opacity: 0.8;
            background: rgba(50, 0, 0, 0.3);
            border-color: rgba(100, 100, 100, 0.4);
        }
        
        /* MOBILE OPTIMIZATIONS */
        @media (max-height: 700px) {
            #warning {
                padding: 25px 15px;
            }
            #warning-content {
                justify-content: flex-start;
                padding-top: 40px;
                padding-bottom: 40px;
            }
            #warning h1 {
                margin-bottom: 40px;
                font-size: clamp(30px, 6.5vw, 56px);
            }
            .warning-block {
                margin-bottom: 35px;
            }
            #warning p {
                margin-bottom: 14px;
                line-height: 1.9;
            }
            #warning .critical {
                margin-top: 35px;
                margin-bottom: 14px;
            }
            #warning button {
                margin-top: 35px;
                padding: clamp(13px, 2.8vw, 20px) clamp(28px, 6.5vw, 60px);
            }
        }
        
        @media (max-width: 600px) {
            #warning {
                padding: 20px 12px;
            }
            #warning-content {
                padding: 20px 12px;
            }
            #warning h1 {
                margin-bottom: 35px;
                font-size: clamp(28px, 7vw, 52px);
            }
            .warning-block {
                margin-bottom: 30px;
            }
            #warning p {
                font-size: clamp(14px, 3.8vw, 19px);
                line-height: 2;
                margin-bottom: 14px;
            }
            #warning .ominous {
                font-size: clamp(15px, 4vw, 20px);
            }
            #warning .critical {
                font-size: clamp(17px, 4.8vw, 24px);
                margin-top: 30px;
            }
            #warning .epilepsy-warning {
                font-size: clamp(16px, 4.2vw, 22px);
                margin-bottom: 12px;
            }
            #warning .subtle-warning {
                font-size: clamp(13px, 3.2vw, 17px);
            }
            #warning .disclaimer {
                font-size: clamp(11px, 2.8vw, 14px);
                margin-top: 18px;
                margin-bottom: 30px;
            }
            #warning button {
                font-size: clamp(16px, 4.5vw, 23px);
                margin-top: 35px;
            }
            .line {
                line-height: 2;
            }
            #content {
                width: 95%;
            }
        }
        
        @media (max-height: 500px) {
            #warning {
                overflow-y: auto;
                justify-content: flex-start;
                padding: 15px 10px;
            }
            #warning-content {
                padding-top: 25px;
                padding-bottom: 25px;
            }
            #warning h1 {
                margin-bottom: 25px;
                font-size: clamp(26px, 6vw, 44px);
            }
            .warning-block {
                margin-bottom: 25px;
            }
            #warning p {
                margin-bottom: 10px;
                line-height: 1.8;
            }
            #warning .critical {
                margin-top: 25px;
                margin-bottom: 10px;
            }
            #warning .subtle-warning {
                margin-top: 20px;
                margin-bottom: 8px;
            }
            #warning .disclaimer {
                margin-top: 15px;
                margin-bottom: 20px;
            }
            #warning button {
                margin-top: 25px;
                margin-bottom: 25px;
                min-height: 50px;
            }
        }
        
        @media (max-width: 400px) {
            #warning h1 {
                font-size: clamp(24px, 8vw, 40px);
            }
            #warning p {
                font-size: clamp(13px, 4.2vw, 17px);
            }
            #warning button {
                font-size: clamp(15px, 5vw, 20px);
                padding: clamp(12px, 3.5vw, 18px) clamp(22px, 7vw, 50px);
            }
        }
    </style>
</head>
<body>
    <div id="cursor"></div>
    
    <div id="warning">
        <div id="warning-content">
            <h1>ПРЕДУПРЕЖДЕНИЕ</h1>
            
            <div class="warning-block">
                <p class="ominous" style="--delay: 0.5s">Это не обычный текст.</p>
                <p style="--delay: 1s">Это опыт.</p>
                <p style="--delay: 1.5s">Опыт, который изменит ваше восприятие.</p>
                <p class="ominous" style="--delay: 2s">Вы не сможете забыть то, что увидите.</p>
            </div>
            
            <div class="warning-block">
                <p class="critical" style="--x: 2; margin-top: 45px;">⚠ КРИТИЧЕСКОЕ ПРЕДУПРЕЖДЕНИЕ ⚠</p>
                <p class="epilepsy-warning" style="--delay: 2.8s">ИНТЕНСИВНЫЕ СТРОБОСКОПИЧЕСКИЕ ЭФФЕКТЫ</p>
                <p class="epilepsy-warning" style="--delay: 3s">БЫСТРЫЕ ВИЗУАЛЬНЫЕ ИЗМЕНЕНИЯ</p>
                <p class="epilepsy-warning" style="--delay: 3.2s">НЕ РЕКОМЕНДУЕТСЯ ПРИ ЭПИЛЕПСИИ</p>
            </div>
            
            <div class="warning-block">
                <p class="subtle-warning" style="--delay: 3.7s">Рекомендуется использовать наушники</p>
                <p class="subtle-warning" style="--delay: 4s">Выключите свет для полного эффекта</p>
                <p class="subtle-warning" style="--delay: 4.3s">Убедитесь, что вас никто не потревожит</p>
            </div>
            
            <p class="critical" style="--x: -2; margin-top: 50px; margin-bottom: 25px;">Вы готовы?</p>
            
            <p class="disclaimer">Продолжая, вы принимаете на себя полную ответственность за происходящее. Создатель предупредил вас о природе этого опыта.</p>
            
            <button id="enter">ВОЙТИ</button>
        </div>
    </div>

    <div id="experience">
        <div class="blackout"></div>
        <div class="strobe"></div>
        <div class="chromatic"></div>
        <div class="watching-overlay"></div>
        <div class="breath-overlay"></div>
        <div class="vignette"></div>
        <div class="static"></div>
        <div class="blood-screen"></div>
        <div class="red-flicker"></div>
        <div class="grain"></div>
        <div class="heartbeat"></div>
        <div class="peripheral-horror left"></div>
        <div class="peripheral-horror right"></div>
        <div class="shadow left"></div>
        <div class="shadow right"></div>
        <div class="screen-tear"></div>
        <div class="time-distortion"></div>
        <div class="reality-glitch"></div>
        <div class="subliminal"></div>
        <div class="breath-fog"></div>
        <div class="screen-crack"></div>
        <div id="water-drops"></div>
        <div id="blood-drops"></div>
        <div id="wet-stains"></div>
        <div id="obsessive-words"></div>
        <div id="forgotten-words"></div>
        <div class="peripheral-shadow" id="shadow-left"></div>
        <div class="peripheral-shadow" id="shadow-right"></div>
        <div class="peripheral-shadow" id="shadow-top"></div>
        <div id="final-horror-container">
            <div class="smile-container"></div>
        </div>
        <div class="subliminal-flash">
            <div class="subliminal-image"></div>
        </div>
        <div id="content"></div>
        <button id="emergency-exit">ВЫХОД</button>
    </div>

    <script>
        // PERFECTED HYPNOTIC IMMERSION
        const story = [
            'Ты <span class="ghost-echo">стоишь</span> в дверях.|2000',
            'Перед тобой — <span class="void focus-word">лужа</span>.|2000|obsess:лужа|water',
            '<span class="death ashen">Тёмная</span>.|1500',
            '<span class="ashen">Расползается</span>.|2000|peripheral|wetstain',
            '|4500|blackout:4500|silence|sound:void_hum',
            'Ты всё ещё здесь?|2500|break|subliminal:ЗДЕСЬ',
            'Ты чувствуешь это?|2200|break|cursormove',
            'Твоя <span class="focus-word">рука</span>.|2000|break',
            'Она <span class="pulse-accent">не твоя</span>.|3000|break|reality',
            'Ты считаешь секунды.|2500',
            'Десять.|1000|sound:tick|heartbeat',
            'Девять.|1000|sound:tick|heartbeat',
            'Восемь.|1000|sound:tick|heartbeat',
            'Семь.|1000|sound:tick|heartbeat',
            'Шесть.|1000|sound:tick|heartbeat',
            'Пять.|1000|sound:tick|heartbeat',
            'Четыре.|1000|sound:tick|heartbeat',
            'Три.|1000|sound:tick|heartbeat',
            'Два.|1000|sound:tick|heartbeat',
            'Один.|3000|sound:tick|heartbeat',
            'Ты <span class="ember">входишь</span>.|2500|sound:step|trail|cursormove',
            'Он смотрит на <span class="focus-word">тебя</span>.|2000',
            'Не <span class="ashen">узнаёт</span>.|2500',
            'В его глазах — <span class="void pulse-accent">страх</span>.|3500|shadow|peripheral',
            'Ты для него <span class="death pulse-accent">чужой</span>.|4000|distorted',
            '|3500|blackout:3500|silence',
            'Посмотри на свои руки.|3000|break|subliminal:РУКИ',
            'Прямо сейчас.|2500|break|peripheralshadow',
            'Они трясутся?|3500|break|watching',
            'Он отступает к стене.|2500',
            'Прикрывает себя руками.|2500',
            'Руки как <span class="death">ветки</span>.|2000',
            'Сухие. <span class="death">Ломкие</span>.|3000',
            'Ты идёшь к нему.|2500|sound:step|peripheralshadow',
            'Каждый шаг.|1500|sound:step',
            'Ближе.|1500|sound:step|peripheral',
            'Ближе.|1800|sound:step|peripheral',
            'Он <span class="scream">кричит</span>.|3000|double|chromatic|sound:scream',
            'Не словами.|2000',
            '<span class="void">Звуком</span>.|2000',
            '<span class="void">Животным</span>.|3000|shake|screentear',
            '|5000|blackout:5000|silence',
            'Сколько времени прошло?|2500|break|timedistort',
            'Минута?|1200|break',
            'Час?|1200|break',
            'День?|2000|break',
            'Ты уже не помнишь, когда вошёл.|3000|break|subliminal:ЗАБЫЛ',
            'Ты рвёшь с него майку.|2000',
            'Она легко рвётся.|2000|sound:tear',
            'Как <span class="void">бумага</span>.|1500',
            'Снимаешь штаны.|1500',
            'Трусы.|1500',
            'Он <span class="death">голый</span> перед тобой.|3000|freeze',
            'Ты смотришь.|2500|watching',
            '<span class="death">Рёбра. Раз. Два. Три. Четыре. Пять</span>.|3000',
            'Все пять. Можно пересчитать пальцем.|2500',
            'Позвоночник — <span class="death">бугры</span> под кожей.|2000',
            'Ноги — <span class="death">спички</span>.|2000',
            'Живот — <span class="void">яма</span>.|2500',
            'Это был твой <span class="death">отец</span>.|4000|shadow|heartbeat',
            'Ты помнишь его другим?|3000|break|obsess:помнишь',
            '|3500|blackout:3500|silence',
            'Нет.|2500|break',
            'Ты не помнишь.|3000|break|subliminal:ЗАБВЕНИЕ',
            'Ты тащишь его к душу.|2000|sound:step|cursormove',
            'За локоть.|1500',
            'Он лёгкий.|1500',
            'Невесомый почти.|2000',
            'Ставишь под воду.|2000',
            'Включаешь.|2000',
            '<span class="cold">Холодная</span>.|2000|sound:water|obsess:вода|water',
            'Он вскрикивает.|2000',
            'Рот открыт. <span class="void">Беззубый</span>.|2500',
            'Чёрная дыра вместо рта.|2500|peripheral',
            'Ты ждёшь.|3000|sound:waterambient',
            'Вода течёт по его телу.|2000|obsess:вода|water',
            '<span class="cold">Холодная</span>.|2000',
            'Он дрожит.|2500|sound:breathing',
            'Весь.|1500',
            'Ты стоишь. Смотришь.|3000|watching',
            'Тридцать секунд.|2500',
            'Может, минута.|3000',
            'Время <span class="void">размазалось</span>.|3000|timedistort',
            '|6000|blackout:6000|silence',
            'Твоя спина болит?|3000|break|subliminal:БОЛИТ',
            'От того, как ты сидишь?|2500|break',
            'Ты сутулишься.|2000|break',
            'Как он.|3000|break|distorted',
            'Он дрожит всем телом.|2500|heartbeat',
            'Ты включаешь горячую.|2000',
            'Теплеет.|1500',
            'Он затихает.|3000',
            'Ты берёшь мочалку.|2000',
            'Намыливаешь.|1500',
            'Начинаешь <span class="machine-word">тереть</span>.|2000|sound:scrub|sound:metallic',
            'Спина.|1200',
            'Круговыми движениями.|1500',
            '<span class="machine-word">Сильно</span>.|1500',
            'Его кожа краснеет.|2000|redFlicker',
            'Ты трёшь <span class="machine-word">сильнее</span>.|2000|shake|sound:scrub',
            'Хочешь <span class="void">стереть</span>.|1500',
            'До <span class="death">костей</span>.|3000',
            '<span class="machine-word">Ты трёшь. Трёшь. Трёшь</span>.|2500|obsess:трёшь|sound:scrub',
            '<span class="machine-word">Монотонно</span>.|2000',
            '<span class="machine-word">Скрип. Скрип. Скрип</span>.|3000|obsess:скрип',
            'Как ногти по доске.|2500|reality',
            'Ты моешь его пах.|2000',
            '<span class="machine-word">Каждый день</span> моешь.|2000|obsess:каждый день',
            '<span class="death">Увядшую плоть</span>.|2500',
            'Потому что он обоссался. <span class="machine-word">Снова</span>.|3000|obsess:снова',
            'Задница.|2000',
            'Ты раздвигаешь.|1500',
            'Он дёргается.|1500',
            'Ты держишь крепче.|2000',
            '<span class="machine-word">Моешь</span>.|1500',
            '<span class="filth">Дерьмо. Размазанное. Вонючее</span>.|3000|obsess:грязь',
            'Запах.|2000',
            'Ты чувствуешь его сейчас?|3000|break|subliminal:ЗАПАХ|breathfog',
            'Нет.|2000|break',
            'Но он в твоей голове.|3000|break|peripheral',
            'Вода <span class="filth">коричневая</span> стекает в слив.|3000|water',
            'С твоего <span class="death">отца</span>.|2500|shadow',
            'Ты продолжаешь.|2000',
            '<span class="machine-word">Моешь. Моешь. Моешь</span>.|2500|obsess:моешь|sound:scrub',
            'Не можешь <span class="void">остановиться</span>.|3000|shake|cursormove',
            'Твои руки <span class="machine-word">трут. Трут. Трут</span>.|2500|heartbeat',
            'Автоматически.|2000',
            '<span class="void">Машина из мяса</span>.|3000|distorted',
            '|4000|blackout:4000|silence',
            'Это напоминает тебе что-то?|2500|break',
            'Твою жизнь.|2000|break|watching',
            'Каждый.|1000|break',
            'Гребаный.|1000|break',
            'День.|3000|break|reality|crack',
            'Его кожа <span class="pain">красная</span>.|2000|redFlicker',
            'Почти <span class="pain">кровь</span>.|3000|blood|obsess:кровь|blooddrop',
            '— <span class="pain">Больно</span>.|4000|double',
            'Шёпот. Еле слышный.|2500',
            'Ты слышал?|2500|break|subliminal:БОЛЬНО',
            '<span class="pain">Больно</span>.|3500',
            'Ты смотришь на руки.|2500',
            'Мочалка в <span class="pain">крови</span>.|2500|blood|obsess:кровь|blooddrop',
            'На спине — <span class="pain">кровь. Полосы</span>.|3000|blood|chromatic|blooddrop',
            'Ты <span class="pain">содрал кожу</span>.|2500|blood|blooddrop|sound:metallic',
            '|2500|strobe:1500',
            'Со своего <span class="death">отца</span>.|4500|shake|redFlicker|screentear|blooddrop',
            'Вода смывает <span class="pain">кровь</span>. Розовая.|3000|sound:water|water|blooddrop',
            'Как у новорождённого.|2500',
            'Ты одеваешь его.|2000',
            'Как сломанную <span class="void">куклу</span>.|2500',
            'Голова висит.|2000',
            'Руки не слушаются.|2000',
            'Ведёшь в комнату.|2000|sound:step|cursormove',
            'Сажаешь на диван.|3000',
            'Он смотрит в <span class="void">пустоту</span>.|3000|obsess:пустота',
            'Ты уходишь на кухню.|2000',
            '<span class="machine-word">Моешь руки. Долго</span>.|2500|sound:water|obsess:моешь|water',
            'Его <span class="filth">грязь</span> въелась.|2000|obsess:грязь',
            'В твою кожу. В твою <span class="pain">кровь</span>.|3000|shake',
            'Ты трёшь <span class="machine-word">сильнее</span>.|2000|heartbeat|sound:scrub',
            'Твоя кожа <span class="pain">слезает</span>.|3000|blood|blooddrop',
            'Розовая. Сырая.|2500|redFlicker',
            '|5000|blackout:5000|silence|sound:pressure',
            'Чем ты отличаешься от него?|3000|break|timedistort',
            'Ты.|1500|break',
            'Смотрящий в экран.|2500|break|watching',
            'Наблюдатель.|2000|break',
            'Соучастник.|3000|break|reality',
            'Твоя мышь.|2000|break|cursormove',
            'Движется сама.|3000|break|subliminal:НЕТ КОНТРОЛЯ',
            'Ты смотришь в окно.|2500',
            'Там люди живут.|2000',
            'Они не знают.|2000',
            'Какой <span class="void">ад</span> здесь.|3500|shadow|peripheral',
            '<span class="machine-word">Три года. Каждый день</span>.|3000|obsess:каждый день',
            'Тысяча девяносто пять дней.|3000|timedistort',
            '<span class="void">Лужа</span>. Вода. <span class="filth">Грязь</span>. <span class="pain">Кровь</span>.|3500|obsess:лужа|water|blooddrop',
            'Ты <span class="void pulse-accent">сходишь с ума</span>.|2500|shake|double|redFlicker',
            '<span class="machine-word">Медленно</span>.|2000',
            'Но верно.|2000',
            'Он теряет <span class="void">память</span>.|2000',
            'Ты теряешь <span class="void ghost-echo">себя</span>.|4000|freeze|obsess:теряю',
            'Иногда ночью.|2500|shadow',
            'Ты стоишь над ним.|2000|watching',
            'Думаешь. <span class="death">Подушка</span>.|2500',
            'Просто прижать.|2000',
            'И всё <span class="death">кончится</span>.|3500|freeze',
            'Ты держишь <span class="death">подушку</span>.|2500|heartbeat',
            'Подносишь к его лицу.|2500|peripheral|breathfog',
            'Руки <span class="void pulse-accent">трясутся</span>.|2500|shake',
            'Твои <span class="focus-word">руки</span>.|2000|break|subliminal:ТВОИ РУКИ',
            'Прямо <span class="pulse-accent">сейчас</span>.|2000|break|cursormove',
            '<span class="scream">Сейчас</span>.|2500',
            '<span class="scream">Сейчас</span>.|2500|redFlicker',
            '<span class="scream">СЕЙЧАС</span>.|4000|shake|redFlicker|screentear',
            '|3000|strobe:1200',
            'Но не делаешь.|2500|freeze',
            'Почему?|2500|break',
            'Страх?|1500|break',
            'Любовь?|1500|break',
            'Или ты уже мёртв внутри?|4500|break|reality',
            'Отходишь.|4000|timedistort',
            'Утром <span class="machine-word">снова</span> — <span class="void">лужа</span>.|2500|sound:machine|obsess:снова|water|wetstain',
            'Он не узнаёт.|2000',
            'Ты входишь.|2500|sound:step|cursormove',
            'И всё <span class="machine-word">сначала</span>.|3500|trail|obsess:сначала',
            'Внутри что-то <span class="pain">ломается</span>.|3000|shake|blood|chromatic|crack',
            'Хруст.|2000|reality|sound:crack',
            'Ты теряешь <span class="void">человечность</span>.|4000|distorted',
            'Ты — <span class="machine-word focus-word">машина</span>.|2500|sound:machine',
            'Которая <span class="machine-word">моет. Одевает. Кормит</span>.|3500|obsess:моешь',
            'Ты смотришь в зеркало.|2500|double|watching',
            'Не узнаёшь <span class="void">себя</span>.|2000|sound:distant_voices',
            'Глаза <span class="void ghost-echo">пустые</span>. Как у него.|3500|freeze|obsess:пустота',
            'Кто смотрит оттуда?|3000|break|peripheral',
            'Это ты?|2500|break|subliminal:КТО ТЫ',
            '|7000|blackout:7000|silence',
            'Когда ты в последний раз.|2500|break',
            'Чувствовал что-то?|3000|break|watching',
            'Вспомни.|2500|break',
            'Вспомни сейчас.|3000|break|cursormove',
            'Вы похожи.|2500|timedistort',
            '<span class="death">Отец и сын</span>.|2000',
            'Оба <span class="void">разрушаетесь</span>.|4000|shadow|heartbeat',
            'Параллельно.|2500',
            'Ты берёшь его руку.|2500',
            '<span class="cold">Холодная</span>. <span class="death">Мёртвая</span> почти.|3500',
            'Стиральная <span class="machine-word">машина</span> гудит.|2500|sound:machine',
            'Вода шумит.|2000|sound:water|water',
            '<span class="machine-word">Каждый день</span>.|3500|trail|obsess:каждый день',
            'Ты держишь <span class="death pulse-accent">мёртвую</span> руку.|2500',
            '<span class="death">Живого трупа</span>.|2500|distorted',
            'Который был твоим <span class="death pulse-accent">отцом</span>.|4000',
            'Который учил тебя не плакать.|3500',
            'Ты не плачешь.|2500',
            'Не можешь.|2500',
            'Внутри — <span class="void ghost-echo">пустота</span>.|3000|freeze|obsess:пустота',
            'Как в его <span class="void">глазах</span>.|4000|shake',
            'Вы ждёте <span class="death pulse-accent">смерти</span>.|3500|blood|redFlicker|peripheral|blooddrop',
            'Чьей. Не важно.|2500',
            'Лишь бы <span class="death pulse-accent">кончилось</span>.|4000|double',
            'Но не кончается.|3000|obsess:не кончается',
            '<span class="focus-word pulse-accent">Никогда</span>.|2500|timedistort',
            'Он дышит. Ты дышишь.|3500|sound:breathing|heartbeat',
            '<span class="machine-word">Завтра то же</span>.|2500|obsess:завтра',
            '<span class="void">Лужа</span>. Вода. <span class="pain">Кровь</span>.|3000|blood|water|blooddrop',
            '<span class="machine-word">И дальше. И дальше</span>.|3000|shake|obsess:и дальше',
            'В <span class="void">аду</span>.|2500',
            'Который называется.|2500|freeze|watching',
            '<span class="scream focus-word">Любовь. Долг. Семья</span>.|5000|shake|blood|redFlicker|chromatic|crack',
            'Вода течёт.|2500|sound:water|obsess:вода|water',
            '<span class="machine-word">Машина</span> гудит.|2500|sound:machine',
            'И ты ждёшь <span class="death">конца</span>.|3500',
            'Который не приходит.|4000|shadow|obsess:не приходит',
            '<span class="focus-word pulse-accent">Никогда</span>.|3000|reality',
            '|8000|blackout:8000|silence',
            'Ты понял?|3000|break|subliminal:ПОНЯЛ',
            'Это не его история.|3000|break|watching',
            'Это твоя.|2500|break|cursormove',
            'Просто.|2000|break',
            'Ты.|2000|break',
            'Ещё.|2000|break',
            'Не.|2000|break',
            'Знаешь.|3000|break|timedistort',
            'Об этом.|4000|break|reality|peripheral',
            '<span class="void pulse-accent">Никогда</span>.|7000|shake|blood|redFlicker|freeze|chromatic|obsess:никогда|blooddrop|crack',
            '|2000|silence',
            '|12000|finalhorror',
            '|15000|blackout:15000|silence'
        ];

        let audioContext, ambientLayers = [], progressionLevel = 0;
        let obsessiveWords = [], forgottenWords = [];
        let obsessionPhase = 0;
        let obsessionFieldActive = false;
        let obsessionFrame = null;
        let lastObsessionTick = null;
        let ambientWordTimeout = null;
        let currentAmbientDelay = 2200;
        let lastBloodPhraseTime = 0;
        let faceAnchors = [];
        let faceAssignmentCursor = 0;
        let facePhaseActivated = false;
        let microFlashInterval = null;
        let finalSequenceActive = false;
        let lastFocusPan = 0;
        let lastFocusTilt = 0;
        let mouseX = 0, mouseY = 0, realMouseX = 0, realMouseY = 0;
        let forcedCursorActive = false, isWatching = false;
        let cursorTrails = [];
        let subliminalMessages = ['ЗАБУДЬ', 'БЕЗЫСХОДНОСТЬ', 'ПОВТОР', 'РАСПАД', 'ПУСТОТА', 'БОЛЬ', 'ЦИКЛ', 'НЕТ ВЫХОДА', 'ПОВИНУЙСЯ', 'СТРАХ', 'ТОНЕШЬ', 'ТЕРЯЕШЬСЯ'];
        const microFlashSymbols = ['🙂', '💀', 'СЛУШАЙ', 'СЕКС', 'СМЕРТЬ', 'ТВОЯ ОЧЕРЕДЬ', 'СТАРИК', '👁️'];
        let waterDrops = [], bloodDrops = [], wetStains = [];
        let lastActivityTime = Date.now();
        let isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        
        const FORGOTTEN = [
            'отец', 'помню', 'забыл', 'кто я', 'где я', 'раньше', 'было', 'имя', 'лицо', 'голос',
            'давно', 'тогда', 'помнишь', 'стёрлось', 'исчезло', 'потерял', 'не помню', 'узнаю',
            'был', 'когда', 'там', 'здесь', 'дома', 'мама', 'детство', 'счастье', 'смех', 'свет',
            'любовь', 'надежда', 'будущее', 'прошлое', 'человек', 'живой', 'помощь', 'конец', 'начало',
            'выход', 'спасение', 'жизнь', 'смерть', 'боль', 'страх', 'время', 'дни', 'годы'
        ];

        const BACKGROUND_OBSESSION_WORDS = [
            'вода', 'лужа', 'стон', 'шёпот', 'кожа', 'старик', 'отец', 'взгляд', 'скрип', 'ты',
            'он', 'дыши', 'помни', 'забудь', 'никогда', 'циклы', 'пустота', 'страх', 'тени',
            'сон', 'глаза', 'видит', 'смех', 'соль', 'кровь', 'мокро', 'туман', 'холод', 'долг',
            'семья', 'дни', 'ночь', 'тишина', 'давление', 'пульс', 'крик', 'мыть', 'грязь', 'запах',
            'здесь', 'рядом', 'не уходи', 'останься', 'он ждёт', 'боль', 'время', 'капли', 'безысходность'
        ];

        const BLOOD_PHRASES = [
            ['ОН', 'СМОТРИТ', 'НА', 'ТЕБЯ'],
            ['НИКТО', 'НЕ', 'ПРИДЁТ'],
            ['ТВОИ', 'РУКИ', 'В', 'КРОВИ'],
            ['ОН', 'УЖЕ', 'МЁРТВ'],
            ['ДЫШИ', 'С', 'НИМ', 'ВМЕСТЕ'],
            ['НЕ', 'СУЩЕСТВУЕТ', 'ВЫХОДА'],
            ['ПАМЯТЬ', 'ГНИЁТ', 'ЗДЕСЬ'],
            ['СТАРИК', 'УХОДИТ', 'ВНУТРЬ'],
            ['НИКТО', 'НЕ', 'УСЛЫШИТ']
        ];

        function startObsessionField() {
            if (obsessionFieldActive) return;
            obsessionFieldActive = true;
            const container = document.getElementById('obsessive-words');
            if (container) {
                container.innerHTML = '';
                container.setAttribute('data-phase', String(obsessionPhase));
            }
            lastObsessionTick = null;
            if (obsessionFrame) {
                cancelAnimationFrame(obsessionFrame);
            }
            obsessionFrame = requestAnimationFrame(animateObsessionField);
            scheduleAmbientWord(true);
        }

        function scheduleAmbientWord(immediate = false) {
            clearTimeout(ambientWordTimeout);
            if (!obsessionFieldActive) return;
            const delay = immediate ? 420 : currentAmbientDelay * (0.6 + Math.random() * 0.8);
            ambientWordTimeout = setTimeout(() => {
                spawnAmbientObsessionWord();
                scheduleAmbientWord(false);
            }, Math.max(120, delay));
        }

        function spawnAmbientObsessionWord(forceHighlight = null) {
            if (!obsessionFieldActive) return;
            const word = BACKGROUND_OBSESSION_WORDS[Math.floor(Math.random() * BACKGROUND_OBSESSION_WORDS.length)];
            let highlight = forceHighlight;
            if (!highlight) {
                if (obsessionPhase >= 2 && Math.random() < 0.22) {
                    highlight = 'blood';
                } else if (Math.random() < 0.18) {
                    highlight = 'whisper';
                }
            }
            registerObsessionWord(word, { highlight });
        }

        function registerObsessionWord(word, options = {}) {
            if (!word) return null;
            const entry = createObsessionWord(word, options);
            if (!entry) return null;
            obsessiveWords.push(entry);
            if (obsessionPhase >= 1 && !options.skipMirror) {
                const mirroredPosition = options.forcePosition
                    ? { x: window.innerWidth - options.forcePosition.x, y: options.forcePosition.y + (Math.random() - 0.5) * 24 }
                    : null;
                const signature = typeof entry.signature === 'number' ? -entry.signature : -(Math.random() - 0.5);
                registerObsessionWord(word, {
                    ...options,
                    forcePosition: mirroredPosition,
                    skipMirror: true,
                    mirrored: true,
                    signature
                });
            }
            trimObsessionField();
            return entry;
        }

        function createObsessionWord(word, options = {}) {
            const container = document.getElementById('obsessive-words');
            if (!container) return null;
            const el = document.createElement('div');
            el.className = 'obsessive-word';
            el.textContent = word;
            if (options.highlight === 'blood') {
                el.classList.add('blood-sigil');
            } else if (options.highlight === 'whisper') {
                el.classList.add('whisper');
            }

            const vw = window.innerWidth;
            const vh = window.innerHeight;
            const entry = {
                el,
                word,
                highlight: options.highlight || null,
                x: options.forcePosition ? options.forcePosition.x : vw * (0.3 + Math.random() * 0.4),
                y: options.forcePosition ? options.forcePosition.y : vh * (0.25 + Math.random() * 0.5),
                targetX: null,
                targetY: null,
                orbitCenterX: vw / 2 + (Math.random() - 0.5) * vw * 0.12,
                orbitCenterY: vh / 2 + (Math.random() - 0.5) * vh * 0.12,
                orbitRadius: Math.min(vw, vh) * (0.18 + Math.random() * 0.35),
                orbitAngle: Math.random() * Math.PI * 2,
                orbitSpeed: 0.12 + Math.random() * 0.1,
                stage: obsessionPhase,
                follow: 1.6 + Math.random() * 1.2,
                seed: Math.random() * Math.PI * 2,
                anchor: options.anchor || null,
                anchorIndex: options.anchorIndex ?? null,
                signature: options.signature !== undefined ? options.signature : (Math.random() - 0.5),
                mirrored: options.mirrored || false,
                life: 0
            };

            entry.el.style.left = entry.x + 'px';
            entry.el.style.top = entry.y + 'px';
            container.appendChild(entry.el);
            requestAnimationFrame(() => entry.el.classList.add('active'));
            configureWordForCurrentPhase(entry, true);
            return entry;
        }

        function configureWordForCurrentPhase(entry, fresh = false) {
            if (!entry || !entry.el) return;
            entry.el.classList.remove('swarm', 'rorschach', 'pulse', 'face-phase');
            if (entry.highlight !== 'blood') {
                entry.el.classList.remove('blood-sigil');
            }
            if (entry.highlight !== 'whisper') {
                entry.el.classList.remove('whisper');
            }
            if (entry.highlight === 'blood') {
                entry.el.classList.add('blood-sigil');
            } else if (entry.highlight === 'whisper') {
                entry.el.classList.add('whisper');
            }
            entry.stage = obsessionPhase;
            if (entry.stage === 0) {
                entry.el.classList.add('swarm');
                entry.follow = 1.6 + Math.random() * 0.9;
            } else if (entry.stage === 1) {
                entry.el.classList.add('rorschach');
                entry.follow = 2.1 + Math.random() * 1.2;
                assignRorschachAnchor(entry, fresh);
            } else if (entry.stage === 2) {
                entry.el.classList.add('rorschach', 'pulse');
                entry.follow = 2.6 + Math.random() * 1.4;
                assignRorschachAnchor(entry, fresh);
                if (!entry.highlight && Math.random() < 0.2) {
                    entry.highlight = 'whisper';
                    entry.el.classList.add('whisper');
                }
            } else {
                entry.el.classList.add('face-phase');
                entry.follow = 3.4 + Math.random() * 1.2;
                assignFaceAnchor(entry, fresh);
            }
        }

        function assignRorschachAnchor(entry, fresh = false) {
            if (obsessionPhase < 1) return;
            if (!fresh && entry.anchor && entry.stage === obsessionPhase) return;
            const centerX = window.innerWidth / 2;
            const centerY = window.innerHeight / 2;
            let signature = entry.signature;
            if (typeof signature !== 'number') {
                signature = Math.random() - 0.5;
                entry.signature = signature;
            }
            const absSig = Math.abs(signature);
            let targetX, targetY;
            if (absSig > 0.42) {
                const radiusX = window.innerWidth * (0.22 + absSig * 0.1);
                targetX = centerX + Math.sign(signature) * radiusX;
                targetY = centerY + window.innerHeight * 0.12 + Math.sin(entry.seed * 4) * window.innerHeight * 0.05;
            } else if (absSig > 0.18) {
                targetX = centerX + Math.sign(signature) * window.innerWidth * (0.12 + absSig * 0.06);
                targetY = centerY - window.innerHeight * (0.22 - absSig * 0.08) + Math.sin(entry.seed * 5) * 35;
            } else {
                targetX = centerX + signature * window.innerWidth * 0.08;
                targetY = centerY + signature * window.innerHeight * 0.12 + Math.sin(entry.seed * 3) * 45;
            }
            if (obsessionPhase === 2) {
                targetY += Math.sin(entry.seed * 6) * 24;
            }
            entry.anchor = { x: targetX, y: targetY };
        }

        function updateObsessionDynamics(level) {
            updateObsessionPhase(level);
            trimObsessionField();
            if (obsessionPhase >= 2 && Math.random() < 0.14) {
                maybeSpawnBloodPhrase();
            }
            if (obsessionPhase === 3 && !facePhaseActivated && level > 0.8) {
                ensureFaceDensity(true);
            }
        }

        function updateObsessionPhase(level) {
            let phase = 0;
            if (level > 0.28) phase = 1;
            if (level > 0.52) phase = 2;
            if (level > 0.78) phase = 3;
            if (phase === obsessionPhase) return;
            obsessionPhase = phase;
            const container = document.getElementById('obsessive-words');
            if (container) {
                container.setAttribute('data-phase', String(obsessionPhase));
            }
            updateAmbientDelay();
            obsessiveWords.forEach(entry => configureWordForCurrentPhase(entry, true));
            if (obsessionPhase >= 2) {
                maybeSpawnBloodPhrase(true);
            }
            if (obsessionPhase < 3) {
                facePhaseActivated = false;
            }
        }

        function updateAmbientDelay() {
            if (obsessionPhase === 0) {
                currentAmbientDelay = 2200;
            } else if (obsessionPhase === 1) {
                currentAmbientDelay = 1400;
            } else if (obsessionPhase === 2) {
                currentAmbientDelay = 900;
            } else {
                currentAmbientDelay = 600;
            }
            scheduleAmbientWord(false);
        }

        function trimObsessionField(limit = getMaxObsessionWords()) {
            while (obsessiveWords.length > limit) {
                const old = obsessiveWords.shift();
                if (old && old.el && old.el.parentNode) {
                    old.el.remove();
                }
            }
        }

        function getMaxObsessionWords() {
            if (obsessionPhase >= 3) return 260;
            if (obsessionPhase === 2) return 190;
            if (obsessionPhase === 1) return 130;
            return 80;
        }

        function animateObsessionField(timestamp) {
            if (!obsessionFieldActive) return;
            if (lastObsessionTick === null) {
                lastObsessionTick = timestamp;
            }
            const dt = Math.min((timestamp - lastObsessionTick) / 1000, 0.05);
            lastObsessionTick = timestamp;
            for (let i = obsessiveWords.length - 1; i >= 0; i--) {
                const entry = obsessiveWords[i];
                if (!entry || !entry.el || !entry.el.isConnected) {
                    obsessiveWords.splice(i, 1);
                    continue;
                }
                updateObsessionWord(entry, dt);
            }
            obsessionFrame = requestAnimationFrame(animateObsessionField);
        }

        function updateObsessionWord(entry, dt) {
            if (!entry || !entry.el) return;
            entry.life += dt;
            if (entry.stage === 0) {
                entry.orbitAngle += entry.orbitSpeed * dt * (1.2 + progressionLevel * 2.3);
                const breathing = 1 + Math.sin(entry.life * 0.6 + entry.seed) * 0.08;
                entry.targetX = entry.orbitCenterX + Math.cos(entry.orbitAngle) * entry.orbitRadius * breathing;
                entry.targetY = entry.orbitCenterY + Math.sin(entry.orbitAngle * 0.92) * entry.orbitRadius * breathing * 0.9;
            } else if (entry.stage === 1 || entry.stage === 2) {
                if (!entry.anchor) {
                    assignRorschachAnchor(entry, true);
                }
                const jitterX = entry.stage === 1 ? 28 : 42;
                const jitterY = entry.stage === 1 ? 36 : 58;
                entry.targetX = entry.anchor.x + Math.sin(entry.life * 0.8 + entry.seed) * jitterX;
                entry.targetY = entry.anchor.y + Math.cos(entry.life * 0.6 + entry.seed * 1.3) * jitterY;
                if (entry.stage === 2) {
                    entry.targetY += Math.sin(entry.life * 1.8 + progressionLevel * 6) * 18;
                }
            } else {
                if (!entry.anchor) {
                    assignFaceAnchor(entry, false);
                }
                const jitterX = 14 + Math.sin(entry.life * 1.6 + entry.seed) * 9;
                const jitterY = 18 + Math.cos(entry.life * 1.2 + entry.seed * 0.7) * 11;
                entry.targetX = entry.anchor.x + Math.sin(entry.life * 0.9 + entry.seed) * jitterX;
                entry.targetY = entry.anchor.y + Math.cos(entry.life * 1.1 + entry.seed * 0.7) * jitterY;
            }
            if (entry.targetX === null || entry.targetY === null) return;
            const follow = Math.min(1, dt * entry.follow);
            entry.x += (entry.targetX - entry.x) * follow;
            entry.y += (entry.targetY - entry.y) * follow;
            entry.el.style.left = entry.x + 'px';
            entry.el.style.top = entry.y + 'px';
            const rotation = Math.sin(entry.life * 0.9 + entry.seed) * (entry.stage >= 2 ? 12 : 6);
            const scale = 1 + Math.sin(entry.life * 0.7 + entry.seed) * 0.06;
            entry.el.style.transform = `translate(-50%, -50%) rotate(${rotation}deg) scale(${scale})`;
        }

        function maybeSpawnBloodPhrase(force = false) {
            if (obsessionPhase < 2) return;
            const now = Date.now();
            const cooldown = Math.max(2200, 6400 - progressionLevel * 2800);
            if (!force && now - lastBloodPhraseTime < cooldown) return;
            lastBloodPhraseTime = now;
            spawnBloodPhrase();
        }

        function spawnBloodPhrase() {
            const phrase = BLOOD_PHRASES[Math.floor(Math.random() * BLOOD_PHRASES.length)];
            const baseX = window.innerWidth / 2 + (Math.random() - 0.5) * window.innerWidth * 0.18;
            const baseY = window.innerHeight * (0.3 + Math.random() * 0.4);
            phrase.forEach((word, index) => {
                registerObsessionWord(word, {
                    highlight: 'blood',
                    forcePosition: {
                        x: baseX + (index - (phrase.length - 1) / 2) * 42,
                        y: baseY + Math.sin(index * 0.8) * 26
                    }
                });
            });
        }

        function ensureFaceDensity(refresh = false) {
            if (!faceAnchors.length || refresh) {
                faceAnchors = generateOldManFaceAnchors();
                faceAssignmentCursor = 0;
            }
            const required = Math.max(faceAnchors.length + 30, getMaxObsessionWords() - 10);
            while (obsessiveWords.length < required) {
                spawnAmbientObsessionWord('whisper');
            }
            obsessiveWords.forEach(entry => {
                if (entry.stage === 3) {
                    assignFaceAnchor(entry, true);
                }
            });
            facePhaseActivated = true;
        }

        function generateOldManFaceAnchors() {
            const anchors = [];
            const width = Math.min(window.innerWidth * 0.7, 700);
            const height = Math.min(window.innerHeight * 0.85, 820);
            const centerX = window.innerWidth / 2;
            const centerY = window.innerHeight * 0.52;

            for (let angle = 0; angle < Math.PI * 2; angle += 0.1) {
                const rx = width * 0.46;
                const ry = height * 0.52;
                anchors.push({ x: centerX + Math.cos(angle) * rx, y: centerY + Math.sin(angle) * ry });
            }

            for (let angle = 0; angle < Math.PI * 2; angle += 0.22) {
                const rx = width * 0.11;
                const ry = height * 0.08;
                anchors.push({ x: centerX - width * 0.18 + Math.cos(angle) * rx, y: centerY - height * 0.18 + Math.sin(angle) * ry });
                anchors.push({ x: centerX + width * 0.18 + Math.cos(angle) * rx, y: centerY - height * 0.18 + Math.sin(angle) * ry });
            }

            for (let angle = 0; angle < Math.PI * 2; angle += 0.4) {
                const rx = width * 0.05;
                const ry = height * 0.04;
                anchors.push({ x: centerX - width * 0.18 + Math.cos(angle) * rx, y: centerY - height * 0.18 + Math.sin(angle) * ry });
                anchors.push({ x: centerX + width * 0.18 + Math.cos(angle) * rx, y: centerY - height * 0.18 + Math.sin(angle) * ry });
            }

            for (let i = 0; i <= 40; i++) {
                const t = i / 40;
                const offset = (t - 0.5);
                anchors.push({ x: centerX - width * 0.22 + t * width * 0.18, y: centerY - height * 0.26 - Math.pow(offset * 1.6, 2) * height * 0.12 });
                anchors.push({ x: centerX + width * 0.04 + t * width * 0.18, y: centerY - height * 0.26 - Math.pow(offset * 1.6, 2) * height * 0.12 });
            }

            for (let i = 0; i <= 32; i++) {
                const t = i / 32;
                anchors.push({ x: centerX + (Math.sin(t * Math.PI) * width * 0.06), y: centerY - height * 0.14 + t * height * 0.22 });
            }

            for (let t = 0; t <= 1; t += 0.035) {
                const offset = t - 0.5;
                const mouthY = centerY + height * 0.24 + Math.pow(offset * 1.4, 2) * height * 0.08;
                anchors.push({ x: centerX + offset * width * 0.38, y: mouthY });
            }

            for (let i = 0; i < 80; i++) {
                const side = i % 2 === 0 ? -1 : 1;
                const t = (i % 40) / 40;
                anchors.push({
                    x: centerX + side * (width * 0.2 + Math.pow(t, 1.5) * width * 0.18),
                    y: centerY + height * 0.05 + Math.sin(t * Math.PI) * height * 0.18
                });
            }

            return anchors;
        }

        function assignFaceAnchor(entry, refresh = false) {
            if (obsessionPhase < 3) return;
            if (!faceAnchors.length || refresh) {
                faceAnchors = generateOldManFaceAnchors();
                faceAssignmentCursor = 0;
            }
            if (!faceAnchors.length) return;
            if (refresh || entry.anchorIndex === null || entry.anchorIndex === undefined || entry.anchorIndex >= faceAnchors.length) {
                entry.anchorIndex = faceAssignmentCursor++ % faceAnchors.length;
            }
            const base = faceAnchors[entry.anchorIndex % faceAnchors.length];
            entry.anchor = {
                x: base.x + (Math.random() - 0.5) * 14,
                y: base.y + (Math.random() - 0.5) * 20
            };
            entry.el.classList.add('face-phase');
        }

        window.addEventListener('resize', () => {
            if (!obsessionFieldActive) return;
            if (obsessionPhase >= 3) {
                faceAnchors = generateOldManFaceAnchors();
                faceAssignmentCursor = 0;
                obsessiveWords.forEach(entry => {
                    if (entry.stage >= 3) {
                        assignFaceAnchor(entry, true);
                    } else if (entry.stage >= 1) {
                        assignRorschachAnchor(entry, true);
                    }
                });
            } else if (obsessionPhase >= 1) {
                obsessiveWords.forEach(entry => assignRorschachAnchor(entry, true));
            }
        });

        // REAL mouse tracking
        document.addEventListener('mousemove', (e) => {
            realMouseX = e.clientX;
            realMouseY = e.clientY;
            lastActivityTime = Date.now();
            
            if (!forcedCursorActive) {
                mouseX = realMouseX;
                mouseY = realMouseY;
                const cursor = document.getElementById('cursor');
                if (cursor) {
                    cursor.style.left = mouseX + 'px';
                    cursor.style.top = mouseY + 'px';
                }
            }
            
            if (Math.random() < 0.25 && progressionLevel > 0.3) {
                createCursorTrail();
            }
        });

        document.addEventListener('touchstart', () => {
            lastActivityTime = Date.now();
        });

        document.addEventListener('touchmove', () => {
            lastActivityTime = Date.now();
        });

        function bindExperienceControls() {
            const exitButton = document.getElementById('emergency-exit');
            const enterButton = document.getElementById('enter');
            const warningScreen = document.getElementById('warning');
            const experienceScreen = document.getElementById('experience');

            if (!exitButton || !enterButton || !warningScreen || !experienceScreen) {
                return false;
            }

            if (!exitButton.dataset.bound) {
                exitButton.dataset.bound = 'true';
                exitButton.addEventListener('click', () => {
                    if (confirm('Прервать опыт?')) {
                        location.reload();
                    }
                });
            }

            if (!enterButton.dataset.bound) {
                enterButton.dataset.bound = 'true';
                enterButton.addEventListener('click', async () => {
                    // IMMEDIATE START - NO DELAY
                    warningScreen.style.display = 'none';
                    experienceScreen.style.display = 'block';

                    // Fullscreen attempt (silent fail on mobile)
                    try {
                        const elem = document.documentElement;
                        if (elem.requestFullscreen) {
                            await elem.requestFullscreen();
                        } else if (elem.webkitRequestFullscreen) {
                            elem.webkitRequestFullscreen();
                        } else if (elem.msRequestFullscreen) {
                            elem.msRequestFullscreen();
                        }
                    } catch (err) {}

                    // Audio initialization
                    try {
                        audioContext = new (window.AudioContext || window.webkitAudioContext)();
                        if (audioContext.state === 'suspended') {
                            await audioContext.resume();
                        }
                        const buffer = audioContext.createBuffer(1, 1, 22050);
                        const source = audioContext.createBufferSource();
                        source.buffer = buffer;
                        source.connect(audioContext.destination);
                        source.start(0);
                        initAtmosphere();
                    } catch (err) {}

                    startObsessionField();
                    setTimeout(() => spawnAmbientObsessionWord(), 300);

                    // START IMMEDIATELY
                    setTimeout(startExperience, 1500);
                    setInterval(triggerRandomSubliminal, 12000);
                    microFlashInterval = setInterval(triggerMicroFlash, 7000);
                });
            }

            return true;
        }

        if (!bindExperienceControls()) {
            document.addEventListener('DOMContentLoaded', bindExperienceControls, { once: true });
        }

        function createCursorTrail() {
            const trail = document.createElement('div');
            trail.className = 'cursor-trail';
            trail.style.left = mouseX + 'px';
            trail.style.top = mouseY + 'px';
            document.body.appendChild(trail);
            setTimeout(() => trail.remove(), 800);
        }

        function createWaterDrop() {
            const drop = document.createElement('div');
            drop.className = 'water-drop';
            drop.style.left = Math.random() * 100 + '%';
            drop.style.height = (40 + Math.random() * 60) + 'px';
            document.getElementById('water-drops').appendChild(drop);
            drop.classList.add('active');
            setTimeout(() => drop.remove(), 3000);
        }

        function createBloodDrop() {
            const drop = document.createElement('div');
            drop.className = 'blood-drop';
            drop.style.left = Math.random() * 100 + '%';
            drop.style.height = (50 + Math.random() * 90) + 'px';
            document.getElementById('blood-drops').appendChild(drop);
            drop.classList.add('active');
            setTimeout(() => drop.remove(), 4000);
            if (navigator.vibrate && Math.random() < 0.3) {
                navigator.vibrate(120);
            }
        }

        function createWetStain() {
            const stain = document.createElement('div');
            stain.className = 'wet-stain';
            const size = 120 + Math.random() * 250;
            stain.style.width = size + 'px';
            stain.style.height = size + 'px';
            stain.style.left = Math.random() * 100 + '%';
            stain.style.top = Math.random() * 100 + '%';
            document.getElementById('wet-stains').appendChild(stain);
            stain.classList.add('active');
        }

        function triggerBreathFog() {
            const fog = document.querySelector('.breath-fog');
            fog.classList.add('active');
            setTimeout(() => fog.classList.remove('active'), 5000);
        }

        function triggerScreenCrack() {
            const crack = document.querySelector('.screen-crack');
            crack.classList.add('active');
            if (navigator.vibrate) {
                navigator.vibrate([350, 120, 350]);
            }
        }

        // ПЕРИФЕРИЙНЫЕ ТЕНИ - замена курсору
        function triggerPeripheralShadows() {
            if (isMobile) return;
            const shadows = ['shadow-left', 'shadow-right', 'shadow-top'];
            const shadowId = shadows[Math.floor(Math.random() * shadows.length)];
            const shadow = document.getElementById(shadowId);
            
            // Случайная позиция в периферии
            let x, y;
            if (shadowId === 'shadow-left') {
                x = -50 + Math.random() * 150;
                y = Math.random() * (window.innerHeight - 200);
            } else if (shadowId === 'shadow-right') {
                x = window.innerWidth - 250 + Math.random() * 150;
                y = Math.random() * (window.innerHeight - 200);
            } else {
                x = Math.random() * (window.innerWidth - 250);
                y = -50 + Math.random() * 150;
            }
            
            shadow.style.left = x + 'px';
            shadow.style.top = y + 'px';
            shadow.classList.add('active');
            
            setTimeout(() => {
                shadow.classList.remove('active');
            }, 12000);
            
            if (navigator.vibrate && Math.random() < 0.3) {
                navigator.vibrate([50, 100, 50]);
            }
        }

        // ПАРЕЙДОЛИЯ - создание образов из слов
        function createPareidoliaPattern(type = 'eyes') {
            const container = document.getElementById('obsessive-words');
            const words = ['СМОТРИТ', 'ВИДИШЬ', 'ГЛАЗА', 'ПУСТОТА', 'ТЬМА', 'ЗДЕСЬ', 'ОН', 'ТЫ'];
            
            if (type === 'eyes') {
                // Создаем два "глаза" из слов
                const leftEyeX = window.innerWidth * 0.35;
                const rightEyeX = window.innerWidth * 0.65;
                const eyeY = window.innerHeight * 0.4;
                
                for (let i = 0; i < 30; i++) {
                    const word = words[Math.floor(Math.random() * words.length)];
                    const wordEl = document.createElement('div');
                    wordEl.className = 'obsessive-word pareidolia';
                    wordEl.textContent = word;
                    
                    // Распределяем слова вокруг двух центров (глаз)
                    const isLeftEye = Math.random() < 0.5;
                    const centerX = isLeftEye ? leftEyeX : rightEyeX;
                    const angle = Math.random() * Math.PI * 2;
                    const radius = Math.random() * 80 + 20;
                    
                    wordEl.style.left = (centerX + Math.cos(angle) * radius) + 'px';
                    wordEl.style.top = (eyeY + Math.sin(angle) * radius) + 'px';
                    wordEl.style.fontSize = (10 + Math.random() * 8) + 'px';
                    
                    container.appendChild(wordEl);
                    
                    setTimeout(() => {
                        wordEl.remove();
                    }, 12000);
                }
            } else if (type === 'figure') {
                // Создаем сгорбленный силуэт
                const centerX = window.innerWidth * 0.5;
                const topY = window.innerHeight * 0.3;
                
                // Голова
                for (let i = 0; i < 15; i++) {
                    const wordEl = document.createElement('div');
                    wordEl.className = 'obsessive-word pareidolia';
                    wordEl.textContent = words[Math.floor(Math.random() * words.length)];
                    const angle = Math.random() * Math.PI * 2;
                    const radius = Math.random() * 40 + 10;
                    wordEl.style.left = (centerX + Math.cos(angle) * radius) + 'px';
                    wordEl.style.top = (topY + Math.sin(angle) * radius) + 'px';
                    wordEl.style.fontSize = (8 + Math.random() * 6) + 'px';
                    container.appendChild(wordEl);
                    setTimeout(() => wordEl.remove(), 12000);
                }
                
                // Сгорбленная спина
                for (let i = 0; i < 20; i++) {
                    const wordEl = document.createElement('div');
                    wordEl.className = 'obsessive-word pareidolia';
                    wordEl.textContent = words[Math.floor(Math.random() * words.length)];
                    const t = i / 20;
                    const x = centerX - 30 + t * 60;
                    const y = topY + 50 + Math.pow(t, 2) * 150;
                    wordEl.style.left = x + 'px';
                    wordEl.style.top = y + 'px';
                    wordEl.style.fontSize = (8 + Math.random() * 6) + 'px';
                    container.appendChild(wordEl);
                    setTimeout(() => wordEl.remove(), 12000);
                }
            }
        }

        // ДЫХАНИЕ И ТРЕМОР ТЕКСТА
        function applyBreathingToText(lineElement) {
            setTimeout(() => {
                lineElement.classList.add('breathing');
            }, 200);
        }

        function applyTremorToText(lineElement) {
            setTimeout(() => {
                lineElement.classList.add('tremor');
            }, 100);
        }

        function forceCursorMovement(duration = 2500) {
            if (isMobile) return;
            forcedCursorActive = true;
            const cursor = document.getElementById('cursor');
            cursor.classList.add('forced');
            const startX = mouseX;
            const startY = mouseY;
            const targetX = Math.random() * window.innerWidth;
            const targetY = Math.random() * window.innerHeight;
            const startTime = Date.now();
            const animate = () => {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const eased = progress < 0.5 
                    ? 4 * progress * progress * progress 
                    : 1 - Math.pow(-2 * progress + 2, 3) / 2;
                mouseX = startX + (targetX - startX) * eased + (Math.sin(progress * Math.PI * 5) * 40);
                mouseY = startY + (targetY - startY) * eased + (Math.cos(progress * Math.PI * 5) * 40);
                cursor.style.left = mouseX + 'px';
                cursor.style.top = mouseY + 'px';
                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    forcedCursorActive = false;
                    cursor.classList.remove('forced');
                }
            };
            animate();
            if (navigator.vibrate) {
                navigator.vibrate([60, 120, 60, 120, 60]);
            }
        }

        function triggerRandomSubliminal() {
            if (progressionLevel < 0.4) return;
            const msg = subliminalMessages[Math.floor(Math.random() * subliminalMessages.length)];
            const subliminal = document.querySelector('.subliminal');
            subliminal.textContent = msg;
            subliminal.classList.add('active');
            setTimeout(() => subliminal.classList.remove('active'), 40);
        }

        function triggerMicroFlash() {
            if (progressionLevel < 0.25 || finalSequenceActive) return;
            if (Math.random() > 0.55) return;
            const flash = document.querySelector('.subliminal-flash');
            if (!flash || flash.classList.contains('active')) return;
            const flashImg = flash.querySelector('.subliminal-image');
            flashImg.textContent = microFlashSymbols[Math.floor(Math.random() * microFlashSymbols.length)];
            flash.classList.add('active');
            setTimeout(() => flash.classList.remove('active'), 60);
        }

        function initAtmosphere() {
            if (!audioContext) return;
            try {
                // DEEPEST INFRASOUND - максимальное физическое давление
                ambientLayers.push(createDrone(12, 0.06, 'lowpass', 40, 28));
                ambientLayers.push(createDrone(13.5, 0.06, 'lowpass', 40, 28));
                ambientLayers.push(createDrone(15, 0.05, 'lowpass', 60, 22));
                ambientLayers.push(createDrone(17, 0.05, 'lowpass', 70, 22));
                ambientLayers.push(createDrone(19, 0.045, 'lowpass', 85, 20));
                
                // Binaural horror - МАКСИМАЛЬНАЯ ИНТЕНСИВНОСТЬ
                ambientLayers.push(createDrone(38, 0.04, 'lowpass', 110, 12));
                ambientLayers.push(createDrone(38.9, 0.04, 'lowpass', 110, 12));
                
                // MAXIMUM Dissonance
                ambientLayers.push(createDrone(90, 0, 'bandpass', 200, 12));
                ambientLayers.push(createDrone(97, 0, 'bandpass', 200, 12));
                ambientLayers.push(createDrone(105, 0, 'bandpass', 230, 10));
                ambientLayers.push(createDrone(112, 0, 'bandpass', 230, 10));
                
                // Tritone - максимальный дискомфорт
                ambientLayers.push(createDrone(210, 0, 'bandpass', 380, 8));
                ambientLayers.push(createDrone(297, 0, 'bandpass', 380, 8));
                
                // METALLIC HELL
                ambientLayers.push(createDrone(650, 0, 'bandpass', 680, 18));
                ambientLayers.push(createDrone(975, 0, 'bandpass', 980, 15));
                
                // High frequency discomfort
                ambientLayers.push(createDrone(440, 0, 'bandpass', 480, 6));
                ambientLayers.push(createDrone(443, 0, 'bandpass', 480, 6));
                
                // CONTINUOUS PRESSURE
                const pressureOsc = audioContext.createOscillator();
                const pressureGain = audioContext.createGain();
                const pressureFilter = audioContext.createBiquadFilter();
                pressureOsc.type = 'sine';
                pressureOsc.frequency.value = 16;
                pressureFilter.type = 'lowpass';
                pressureFilter.frequency.value = 32;
                pressureFilter.Q.value = 20;
                pressureOsc.connect(pressureFilter);
                pressureFilter.connect(pressureGain);
                pressureGain.connect(audioContext.destination);
                pressureGain.gain.setValueAtTime(0, audioContext.currentTime);
                pressureGain.gain.linearRampToValueAtTime(0.1, audioContext.currentTime + 30);
                pressureOsc.start();
                ambientLayers.push({ osc: pressureOsc, gain: pressureGain, filter: pressureFilter });
                
                createShepardTone();
                createRandomScreams();
                createSubsonicPulse();
                createMetallicAmbient();
                createDistantEchoes();
                
                setInterval(() => {
                    ambientLayers.forEach(layer => {
                        if (layer && layer.gain) {
                            const time = audioContext.currentTime;
                            const currentGain = layer.gain.gain.value;
                            const variation = 0.04 * (1 + progressionLevel * 6);
                            layer.gain.gain.cancelScheduledValues(time);
                            layer.gain.gain.setValueAtTime(currentGain, time);
                            layer.gain.gain.linearRampToValueAtTime(
                                currentGain + variation * (Math.random() - 0.5), 
                                time + 1 + Math.random() * 2.5
                            );
                        }
                    });
                }, 1000);
            } catch (err) {}
        }

        function createDrone(freq, initialGain, filterType, filterFreq, Q) {
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            const filter = audioContext.createBiquadFilter();
            osc.type = 'sine';
            osc.frequency.value = freq;
            filter.type = filterType;
            filter.frequency.value = filterFreq;
            filter.Q.value = Q;
            osc.connect(filter);
            filter.connect(gain);
            gain.connect(audioContext.destination);
            gain.gain.setValueAtTime(0, audioContext.currentTime);
            if (initialGain > 0) {
                gain.gain.linearRampToValueAtTime(initialGain, audioContext.currentTime + 20);
            }
            osc.start();
            return { osc, gain, filter, baseFreq: freq, baseGain: initialGain };
        }

        function createShepardTone() {
            const shepardLayers = [];
            for (let i = 0; i < 6; i++) {
                const freq = 50 * Math.pow(2, i);
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                osc.type = 'sine';
                osc.frequency.value = freq;
                osc.connect(gain);
                gain.connect(audioContext.destination);
                const envelope = Math.exp(-Math.pow((i - 3), 2) / 4);
                gain.gain.setValueAtTime(0, audioContext.currentTime);
                osc.start();
                shepardLayers.push({ osc, gain, envelope });
            }
            setInterval(() => {
                shepardLayers.forEach(layer => {
                    const time = audioContext.currentTime;
                    const targetGain = layer.envelope * 0.03 * (1 + progressionLevel * 3.5);
                    layer.gain.gain.linearRampToValueAtTime(targetGain, time + 1);
                    const currentFreq = layer.osc.frequency.value;
                    const newFreq = currentFreq / 1.015;
                    layer.osc.frequency.linearRampToValueAtTime(newFreq, time + 0.5);
                    if (newFreq < 50 * 0.9) {
                        layer.osc.frequency.setValueAtTime(newFreq * 2, time + 0.5);
                    }
                });
            }, 400);
            ambientLayers.push(...shepardLayers);
        }

        function createRandomScreams() {
            setInterval(() => {
                if (progressionLevel < 0.4 || Math.random() > (0.18 + progressionLevel * 0.3)) return;
                const now = audioContext.currentTime;
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                const filter = audioContext.createBiquadFilter();
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(900 + Math.random() * 900, now);
                osc.frequency.exponentialRampToValueAtTime(280 + Math.random() * 300, now + 0.5);
                filter.type = 'bandpass';
                filter.frequency.value = 1200 + Math.random() * 1500;
                filter.Q.value = 18;
                osc.connect(filter);
                filter.connect(gain);
                gain.connect(audioContext.destination);
                const maxGain = 0.1 * Math.pow(progressionLevel, 0.7);
                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(maxGain, now + 0.06);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.5);
                osc.start(now);
                try { osc.stop(now + 0.5); } catch(e) {}
                if (navigator.vibrate && Math.random() < 0.5) {
                    navigator.vibrate([120, 60, 120]);
                }
            }, 4500);
        }

        function createSubsonicPulse() {
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            const filter = audioContext.createBiquadFilter();
            osc.type = 'sine';
            osc.frequency.value = 11;
            filter.type = 'lowpass';
            filter.frequency.value = 45;
            osc.connect(filter);
            filter.connect(gain);
            gain.connect(audioContext.destination);
            gain.gain.setValueAtTime(0, audioContext.currentTime);
            osc.start();
            ambientLayers.push({ osc, gain, filter });
            setInterval(() => {
                if (progressionLevel > 0.6) {
                    const time = audioContext.currentTime;
                    gain.gain.linearRampToValueAtTime(0.06 * progressionLevel, time + 0.1);
                    gain.gain.linearRampToValueAtTime(0, time + 0.35);
                }
            }, 2500);
        }

        function createMetallicAmbient() {
            setInterval(() => {
                if (progressionLevel < 0.3 || Math.random() > 0.3) return;
                const now = audioContext.currentTime;
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                const filter = audioContext.createBiquadFilter();
                osc.type = 'triangle';
                const baseFreq = 750 + Math.random() * 2200;
                osc.frequency.value = baseFreq;
                filter.type = 'bandpass';
                filter.frequency.value = baseFreq;
                filter.Q.value = 28;
                osc.connect(filter);
                filter.connect(gain);
                gain.connect(audioContext.destination);
                const maxGain = 0.06 * progressionLevel;
                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(maxGain, now + 2.5);
                gain.gain.linearRampToValueAtTime(0, now + 9);
                filter.frequency.linearRampToValueAtTime(baseFreq * 0.65, now + 9);
                osc.start(now);
                try { osc.stop(now + 9); } catch(e) {}
            }, 10000);
        }

        function createDistantEchoes() {
            setInterval(() => {
                if (progressionLevel < 0.45 || Math.random() > 0.22) return;
                const now = audioContext.currentTime;
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                const filter = audioContext.createBiquadFilter();
                const delay = audioContext.createDelay();
                const delayGain = audioContext.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(180 + Math.random() * 420, now);
                osc.frequency.exponentialRampToValueAtTime(90 + Math.random() * 220, now + 4.5);
                filter.type = 'bandpass';
                filter.frequency.value = 320;
                filter.Q.value = 18;
                delay.delayTime.value = 0.9;
                delayGain.gain.value = 0.65;
                osc.connect(filter);
                filter.connect(gain);
                filter.connect(delay);
                delay.connect(delayGain);
                delayGain.connect(gain);
                gain.connect(audioContext.destination);
                const maxGain = 0.05 * Math.pow(progressionLevel, 1.3);
                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(maxGain, now + 1.2);
                gain.gain.linearRampToValueAtTime(0, now + 5.5);
                osc.start(now);
                try { osc.stop(now + 5.5); } catch(e) {}
            }, 13000);
        }

        function updateAtmosphere(progress) {
            if (!audioContext) return;
            try {
                const time = audioContext.currentTime;
                // DEEPEST INFRASOUND - нарастает агрессивно
                for (let i = 0; i < 5; i++) {
                    if (ambientLayers[i]) {
                        const infraGain = (0.06 - i * 0.01) + progress * 0.18;
                        ambientLayers[i].gain.gain.linearRampToValueAtTime(infraGain, time + 2);
                    }
                }
                // Binaural - МАКСИМУМ
                if (ambientLayers[5] && ambientLayers[6]) {
                    const bassGain = 0.04 + progress * 0.18;
                    ambientLayers[5].gain.gain.linearRampToValueAtTime(bassGain, time + 2);
                    ambientLayers[6].gain.gain.linearRampToValueAtTime(bassGain, time + 2);
                    const newFreq = 38 - progress * 20;
                    ambientLayers[5].osc.frequency.linearRampToValueAtTime(newFreq, time + 2);
                    ambientLayers[6].osc.frequency.linearRampToValueAtTime(newFreq + 0.9, time + 2);
                }
                // Dissonance layers
                for (let i = 7; i < 11; i++) {
                    if (ambientLayers[i] && progress > 0.15) {
                        const disGain = Math.pow((progress - 0.15) / 0.85, 1.3) * 0.2;
                        ambientLayers[i].gain.gain.linearRampToValueAtTime(disGain, time + 2);
                    }
                }
                // Tritone
                if (ambientLayers[11] && ambientLayers[12] && progress > 0.4) {
                    const tritoneGain = Math.pow((progress - 0.4) / 0.6, 1.8) * 0.25;
                    ambientLayers[11].gain.gain.linearRampToValueAtTime(tritoneGain, time + 2);
                    ambientLayers[12].gain.gain.linearRampToValueAtTime(tritoneGain, time + 2);
                }
                // METALLIC
                if (ambientLayers[13] && ambientLayers[14] && progress > 0.5) {
                    const metallicGain = Math.pow((progress - 0.5) / 0.5, 2.2) * 0.16;
                    ambientLayers[13].gain.gain.linearRampToValueAtTime(metallicGain, time + 2);
                    ambientLayers[14].gain.gain.linearRampToValueAtTime(metallicGain, time + 2);
                }
                // High frequency
                if (ambientLayers[15] && ambientLayers[16] && progress > 0.55) {
                    const detunedGain = Math.pow((progress - 0.55) / 0.45, 1.8) * 0.14;
                    ambientLayers[15].gain.gain.linearRampToValueAtTime(detunedGain, time + 2);
                    ambientLayers[16].gain.gain.linearRampToValueAtTime(detunedGain, time + 2);
                }
            } catch (err) {}
        }

        async function triggerFinalHorror() {
            finalSequenceActive = true;
            if (microFlashInterval) {
                clearInterval(microFlashInterval);
                microFlashInterval = null;
            }
            // Максимальная интенсивность звука
            if (audioContext) {
                ambientLayers.forEach(layer => {
                    if (layer && layer.gain) {
                        const time = audioContext.currentTime;
                        const currentGain = layer.gain.gain.value;
                        layer.gain.gain.linearRampToValueAtTime(currentGain * 2.5, time + 2);
                    }
                });
            }
            
            const container = document.getElementById('final-horror-container');
            const smileContainer = container.querySelector('.smile-container');
            const content = document.getElementById('content');
            content.style.display = 'none';
            container.style.display = 'block';
            
            // Страшные слова связанные с рассказом
            const horrorWords = [
                'ЗАБЫЛ', 'НЕ ПОМНИТ', 'ПУСТОТА', 'СМЕРТЬ', 'ВОДА', 'МАШИНА', 'КАЖДЫЙ ДЕНЬ',
                'БОЛЬ', 'СТРАХ', 'РАСПАД', 'ХОЛОД', 'ЛУЖА', 'КРОВЬ', 'РУКИ', 'ГЛАЗА',
                'ОТЕЦ', 'СЫН', 'БЕЗУМИЕ', 'НИКОГДА', 'ПОВТОР', 'ЦИКЛ', 'УЖАС', 'КОНЕЦ',
                'КРИК', 'ТЬМА', 'РАЗРУШЕНИЕ', 'ПУСТЫЕ', 'ТРУП', 'ЖИВОЙ ТРУП', 'ДЕМЕНЦИЯ',
                'ПОТЕРЯН', 'ЗАБВЕНИЕ', 'БЕЗЫСХОДНОСТЬ', 'АД', 'ЛЮБОВЬ', 'ДОЛГ', 'СЕМЬЯ'
            ];
            
            // Создаем в 50 раз больше слов для плотности
            const wordElements = [];
            for (let i = 0; i < 200; i++) {
                const word = horrorWords[Math.floor(Math.random() * horrorWords.length)];
                const wordEl = document.createElement('div');
                wordEl.className = 'final-word';
                wordEl.textContent = word;
                wordEl.style.left = Math.random() * window.innerWidth + 'px';
                wordEl.style.top = Math.random() * window.innerHeight + 'px';
                wordEl.style.fontSize = (12 + Math.random() * 14) + 'px';
                container.appendChild(wordEl);
                wordElements.push(wordEl);
                
                // Постепенное появление
                setTimeout(() => {
                    wordEl.style.opacity = Math.random() * 0.7 + 0.3;
                }, i * 15);
            }
            
            // Пауза 2 секунды
            await new Promise(resolve => setTimeout(resolve, 2000));
            
            // Постепенно делаем слова кровавыми
            for (let i = 0; i < wordElements.length; i++) {
                setTimeout(() => {
                    wordElements[i].classList.add('bloodify');
                    if (i % 20 === 0 && navigator.vibrate) {
                        navigator.vibrate(80);
                    }
                }, i * 20);
            }
            
            // Звук нарастающего ужаса
            if (audioContext) {
                const now = audioContext.currentTime;
                const terror = audioContext.createOscillator();
                const terrorGain = audioContext.createGain();
                const terrorFilter = audioContext.createBiquadFilter();
                terror.type = 'sawtooth';
                terror.frequency.setValueAtTime(40, now);
                terror.frequency.linearRampToValueAtTime(8, now + 4);
                terrorFilter.type = 'lowpass';
                terrorFilter.frequency.value = 200;
                terrorFilter.Q.value = 15;
                terror.connect(terrorFilter);
                terrorFilter.connect(terrorGain);
                terrorGain.connect(audioContext.destination);
                terrorGain.gain.setValueAtTime(0, now);
                terrorGain.gain.linearRampToValueAtTime(0.15, now + 4);
                terror.start(now);
                setTimeout(() => { try { terror.stop(); } catch(e) {} }, 4000);
            }
            
            await new Promise(resolve => setTimeout(resolve, 4000));
            
            // Формируем жуткий смайлик из слов
            const smileWidth = Math.min(window.innerWidth * 0.6, 600);
            const smileHeight = Math.min(window.innerHeight * 0.6, 600);
            const centerX = window.innerWidth / 2;
            const centerY = window.innerHeight / 2;
            
            // Контуры лица (круг)
            const faceWords = [];
            for (let angle = 0; angle < Math.PI * 2; angle += 0.15) {
                const radius = smileWidth * 0.45;
                const x = centerX + Math.cos(angle) * radius;
                const y = centerY + Math.sin(angle) * radius;
                faceWords.push({ x, y });
            }
            
            // Левый глаз
            const leftEyeWords = [];
            for (let angle = 0; angle < Math.PI * 2; angle += 0.3) {
                const radius = smileWidth * 0.08;
                const x = centerX - smileWidth * 0.2 + Math.cos(angle) * radius;
                const y = centerY - smileHeight * 0.15 + Math.sin(angle) * radius;
                leftEyeWords.push({ x, y });
            }
            
            // Правый глаз
            const rightEyeWords = [];
            for (let angle = 0; angle < Math.PI * 2; angle += 0.3) {
                const radius = smileWidth * 0.08;
                const x = centerX + smileWidth * 0.2 + Math.cos(angle) * radius;
                const y = centerY - smileHeight * 0.15 + Math.sin(angle) * radius;
                rightEyeWords.push({ x, y });
            }
            
            // Жуткая улыбка (широкая, до ушей)
            const smileWords = [];
            for (let t = 0; t <= 1; t += 0.02) {
                const angle = Math.PI + t * Math.PI * 0.7;
                const radius = smileWidth * 0.35;
                const x = centerX + Math.cos(angle) * radius;
                const y = centerY + smileHeight * 0.05 + Math.sin(angle) * radius * 0.6;
                smileWords.push({ x, y });
            }
            
            const allSmilePositions = [...faceWords, ...leftEyeWords, ...rightEyeWords, ...smileWords];
            
            // Анимация формирования смайлика
            for (let i = 0; i < Math.min(wordElements.length, allSmilePositions.length); i++) {
                const pos = allSmilePositions[i];
                setTimeout(() => {
                    wordElements[i].classList.add('positioned');
                    wordElements[i].style.left = pos.x + 'px';
                    wordElements[i].style.top = pos.y + 'px';
                    wordElements[i].style.fontSize = '16px';
                }, i * 15);
            }
            
            // Звук формирования
            if (audioContext) {
                playSound('scream');
                setTimeout(() => playSound('crack'), 1000);
                setTimeout(() => playSound('scream'), 2000);
            }
            
            await new Promise(resolve => setTimeout(resolve, 3000));
            
            // Смайлик полностью сформирован - пауза для давления
            smileContainer.style.opacity = '1';
            
            if (navigator.vibrate) {
                navigator.vibrate([200, 100, 200, 100, 200]);
            }
            
            await new Promise(resolve => setTimeout(resolve, 2000));
            
            // Серия сублиминальных вспышек с ужасающими образами
            const subliminal = document.querySelector('.subliminal-flash');
            const subliminalImg = subliminal.querySelector('.subliminal-image');
            
            const curatedSequence = ['🙂', '💀', '🙂', 'СЕКС', 'СМЕРТЬ', '💀', '🙂'];
            const extraFlashes = ['😱', '👁️', '🩸', 'НЕ СПАСЁТСЯ', 'РАСПАД', '⚠️'];
            const totalFlashes = curatedSequence.length + 9;

            for (let i = 0; i < totalFlashes; i++) {
                const symbol = i < curatedSequence.length
                    ? curatedSequence[i]
                    : extraFlashes[Math.floor(Math.random() * extraFlashes.length)];
                subliminalImg.textContent = symbol;
                subliminal.classList.add('active');

                if (audioContext) {
                    const now = audioContext.currentTime;
                    const flash = audioContext.createOscillator();
                    const flashGain = audioContext.createGain();
                    flash.type = 'square';
                    flash.frequency.value = 1100 + Math.random() * 1900;
                    flash.connect(flashGain);
                    flashGain.connect(audioContext.destination);
                    flashGain.gain.setValueAtTime(0.08, now);
                    flashGain.gain.exponentialRampToValueAtTime(0.001, now + 0.05);
                    flash.start(now);
                    try { flash.stop(now + 0.05); } catch(e) {}
                }

                await new Promise(resolve => setTimeout(resolve, 100));
                subliminal.classList.remove('active');
                const pause = i < curatedSequence.length ? 120 : Math.random() * 280 + 120;
                await new Promise(resolve => setTimeout(resolve, pause));
            }
            
            // Финальная distortion
            container.style.animation = 'finalDistortion 2s';
            
            if (audioContext) {
                ambientLayers.forEach(layer => {
                    if (layer && layer.gain) {
                        const time = audioContext.currentTime;
                        layer.gain.gain.linearRampToValueAtTime(0, time + 2);
                    }
                });
            }
            
            await new Promise(resolve => setTimeout(resolve, 2000));
            
            // Все исчезает в черноту
            container.style.opacity = '0';
            container.style.transition = 'opacity 1s';
        }

        function increaseIntensity(lineIndex) {
            progressionLevel = lineIndex / story.length;
            updateAtmosphere(progressionLevel);
            updateObsessionDynamics(progressionLevel);
            document.querySelector('.static').style.opacity = 0.12 + progressionLevel * 0.55;
            document.querySelector('.vignette').style.boxShadow =
                `inset 0 0 ${500 + progressionLevel * 2500}px rgba(0,0,0,${0.95 + progressionLevel * 0.05})`;
            document.querySelector('.breath-overlay').style.animation =
                `breatheOppressive ${Math.max(0.5, 7 - progressionLevel * 6.5)}s infinite`;
            document.querySelector('.grain').style.opacity = progressionLevel * 0.6;
            if (progressionLevel > 0.45 && Math.random() < (progressionLevel - 0.45) * 0.15) {
                triggerWatching();
            }
            if (progressionLevel > 0.35 && Math.random() < (progressionLevel - 0.35) * 0.18) {
                triggerPeripheralHorror();
            }
            if (progressionLevel > 0.25 && Math.random() < (progressionLevel - 0.25) * 0.9) {
                addForgottenWord();
            }
            if (progressionLevel > 0.5 && Math.random() < 0.04) {
                triggerScreenTear();
            }
        }

        function addObsessiveWord(word) {
            if (!word) return;
            if (!obsessionFieldActive) {
                startObsessionField();
            }
            const highlight = progressionLevel > 0.55 && Math.random() < 0.35 ? 'blood' : null;
            registerObsessionWord(word, { highlight });
        }

        function addForgottenWord() {
            if (forgottenWords.length > 350) return;
            const word = FORGOTTEN[Math.floor(Math.random() * FORGOTTEN.length)];
            const wordEl = document.createElement('div');
            wordEl.className = 'forgotten-word';
            wordEl.textContent = word;
            wordEl.style.left = (1 + Math.random() * 98) + '%';
            wordEl.style.top = (1 + Math.random() * 98) + '%';
            wordEl.style.transform = `rotate(${(Math.random() - 0.5) * 45}deg)`;
            document.getElementById('forgotten-words').appendChild(wordEl);
            setTimeout(() => wordEl.classList.add('active'), 100);
            forgottenWords.push(wordEl);
        }

        function triggerBlackout(duration) {
            const blackout = document.querySelector('.blackout');
            blackout.classList.add('active');
            setTimeout(() => blackout.classList.remove('active'), duration);
        }

        function triggerStrobe(duration) {
            const strobe = document.querySelector('.strobe');
            strobe.classList.add('active');
            setTimeout(() => strobe.classList.remove('active'), duration);
            if (navigator.vibrate) {
                const pattern = [];
                for (let i = 0; i < duration / 80; i++) {
                    pattern.push(50, 30);
                }
                navigator.vibrate(pattern);
            }
        }

        function triggerChromatic() {
            const chromatic = document.querySelector('.chromatic');
            chromatic.classList.add('active');
            setTimeout(() => chromatic.classList.remove('active'), 300);
        }

        function triggerWatching() {
            isWatching = true;
            const watching = document.querySelector('.watching-overlay');
            watching.style.setProperty('--x', (mouseX / window.innerWidth * 100) + '%');
            watching.style.setProperty('--y', (mouseY / window.innerHeight * 100) + '%');
            watching.classList.add('active');
            document.getElementById('cursor').classList.add('watching');
            setTimeout(() => {
                watching.classList.remove('active');
                document.getElementById('cursor').classList.remove('watching');
                isWatching = false;
            }, 5000);
            if (navigator.vibrate) {
                navigator.vibrate([120, 60, 120, 60, 120]);
            }
        }

        function triggerPeripheralHorror() {
            const side = Math.random() < 0.5 ? 'left' : 'right';
            const peripheral = document.querySelector(`.peripheral-horror.${side}`);
            peripheral.classList.add('active');
            setTimeout(() => peripheral.classList.remove('active'), 150);
            if (navigator.vibrate && Math.random() < 0.4) {
                navigator.vibrate(60);
            }
        }

        function triggerScreenTear() {
            const tear = document.querySelector('.screen-tear');
            tear.classList.add('active');
            setTimeout(() => tear.classList.remove('active'), 600);
        }

        function triggerTimeDistortion() {
            const distortion = document.querySelector('.time-distortion');
            distortion.classList.add('active');
            setTimeout(() => distortion.classList.remove('active'), 4000);
        }

        function triggerRealityGlitch() {
            const glitch = document.querySelector('.reality-glitch');
            glitch.classList.add('active');
            setTimeout(() => glitch.classList.remove('active'), 400);
            if (navigator.vibrate) {
                navigator.vibrate([60, 40, 60, 40, 60]);
            }
        }

        function updateCinematicFocus(index, text) {
            const content = document.getElementById('content');
            if (!content) return;
            const progress = index / story.length;
            const lower = text.toLowerCase();
            const intense = lower.includes('никогда') || lower.includes('сейчас') || lower.includes('кров') || lower.includes('смер');
            const baseScale = 1 + progress * 0.08;
            const scaleBoost = intense ? 0.06 : 0.02 * Math.sin(progress * Math.PI);
            const targetScale = baseScale + scaleBoost;
            const rawPan = (Math.random() - 0.5) * (16 + progress * 60);
            const pan = lastFocusPan + (rawPan - lastFocusPan) * 0.55;
            lastFocusPan = pan;
            const rawTilt = (Math.random() - 0.5) * (progress > 0.55 ? 8 : 4);
            const tilt = lastFocusTilt + (rawTilt - lastFocusTilt) * 0.6;
            lastFocusTilt = tilt;
            const blur = progress > 0.72 ? Math.min(1.2, (progress - 0.72) * 6) : 0;
            const contrast = 1.12 + progress * 0.45 + (intense ? 0.12 : 0);

            content.style.setProperty('--focus-scale', targetScale.toFixed(3));
            content.style.setProperty('--focus-pan', pan.toFixed(1) + 'px');
            content.style.setProperty('--focus-tilt', tilt.toFixed(2) + 'deg');
            content.style.setProperty('--focus-contrast', contrast.toFixed(2));
            content.style.setProperty('--focus-blur', blur.toFixed(2) + 'px');
        }

        async function startExperience() {
            const content = document.getElementById('content');
            try {
                for (let i = 0; i < story.length; i++) {
                    const parts = story[i].split('|');
                    const text = parts[0];
                    const wait = parseInt(parts[1]);
                    const effects = parts.slice(2);
                    increaseIntensity(i);
                    updateCinematicFocus(i, text);
                    content.innerHTML = '';
                    if (text.trim()) {
                        const div = document.createElement('div');
                        div.className = 'line';
                        div.innerHTML = text;
                        content.appendChild(div);
                        setTimeout(() => div.classList.add('active'), 100);
                        
                        // АВТОМАТИЧЕСКОЕ ПРИМЕНЕНИЕ ПСИХОЛОГИЧЕСКИХ ЭФФЕКТОВ
                        // Дыхание для эмоциональных моментов
                        if (progressionLevel > 0.3 && (
                            text.includes('смотришь') || 
                            text.includes('видишь') || 
                            text.includes('чувствуешь') ||
                            text.includes('дышит') ||
                            text.includes('ждёшь')
                        )) {
                            applyBreathingToText(div);
                        }
                        
                        // Тремор для тревожных моментов
                        if (progressionLevel > 0.4 && (
                            text.includes('страх') ||
                            text.includes('трясутся') ||
                            text.includes('боль') ||
                            text.includes('кричит') ||
                            text.includes('ломается')
                        )) {
                            applyTremorToText(div);
                        }
                        
                        for (const effect of effects) {
                            if (effect === 'break') {
                                div.classList.add('break-wall');
                            }
                            else if (effect === 'glitch') {
                                setTimeout(() => div.classList.add('glitched'), 100);
                                setTimeout(() => div.classList.remove('glitched'), 2000);
                            }
                            else if (effect === 'shake') {
                                content.classList.add('shake');
                            }
                            else if (effect === 'distorted') {
                                setTimeout(() => div.classList.add('distorted'), 100);
                            }
                            else if (effect === 'watching') {
                                triggerWatching();
                                // Добавляем парейдолию глаз при watching
                                if (Math.random() < 0.4) {
                                    setTimeout(() => createPareidoliaPattern('eyes'), 500);
                                }
                            }
                            else if (effect === 'cursormove' || effect === 'peripheralshadow') {
                                triggerPeripheralShadows();
                            }
                            else if (effect === 'peripheral') {
                                triggerPeripheralHorror();
                                // Иногда добавляем фигуру
                                if (Math.random() < 0.25) {
                                    setTimeout(() => createPareidoliaPattern('figure'), 800);
                                }
                            }
                            else if (effect === 'chromatic') {
                                triggerChromatic();
                            }
                            else if (effect === 'screentear') {
                                triggerScreenTear();
                            }
                            else if (effect === 'timedistort') {
                                triggerTimeDistortion();
                            }
                            else if (effect === 'reality') {
                                triggerRealityGlitch();
                            }
                            else if (effect === 'heartbeat') {
                                const hb = document.querySelector('.heartbeat');
                                hb.classList.add('active');
                                setTimeout(() => hb.classList.remove('active'), 3500);
                            }
                            else if (effect === 'water') {
                                for (let j = 0; j < 4; j++) {
                                    setTimeout(() => createWaterDrop(), j * 250);
                                }
                            }
                            else if (effect === 'blooddrop') {
                                for (let j = 0; j < 3; j++) {
                                    setTimeout(() => createBloodDrop(), j * 350);
                                }
                            }
                            else if (effect === 'wetstain') {
                                createWetStain();
                            }
                            else if (effect === 'breathfog') {
                                triggerBreathFog();
                            }
                            else if (effect === 'crack') {
                                triggerScreenCrack();
                            }
                            else if (effect === 'finalhorror') {
                                await triggerFinalHorror();
                            }
                            else if (effect === 'silence') {
                                if (audioContext) {
                                    ambientLayers.forEach(layer => {
                                        if (layer && layer.gain) {
                                            const time = audioContext.currentTime;
                                            const current = layer.gain.gain.value;
                                            layer.gain.gain.linearRampToValueAtTime(current * 0.08, time + 0.5);
                                            setTimeout(() => {
                                                layer.gain.gain.linearRampToValueAtTime(current, time + 2.5);
                                            }, 1000);
                                        }
                                    });
                                }
                            }
                            else if (effect.startsWith('subliminal:')) {
                                const msg = effect.split(':')[1];
                                const subliminal = document.querySelector('.subliminal');
                                subliminal.textContent = msg;
                                subliminal.classList.add('active');
                                setTimeout(() => subliminal.classList.remove('active'), 40);
                            }
                            else if (effect.startsWith('blackout:')) {
                                const duration = parseInt(effect.split(':')[1]);
                                setTimeout(() => triggerBlackout(duration), 100);
                            }
                            else if (effect.startsWith('strobe:')) {
                                const duration = parseInt(effect.split(':')[1]);
                                setTimeout(() => triggerStrobe(duration), 100);
                            }
                            else if (effect === 'shadow') {
                                const side = Math.random() < 0.5 ? 'left' : 'right';
                                const shadowEl = document.querySelector(`.shadow.${side}`);
                                shadowEl.classList.add('active');
                                setTimeout(() => shadowEl.classList.remove('active'), 3000);
                            }
                            else if (effect === 'blood') {
                                div.classList.add('blood');
                                document.querySelector('.blood-screen').classList.add('active');
                                setTimeout(() => document.querySelector('.blood-screen').classList.remove('active'), 4000);
                            }
                            else if (effect === 'redFlicker') {
                                const flickerEl = document.querySelector('.red-flicker');
                                flickerEl.classList.add('active');
                                setTimeout(() => flickerEl.classList.remove('active'), 3000);
                            }
                            else if (effect === 'trail') {
                                setTimeout(() => div.classList.add('text-trail'), 100);
                            }
                            else if (effect === 'double') {
                                setTimeout(() => div.classList.add('double-vision'), 100);
                            }
                            else if (effect === 'freeze') {
                                setTimeout(() => div.classList.add('time-freeze'), 100);
                            }
                            else if (effect.startsWith('obsess:')) {
                                addObsessiveWord(effect.split(':')[1]);
                            }
                            else if (effect.startsWith('sound:')) {
                                playSound(effect.split(':')[1]);
                            }
                        }
                        if (effects.includes('shake')) {
                            setTimeout(() => content.classList.remove('shake'), 500);
                        }
                    }
                    await new Promise(resolve => setTimeout(resolve, wait));
                }
                // Fade out
                if (audioContext) {
                    const time = audioContext.currentTime;
                    ambientLayers.forEach(layer => {
                        if (layer && layer.gain) {
                            layer.gain.gain.linearRampToValueAtTime(0, time + 12);
                        }
                    });
                }
                setTimeout(() => {
                    if (audioContext) {
                        ambientLayers.forEach(layer => {
                            if (layer && layer.osc) {
                                try { layer.osc.stop(); } catch(e) {}
                            }
                        });
                    }
                    location.reload();
                }, 15000);
            } catch (err) {}
        }

        function playSound(type) {
            if (!audioContext) return;
            const now = audioContext.currentTime;
            if (type === 'tick') {
                const osc1 = audioContext.createOscillator();
                const osc2 = audioContext.createOscillator();
                const gain = audioContext.createGain();
                const filter = audioContext.createBiquadFilter();
                osc1.type = 'sine';
                osc2.type = 'sine';
                osc1.frequency.setValueAtTime(52, now);
                osc1.frequency.exponentialRampToValueAtTime(32, now + 0.1);
                osc2.frequency.setValueAtTime(104, now);
                osc2.frequency.exponentialRampToValueAtTime(64, now + 0.1);
                filter.type = 'lowpass';
                filter.frequency.value = 140;
                filter.Q.value = 10;
                osc1.connect(filter);
                osc2.connect(filter);
                filter.connect(gain);
                gain.connect(audioContext.destination);
                gain.gain.setValueAtTime(0.4, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.18);
                osc1.start(now);
                osc2.start(now);
                try {
                    osc1.stop(now + 0.18);
                    osc2.stop(now + 0.18);
                } catch(e) {}
                if (navigator.vibrate) {
                    navigator.vibrate(90);
                }
            }
            else if (type === 'step') {
                for (let i = 0; i < 2; i++) {
                    setTimeout(() => {
                        const noiseBuffer1 = audioContext.createBuffer(1, 8192, audioContext.sampleRate);
                        const noiseData1 = noiseBuffer1.getChannelData(0);
                        for (let j = 0; j < 8192; j++) {
                            noiseData1[j] = (Math.random() * 2 - 1) * Math.exp(-j / 1800);
                        }
                        const noise1 = audioContext.createBufferSource();
                        noise1.buffer = noiseBuffer1;
                        const filter1 = audioContext.createBiquadFilter();
                        filter1.type = 'lowpass';
                        filter1.frequency.value = 75 + Math.random() * 35;
                        filter1.Q.value = 4;
                        const gain1 = audioContext.createGain();
                        noise1.connect(filter1);
                        filter1.connect(gain1);
                        gain1.connect(audioContext.destination);
                        const t = audioContext.currentTime;
                        gain1.gain.setValueAtTime(0.5, t);
                        gain1.gain.exponentialRampToValueAtTime(0.01, t + 0.4);
                        noise1.start(t);
                        const noiseBuffer2 = audioContext.createBuffer(1, 4096, audioContext.sampleRate);
                        const noiseData2 = noiseBuffer2.getChannelData(0);
                        for (let j = 0; j < 4096; j++) {
                            noiseData2[j] = (Math.random() * 2 - 1) * (j < 600 ? 1 : Math.exp(-(j - 600) / 900));
                        }
                        const noise2 = audioContext.createBufferSource();
                        noise2.buffer = noiseBuffer2;
                        const filter2 = audioContext.createBiquadFilter();
                        filter2.type = 'bandpass';
                        filter2.frequency.value = 380 + Math.random() * 650;
                        filter2.Q.value = 14;
                        const gain2 = audioContext.createGain();
                        noise2.connect(filter2);
                        filter2.connect(gain2);
                        gain2.connect(audioContext.destination);
                        gain2.gain.setValueAtTime(0.28, t);
                        gain2.gain.exponentialRampToValueAtTime(0.01, t + 0.18);
                        noise2.start(t);
                        const noiseBuffer3 = audioContext.createBuffer(1, 2048, audioContext.sampleRate);
                        const noiseData3 = noiseBuffer3.getChannelData(0);
                        for (let j = 0; j < 2048; j++) {
                            noiseData3[j] = (Math.random() * 2 - 1) * (j < 250 ? 1 : 0);
                        }
                        const noise3 = audioContext.createBufferSource();
                        noise3.buffer = noiseBuffer3;
                        const filter3 = audioContext.createBiquadFilter();
                        filter3.type = 'highpass';
                        filter3.frequency.value = 1400 + Math.random() * 1100;
                        filter3.Q.value = 10;
                        const gain3 = audioContext.createGain();
                        noise3.connect(filter3);
                        filter3.connect(gain3);
                        gain3.connect(audioContext.destination);
                        gain3.gain.setValueAtTime(0.18, t);
                        gain3.gain.exponentialRampToValueAtTime(0.01, t + 0.1);
                        noise3.start(t);
                        const delay = audioContext.createDelay();
                        delay.delayTime.value = 0.1;
                        const delayGain = audioContext.createGain();
                        delayGain.gain.value = 0.35;
                        filter1.connect(delay);
                        delay.connect(delayGain);
                        delayGain.connect(audioContext.destination);
                        if (navigator.vibrate) {
                            navigator.vibrate([110, 35, 70]);
                        }
                    }, i * 600);
                }
            }
            else if (type === 'metallic') {
                const filter1 = audioContext.createBiquadFilter();
                const filter2 = audioContext.createBiquadFilter();
                const gain = audioContext.createGain();
                filter1.type = 'bandpass';
                filter1.frequency.value = 2400 + Math.random() * 2200;
                filter1.Q.value = 18;
                filter2.type = 'highpass';
                filter2.frequency.value = 1150;
                const buffer = audioContext.createBuffer(1, 16384, audioContext.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < 16384; i++) {
                    data[i] = (Math.random() * 2 - 1) * (1 - i / 16384);
                }
                const noise = audioContext.createBufferSource();
                noise.buffer = buffer;
                noise.playbackRate.value = 0.65;
                noise.connect(filter1);
                filter1.connect(filter2);
                filter2.connect(gain);
                gain.connect(audioContext.destination);
                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(0.2, now + 0.18);
                gain.gain.linearRampToValueAtTime(0.14, now + 1.4);
                gain.gain.linearRampToValueAtTime(0, now + 2);
                const lfo = audioContext.createOscillator();
                const lfoGain = audioContext.createGain();
                lfo.frequency.value = 3.8;
                lfoGain.gain.value = 450;
                lfo.connect(lfoGain);
                lfoGain.connect(filter1.frequency);
                noise.start(now);
                lfo.start(now);
                setTimeout(() => {
                    try {
                        noise.stop();
                        lfo.stop();
                    } catch(e) {}
                }, 2000);
                if (navigator.vibrate) {
                    navigator.vibrate([170, 90, 170, 90, 170]);
                }
            }
            else if (type === 'distant_voices') {
                for (let i = 0; i < 3; i++) {
                    setTimeout(() => {
                        const osc1 = audioContext.createOscillator();
                        const osc2 = audioContext.createOscillator();
                        const gain = audioContext.createGain();
                        const filter = audioContext.createBiquadFilter();
                        const delay = audioContext.createDelay();
                        const delayGain = audioContext.createGain();
                        osc1.type = 'sawtooth';
                        osc2.type = 'sine';
                        const baseFreq = 170 + Math.random() * 130;
                        osc1.frequency.setValueAtTime(baseFreq, now);
                        osc2.frequency.setValueAtTime(baseFreq * 1.01, now);
                        filter.type = 'bandpass';
                        filter.frequency.value = 280 + Math.random() * 220;
                        filter.Q.value = 10;
                        delay.delayTime.value = 0.35;
                        delayGain.gain.value = 0.45;
                        osc1.connect(filter);
                        osc2.connect(filter);
                        filter.connect(gain);
                        filter.connect(delay);
                        delay.connect(delayGain);
                        delayGain.connect(gain);
                        gain.connect(audioContext.destination);
                        const t = audioContext.currentTime;
                        gain.gain.setValueAtTime(0, t);
                        gain.gain.linearRampToValueAtTime(0.1, t + 0.6);
                        gain.gain.linearRampToValueAtTime(0.07, t + 2.5);
                        gain.gain.linearRampToValueAtTime(0, t + 3.5);
                        osc1.start(t);
                        osc2.start(t);
                        try {
                            osc1.stop(t + 3.5);
                            osc2.stop(t + 3.5);
                        } catch(e) {}
                    }, i * 1100 + Math.random() * 600);
                }
            }
            else if (type === 'void_hum') {
                const osc1 = audioContext.createOscillator();
                const osc2 = audioContext.createOscillator();
                const osc3 = audioContext.createOscillator();
                const gain = audioContext.createGain();
                const filter = audioContext.createBiquadFilter();
                osc1.type = 'sine';
                osc2.type = 'sine';
                osc3.type = 'triangle';
                osc1.frequency.value = 58;
                osc2.frequency.value = 58.5;
                osc3.frequency.value = 87;
                filter.type = 'lowpass';
                filter.frequency.value = 180;
                filter.Q.value = 14;
                osc1.connect(filter);
                osc2.connect(filter);
                osc3.connect(filter);
                filter.connect(gain);
                gain.connect(audioContext.destination);
                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(0.25, now + 2.5);
                gain.gain.linearRampToValueAtTime(0.2, now + 9);
                gain.gain.linearRampToValueAtTime(0, now + 11);
                filter.frequency.linearRampToValueAtTime(75, now + 11);
                osc1.start(now);
                osc2.start(now);
                osc3.start(now);
                setTimeout(() => {
                    try {
                        osc1.stop();
                        osc2.stop();
                        osc3.stop();
                    } catch(e) {}
                }, 11000);
            }
            else if (type === 'pressure') {
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                const filter = audioContext.createBiquadFilter();
                osc.type = 'sine';
                osc.frequency.value = 17;
                filter.type = 'lowpass';
                filter.frequency.value = 38;
                filter.Q.value = 22;
                osc.connect(filter);
                filter.connect(gain);
                gain.connect(audioContext.destination);
                const lfo = audioContext.createOscillator();
                const lfoGain = audioContext.createGain();
                lfo.frequency.value = 0.35;
                lfoGain.gain.value = 0.18;
                lfo.connect(lfoGain);
                lfoGain.connect(gain.gain);
                gain.gain.setValueAtTime(0.28, now);
                osc.start(now);
                lfo.start(now);
                setTimeout(() => {
                    try {
                        gain.gain.linearRampToValueAtTime(0, audioContext.currentTime + 1.2);
                        setTimeout(() => {
                            osc.stop();
                            lfo.stop();
                        }, 1200);
                    } catch(e) {}
                }, 4500);
                if (navigator.vibrate) {
                    navigator.vibrate([220, 110, 220, 110, 220, 110, 220]);
                }
            }
            else if (type === 'water' || type === 'waterambient') {
                const gain = audioContext.createGain();
                const filter1 = audioContext.createBiquadFilter();
                const filter2 = audioContext.createBiquadFilter();
                filter1.type = 'bandpass';
                filter1.frequency.value = 420 + Math.random() * 380;
                filter1.Q.value = 1.3;
                filter2.type = 'highpass';
                filter2.frequency.value = 170;
                const buffer = audioContext.createBuffer(1, 12288, audioContext.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < 12288; i++) {
                    data[i] = Math.random() * 2 - 1;
                }
                const noise = audioContext.createBufferSource();
                noise.buffer = buffer;
                noise.loop = true;
                noise.connect(filter1);
                filter1.connect(filter2);
                filter2.connect(gain);
                gain.connect(audioContext.destination);
                const duration = type === 'waterambient' ? 7000 : 4500;
                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(0.18, now + 0.7);
                gain.gain.linearRampToValueAtTime(0.14, now + (duration/1000) - 0.6);
                gain.gain.linearRampToValueAtTime(0, now + (duration/1000));
                const lfo = audioContext.createOscillator();
                const lfoGain = audioContext.createGain();
                lfo.frequency.value = 0.8;
                lfoGain.gain.value = 200;
                lfo.connect(lfoGain);
                lfoGain.connect(filter1.frequency);
                noise.start(now);
                lfo.start(now);
                setTimeout(() => {
                    try {
                        noise.stop();
                        lfo.stop();
                    } catch(e) {}
                }, duration);
            }
            else if (type === 'machine') {
                const noiseBuffer1 = audioContext.createBuffer(1, 44100, audioContext.sampleRate);
                const noiseData1 = noiseBuffer1.getChannelData(0);
                for (let i = 0; i < 44100; i++) {
                    noiseData1[i] = (Math.random() * 2 - 1) * 0.85;
                }
                const noise1 = audioContext.createBufferSource();
                noise1.buffer = noiseBuffer1;
                noise1.loop = true;
                const filter1 = audioContext.createBiquadFilter();
                filter1.type = 'lowpass';
                filter1.frequency.value = 115;
                filter1.Q.value = 18;
                const gain1 = audioContext.createGain();
                noise1.connect(filter1);
                filter1.connect(gain1);
                gain1.connect(audioContext.destination);
                gain1.gain.setValueAtTime(0, now);
                gain1.gain.linearRampToValueAtTime(0.2, now + 0.9);
                gain1.gain.setValueAtTime(0.2, now + 3.5);
                gain1.gain.linearRampToValueAtTime(0, now + 4.2);
                const noiseBuffer2 = audioContext.createBuffer(1, 44100, audioContext.sampleRate);
                const noiseData2 = noiseBuffer2.getChannelData(0);
                for (let i = 0; i < 44100; i++) {
                    noiseData2[i] = (Math.random() * 2 - 1) * 0.65;
                }
                const noise2 = audioContext.createBufferSource();
                noise2.buffer = noiseBuffer2;
                noise2.loop = true;
                const filter2 = audioContext.createBiquadFilter();
                filter2.type = 'bandpass';
                filter2.frequency.value = 230;
                filter2.Q.value = 28;
                const gain2 = audioContext.createGain();
                noise2.connect(filter2);
                filter2.connect(gain2);
                gain2.connect(audioContext.destination);
                gain2.gain.setValueAtTime(0, now);
                gain2.gain.linearRampToValueAtTime(0.14, now + 0.9);
                gain2.gain.setValueAtTime(0.14, now + 3.5);
                gain2.gain.linearRampToValueAtTime(0, now + 4.2);
                const lfo1 = audioContext.createOscillator();
                const lfoGain1 = audioContext.createGain();
                lfo1.frequency.value = 0.25;
                lfoGain1.gain.value = 22;
                lfo1.connect(lfoGain1);
                lfoGain1.connect(filter1.frequency);
                const lfo2 = audioContext.createOscillator();
                const lfoGain2 = audioContext.createGain();
                lfo2.frequency.value = 0.4;
                lfoGain2.gain.value = 35;
                lfo2.connect(lfoGain2);
                lfoGain2.connect(filter2.frequency);
                noise1.start(now);
                noise2.start(now);
                lfo1.start(now);
                lfo2.start(now);
                setTimeout(() => {
                    try {
                        noise1.stop();
                        noise2.stop();
                        lfo1.stop();
                        lfo2.stop();
                    } catch(e) {}
                }, 4200);
                if (navigator.vibrate) {
                    const pattern = [];
                    for (let i = 0; i < 9; i++) {
                        pattern.push(160, 220);
                    }
                    navigator.vibrate(pattern);
                }
            }
            else if (type === 'breathing') {
                for (let i = 0; i < 2; i++) {
                    setTimeout(() => {
                        const inhaleBuffer = audioContext.createBuffer(1, 22050, audioContext.sampleRate);
                        const inhaleData = inhaleBuffer.getChannelData(0);
                        for (let j = 0; j < 22050; j++) {
                            const envelope = Math.sin((j / 22050) * Math.PI);
                            inhaleData[j] = (Math.random() * 2 - 1) * envelope * 0.75;
                        }
                        const inhale = audioContext.createBufferSource();
                        inhale.buffer = inhaleBuffer;
                        const inhaleFilter = audioContext.createBiquadFilter();
                        inhaleFilter.type = 'bandpass';
                        inhaleFilter.frequency.value = 240 + Math.random() * 220;
                        inhaleFilter.Q.value = 3.5;
                        const inhaleGain = audioContext.createGain();
                        inhale.connect(inhaleFilter);
                        inhaleFilter.connect(inhaleGain);
                        inhaleGain.connect(audioContext.destination);
                        const t = audioContext.currentTime;
                        inhaleGain.gain.setValueAtTime(0, t);
                        inhaleGain.gain.linearRampToValueAtTime(0.25, t + 1);
                        inhaleGain.gain.linearRampToValueAtTime(0, t + 1.6);
                        inhaleFilter.frequency.linearRampToValueAtTime(360, t + 0.8);
                        inhale.start(t);
                        setTimeout(() => {
                            const exhaleBuffer = audioContext.createBuffer(1, 33075, audioContext.sampleRate);
                            const exhaleData = exhaleBuffer.getChannelData(0);
                            for (let j = 0; j < 33075; j++) {
                                const envelope = Math.sin((j / 33075) * Math.PI);
                                exhaleData[j] = (Math.random() * 2 - 1) * envelope * 0.65;
                            }
                            const exhale = audioContext.createBufferSource();
                            exhale.buffer = exhaleBuffer;
                            const exhaleFilter = audioContext.createBiquadFilter();
                            exhaleFilter.type = 'bandpass';
                            exhaleFilter.frequency.value = 190 + Math.random() * 160;
                            exhaleFilter.Q.value = 2.8;
                            const exhaleGain = audioContext.createGain();
                            exhale.connect(exhaleFilter);
                            exhaleFilter.connect(exhaleGain);
                            exhaleGain.connect(audioContext.destination);
                            const t2 = audioContext.currentTime;
                            exhaleGain.gain.setValueAtTime(0, t2);
                            exhaleGain.gain.linearRampToValueAtTime(0.2, t2 + 0.7);
                            exhaleGain.gain.linearRampToValueAtTime(0, t2 + 2);
                            exhaleFilter.frequency.linearRampToValueAtTime(170, t2 + 1.4);
                            exhale.start(t2);
                            try {
                                exhale.stop(t2 + 2);
                            } catch(e) {}
                        }, 1600);
                        try {
                            inhale.stop(t + 1.6);
                        } catch(e) {}
                    }, i * 4000);
                }
            }
            else if (type === 'scrub') {
                const noiseBuffer = audioContext.createBuffer(1, 22050, audioContext.sampleRate);
                const noiseData = noiseBuffer.getChannelData(0);
                for (let i = 0; i < 22050; i++) {
                    const cycle = Math.floor(i / 2000);
                    const intensity = 0.75 + Math.sin(cycle * 0.5) * 0.25;
                    noiseData[i] = (Math.random() * 2 - 1) * intensity;
                }
                const noise = audioContext.createBufferSource();
                noise.buffer = noiseBuffer;
                noise.playbackRate.value = 0.75 + Math.random() * 0.5;
                const filter1 = audioContext.createBiquadFilter();
                filter1.type = 'highpass';
                filter1.frequency.value = 580 + Math.random() * 450;
                filter1.Q.value = 3.5;
                const filter2 = audioContext.createBiquadFilter();
                filter2.type = 'bandpass';
                filter2.frequency.value = 1900 + Math.random() * 1600;
                filter2.Q.value = 10;
                const gain = audioContext.createGain();
                noise.connect(filter1);
                filter1.connect(filter2);
                filter2.connect(gain);
                gain.connect(audioContext.destination);
                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(0.14, now + 0.1);
                gain.gain.linearRampToValueAtTime(0.1, now + 0.3);
                gain.gain.linearRampToValueAtTime(0.14, now + 0.4);
                gain.gain.linearRampToValueAtTime(0, now + 0.6);
                const lfo = audioContext.createOscillator();
                const lfoGain = audioContext.createGain();
                lfo.frequency.value = 5.5 + Math.random() * 4.5;
                lfoGain.gain.value = 350;
                lfo.connect(lfoGain);
                lfoGain.connect(filter2.frequency);
                noise.start(now);
                lfo.start(now);
                setTimeout(() => {
                    try {
                        noise.stop();
                        lfo.stop();
                    } catch(e) {}
                }, 600);
                if (navigator.vibrate) {
                    navigator.vibrate([90, 50, 90, 50, 90]);
                }
            }
            else if (type === 'tear') {
                const tearBuffer = audioContext.createBuffer(1, 11025, audioContext.sampleRate);
                const tearData = tearBuffer.getChannelData(0);
                for (let i = 0; i < 11025; i++) {
                    const progress = i / 11025;
                    const intensity = Math.pow(progress, 0.3) * (1 - progress);
                    const fiber = Math.sin(i * 0.3) * 0.35;
                    tearData[i] = ((Math.random() * 2 - 1) * 0.75 + fiber) * intensity;
                }
                const tear = audioContext.createBufferSource();
                tear.buffer = tearBuffer;
                tear.playbackRate.value = 0.65 + Math.random() * 0.35;
                const tearFilter1 = audioContext.createBiquadFilter();
                tearFilter1.type = 'highpass';
                tearFilter1.frequency.value = 380;
                tearFilter1.Q.value = 3.5;
                const tearFilter2 = audioContext.createBiquadFilter();
                tearFilter2.type = 'bandpass';
                tearFilter2.frequency.value = 1150;
                tearFilter2.Q.value = 10;
                const tearGain = audioContext.createGain();
                tear.connect(tearFilter1);
                tearFilter1.connect(tearFilter2);
                tearFilter2.connect(tearGain);
                tearGain.connect(audioContext.destination);
                tearGain.gain.setValueAtTime(0.18, now);
                tearGain.gain.linearRampToValueAtTime(0.1, now + 0.18);
                tearGain.gain.exponentialRampToValueAtTime(0.01, now + 0.45);
                tearFilter2.frequency.linearRampToValueAtTime(580, now + 0.45);
                tear.start(now);
                try {
                    tear.stop(now + 0.45);
                } catch(e) {}
                if (navigator.vibrate) {
                    navigator.vibrate([70, 35, 100]);
                }
            }
            else if (type === 'scream') {
                const screamBuffer1 = audioContext.createBuffer(1, 22050, audioContext.sampleRate);
                const screamData1 = screamBuffer1.getChannelData(0);
                for (let i = 0; i < 22050; i++) {
                    const envelope = Math.sin((i / 22050) * Math.PI * 2);
                    const chaos = Math.sin(i * 0.05) * Math.sin(i * 0.012);
                    screamData1[i] = (Math.random() * 2 - 1) * Math.abs(envelope) * (0.85 + chaos * 0.15);
                }
                const scream1 = audioContext.createBufferSource();
                scream1.buffer = screamBuffer1;
                scream1.playbackRate.value = 1.15 + Math.random() * 0.35;
                const screamFilter1 = audioContext.createBiquadFilter();
                screamFilter1.type = 'bandpass';
                screamFilter1.frequency.value = 1750;
                screamFilter1.Q.value = 18;
                const screamGain1 = audioContext.createGain();
                scream1.connect(screamFilter1);
                screamFilter1.connect(screamGain1);
                screamGain1.connect(audioContext.destination);
                screamGain1.gain.setValueAtTime(0, now);
                screamGain1.gain.linearRampToValueAtTime(0.2, now + 0.1);
                screamGain1.gain.linearRampToValueAtTime(0.16, now + 0.35);
                screamGain1.gain.exponentialRampToValueAtTime(0.01, now + 0.7);
                screamFilter1.frequency.exponentialRampToValueAtTime(750, now + 0.7);
                const screamBuffer2 = audioContext.createBuffer(1, 11025, audioContext.sampleRate);
                const screamData2 = screamBuffer2.getChannelData(0);
                for (let i = 0; i < 11025; i++) {
                    const envelope = i < 2200 ? 1 : Math.exp(-(i - 2200) / 2200);
                    screamData2[i] = (Math.random() * 2 - 1) * envelope;
                }
                const scream2 = audioContext.createBufferSource();
                scream2.buffer = screamBuffer2;
                const screamFilter2 = audioContext.createBiquadFilter();
                screamFilter2.type = 'highpass';
                screamFilter2.frequency.value = 2900;
                screamFilter2.Q.value = 10;
                const screamGain2 = audioContext.createGain();
                scream2.connect(screamFilter2);
                screamFilter2.connect(screamGain2);
                screamGain2.connect(audioContext.destination);
                screamGain2.gain.setValueAtTime(0.14, now);
                screamGain2.gain.exponentialRampToValueAtTime(0.01, now + 0.35);
                scream1.start(now);
                scream2.start(now);
                try {
                    scream1.stop(now + 0.7);
                    scream2.stop(now + 0.35);
                } catch(e) {}
                if (navigator.vibrate) {
                    navigator.vibrate([170, 60, 220, 60, 170]);
                }
            }
            else if (type === 'crack') {
                const crackBuffer = audioContext.createBuffer(1, 2205, audioContext.sampleRate);
                const crackData = crackBuffer.getChannelData(0);
                for (let i = 0; i < 2205; i++) {
                    const envelope = i < 120 ? 1 : Math.exp(-(i - 120) / 320);
                    crackData[i] = (Math.random() * 2 - 1) * envelope;
                }
                const crack = audioContext.createBufferSource();
                crack.buffer = crackBuffer;
                const crackFilter1 = audioContext.createBiquadFilter();
                crackFilter1.type = 'highpass';
                crackFilter1.frequency.value = 780;
                crackFilter1.Q.value = 4.5;
                const crackFilter2 = audioContext.createBiquadFilter();
                crackFilter2.type = 'bandpass';
                crackFilter2.frequency.value = 2400 + Math.random() * 1600;
                crackFilter2.Q.value = 14;
                const crackGain = audioContext.createGain();
                crack.connect(crackFilter1);
                crackFilter1.connect(crackFilter2);
                crackFilter2.connect(crackGain);
                crackGain.connect(audioContext.destination);
                crackGain.gain.setValueAtTime(0.4, now);
                crackGain.gain.exponentialRampToValueAtTime(0.01, now + 0.18);
                crack.start(now);
                const thumpBuffer = audioContext.createBuffer(1, 4410, audioContext.sampleRate);
                const thumpData = thumpBuffer.getChannelData(0);
                for (let i = 0; i < 4410; i++) {
                    const envelope = Math.exp(-i / 850);
                    thumpData[i] = (Math.random() * 2 - 1) * envelope * 0.65;
                }
                const thump = audioContext.createBufferSource();
                thump.buffer = thumpBuffer;
                const thumpFilter = audioContext.createBiquadFilter();
                thumpFilter.type = 'lowpass';
                thumpFilter.frequency.value = 140;
                thumpFilter.Q.value = 7;
                const thumpGain = audioContext.createGain();
                thump.connect(thumpFilter);
                thumpFilter.connect(thumpGain);
                thumpGain.connect(audioContext.destination);
                thumpGain.gain.setValueAtTime(0.35, now);
                thumpGain.gain.exponentialRampToValueAtTime(0.01, now + 0.22);
                thump.start(now);
                try {
                    crack.stop(now + 0.18);
                    thump.stop(now + 0.22);
                } catch(e) {}
                if (navigator.vibrate) {
                    navigator.vibrate([130, 35, 90]);
                }
            }
        }

        // Prevent right-click
        document.addEventListener('contextmenu', e => e.preventDefault());
        // Prevent escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && document.getElementById('experience').style.display === 'block') {
                e.preventDefault();
            }
        });
    </script>
</body>
</html>
