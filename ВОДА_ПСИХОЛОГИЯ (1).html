<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>ВОДА</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Courier+Prime:wght@400;700&display=swap');
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            background: #000; 
            color: #fff; 
            font-family: 'Courier Prime', monospace; 
            overflow: hidden; 
            user-select: none;
            -webkit-user-select: none;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }
        /* HYPNOTIC WARNING SCREEN */
        #warning { 
            position: fixed; 
            top: 0; left: 0; 
            width: 100%; height: 100%; 
            background: #000; 
            display: flex; 
            flex-direction: column; 
            justify-content: center; 
            align-items: center; 
            z-index: 10000; 
            padding: 30px 20px;
            animation: warningDistortion 12s infinite;
            overflow-y: auto;
        }
        @keyframes warningDistortion {
            0%, 100% { background: #000; }
            33% { background: #050000; }
            66% { background: #000505; }
        }
        
        #warning::before {
            content: '';
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: repeating-linear-gradient(
                0deg,
                transparent,
                transparent 2px,
                rgba(30, 0, 0, 0.03) 2px,
                rgba(30, 0, 0, 0.03) 4px
            );
            pointer-events: none;
            animation: scanlines 8s linear infinite;
        }
        @keyframes scanlines {
            0% { transform: translateY(0); }
            100% { transform: translateY(20px); }
        }
        
        #warning-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            max-width: 900px;
            width: 100%;
            opacity: 0;
            animation: hypnoticFadeIn 3s forwards;
            padding: 30px 20px;
            position: relative;
            z-index: 1;
        }
        @keyframes hypnoticFadeIn {
            0% { opacity: 0; transform: scale(0.97) translateY(10px); }
            100% { opacity: 1; transform: scale(1) translateY(0); }
        }
        
        #warning h1 { 
            font-size: clamp(36px, 7vw, 72px);
            margin-bottom: 55px; 
            text-align: center; 
            color: #6a0000; 
            letter-spacing: clamp(5px, 1.5vw, 12px);
            animation: titleGlitch 8s infinite;
            text-shadow: 
                2px 2px 0 rgba(90, 0, 0, 0.3),
                -2px -2px 0 rgba(0, 90, 90, 0.1),
                0 0 40px rgba(106, 0, 0, 0.8);
            font-weight: 700;
            line-height: 1.1;
            position: relative;
        }
        @keyframes titleGlitch {
            0%, 90%, 100% { 
                opacity: 1; 
                transform: translate(0, 0);
                text-shadow: 
                    2px 2px 0 rgba(90, 0, 0, 0.3),
                    -2px -2px 0 rgba(0, 90, 90, 0.1),
                    0 0 40px rgba(106, 0, 0, 0.8);
            }
            91% {
                opacity: 0.8;
                transform: translate(-2px, 1px);
                text-shadow: 
                    3px 0 0 rgba(200, 0, 0, 0.6),
                    -3px 0 0 rgba(0, 200, 200, 0.6),
                    0 0 50px rgba(106, 0, 0, 1);
            }
            93% {
                opacity: 0.9;
                transform: translate(2px, -1px);
                text-shadow: 
                    -2px 0 0 rgba(200, 0, 0, 0.6),
                    2px 0 0 rgba(0, 200, 200, 0.6),
                    0 0 50px rgba(106, 0, 0, 1);
            }
            95% {
                opacity: 1;
                transform: translate(0, 0);
            }
        }
        
        .warning-block {
            margin-bottom: 45px;
            width: 100%;
            max-width: 750px;
        }
        
        #warning p { 
            font-size: clamp(15px, 2.3vw, 21px);
            text-align: center; 
            line-height: 2.1; 
            margin-bottom: 18px; 
            color: #5a5a5a; 
            opacity: 0;
            animation: lineAppearGlitch 1.5s forwards;
            animation-delay: var(--delay, 0s);
            max-width: 700px;
            padding: 0 15px;
            position: relative;
        }
        @keyframes lineAppearGlitch {
            0% { 
                opacity: 0; 
                transform: translateX(-5px);
                filter: blur(3px);
            }
            70% {
                opacity: 0.95;
            }
            100% { 
                opacity: 0.92; 
                transform: translateX(0);
                filter: blur(0);
            }
        }
        
        #warning .ominous {
            color: #4a0000;
            font-size: clamp(16px, 2.5vw, 22px);
            margin-bottom: 22px;
            letter-spacing: 1px;
            animation: ominousFlicker 5s infinite;
            text-shadow: 0 0 20px rgba(74, 0, 0, 0.6);
        }
        @keyframes ominousFlicker {
            0%, 94%, 100% { 
                opacity: 0.88;
            }
            95%, 97% {
                opacity: 0.5;
            }
            96%, 98% {
                opacity: 0.95;
            }
        }
        
        #warning .critical {
            color: #7a0000;
            font-size: clamp(19px, 3.5vw, 28px);
            font-weight: 700;
            margin-top: 15px;
            margin-bottom: 18px;
            letter-spacing: 4px;
            animation: criticalStatic 6s infinite;
            line-height: 1.6;
            text-shadow: 0 0 25px rgba(122, 0, 0, 0.9);
            position: relative;
        }
        @keyframes criticalStatic {
            0%, 85%, 100% { 
                opacity: 1;
                transform: translate(0, 0);
            }
            86%, 88%, 90%, 92% {
                opacity: 0.7;
                transform: translate(calc(var(--x, 0) * 1px), 0);
            }
            87%, 89%, 91%, 93% {
                opacity: 0.95;
                transform: translate(calc(var(--x, 0) * -1px), 0);
            }
        }
        
        #warning .epilepsy-warning {
            color: #8a0000;
            font-size: clamp(17px, 3vw, 24px);
            font-weight: 700;
            margin-bottom: 14px;
            opacity: 0;
            animation: epilepsyPulse 3s infinite;
            line-height: 1.6;
            text-shadow: 0 0 30px rgba(138, 0, 0, 0.9);
            letter-spacing: 2px;
        }
        @keyframes epilepsyPulse {
            0%, 100% { 
                opacity: 0.85;
                transform: scale(1);
            }
            50% { 
                opacity: 1;
                transform: scale(1.02);
            }
        }
        
        #warning .subtle-warning {
            font-size: clamp(12px, 1.9vw, 16px);
            color: #3a3a3a;
            margin-top: 35px;
            margin-bottom: 10px;
            opacity: 0.45;
            line-height: 1.9;
            max-width: 600px;
            animation: subtleBreath 7s infinite;
        }
        @keyframes subtleBreath {
            0%, 100% { opacity: 0.4; }
            50% { opacity: 0.6; }
        }
        
        #warning .disclaimer {
            font-size: clamp(10px, 1.6vw, 13px);
            color: #2a2a2a;
            margin-top: 20px;
            margin-bottom: 35px;
            opacity: 0.3;
            line-height: 1.7;
            max-width: 550px;
            font-style: italic;
        }
        
        #warning button { 
            font-family: 'Courier Prime', monospace; 
            font-size: clamp(17px, 3vw, 26px);
            padding: clamp(15px, 3.2vw, 24px) clamp(35px, 7.5vw, 80px);
            background: #0f0000; 
            color: #6a0000; 
            border: 2px solid #4a0000; 
            cursor: pointer; 
            margin-top: 45px;
            transition: all 0.3s ease; 
            letter-spacing: clamp(4px, 1.2vw, 6px);
            min-height: 60px;
            touch-action: manipulation;
            font-weight: 700;
            opacity: 0;
            animation: buttonMaterialize 2.5s forwards 3.5s;
            border-radius: 1px;
            position: relative;
            overflow: hidden;
            text-shadow: 0 0 15px rgba(106, 0, 0, 0.8);
            box-shadow: 
                0 0 20px rgba(106, 0, 0, 0.3),
                inset 0 0 20px rgba(106, 0, 0, 0.1);
        }
        @keyframes buttonMaterialize {
            0% {
                opacity: 0;
                transform: scale(0.95);
                filter: blur(5px);
            }
            70% {
                opacity: 0.9;
                transform: scale(1.01);
            }
            100% { 
                opacity: 0.88; 
                transform: scale(1);
                filter: blur(0);
            }
        }
        
        #warning button::before {
            content: '';
            position: absolute;
            top: 0; left: -100%;
            width: 100%; height: 100%;
            background: linear-gradient(90deg, transparent, rgba(106, 0, 0, 0.3), transparent);
            transition: left 0.5s;
        }
        
        #warning button:hover::before, #warning button:active::before {
            left: 100%;
        }
        
        #warning button:hover, #warning button:active { 
            background: #1a0000; 
            color: #8a0000; 
            border-color: #6a0000;
            box-shadow: 
                0 0 40px rgba(138, 0, 0, 0.7),
                inset 0 0 30px rgba(138, 0, 0, 0.2);
            opacity: 1;
            transform: scale(1.03);
            text-shadow: 0 0 20px rgba(138, 0, 0, 1);
        }
        
        #warning button:active {
            transform: scale(0.98);
        }
        
        /* GLITCH OVERLAY */
        #warning::after {
            content: '';
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: linear-gradient(
                rgba(20, 0, 0, 0) 50%,
                rgba(0, 20, 0, 0.05) 50%
            );
            background-size: 100% 4px;
            pointer-events: none;
            opacity: 0;
            animation: glitchOverlay 13s infinite;
            z-index: 2;
        }
        @keyframes glitchOverlay {
            0%, 96%, 100% { opacity: 0; }
            97%, 98% { opacity: 0.3; }
        }
        
        /* TEXT CORRUPTION EFFECT */
        .warning-block::before {
            content: attr(data-glitch);
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            opacity: 0;
            pointer-events: none;
            animation: textCorrupt 15s infinite;
        }
        @keyframes textCorrupt {
            0%, 94%, 100% { 
                opacity: 0; 
                transform: translate(0, 0);
            }
            95% {
                opacity: 0.5;
                transform: translate(-2px, 0);
                color: #f00;
            }
            96% {
                opacity: 0.4;
                transform: translate(2px, 0);
                color: #0ff;
            }
            97% {
                opacity: 0;
                transform: translate(0, 0);
            }
        }
        
        /* RANDOM STATIC FLASHES */
        @keyframes randomStatic {
            0%, 97%, 100% { opacity: 0; }
            98% { opacity: 0.15; }
            99% { opacity: 0.05; }
        }
        
        #warning-content::after {
            content: '';
            position: absolute;
            top: -50%; left: -50%;
            width: 200%; height: 200%;
            background: repeating-linear-gradient(
                45deg,
                transparent 0,
                transparent 2px,
                rgba(100, 0, 0, 0.1) 2px,
                rgba(100, 0, 0, 0.1) 4px
            );
            pointer-events: none;
            opacity: 0;
            animation: randomStatic 11s infinite;
        }
        
        /* FINAL HORROR - BLOOD WORD SMILE */
        #final-horror-container {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            display: none;
            z-index: 9999;
            background: #000;
        }
        
        .final-word {
            position: absolute;
            font-family: 'Courier Prime', monospace;
            font-size: clamp(12px, 2vw, 18px);
            color: #4a4a4a;
            opacity: 0;
            pointer-events: none;
            white-space: nowrap;
            font-weight: 400;
            transition: all 2s ease-out;
        }
        
        .final-word.bloodify {
            color: #8a0000;
            opacity: 0.9;
            font-weight: 700;
            text-shadow: 0 0 20px rgba(138, 0, 0, 0.9);
            animation: wordPulse 1.5s infinite;
        }
        
        @keyframes wordPulse {
            0%, 100% { 
                opacity: 0.85;
                transform: scale(1);
            }
            50% { 
                opacity: 1;
                transform: scale(1.05);
            }
        }
        
        .final-word.positioned {
            transition: all 3s cubic-bezier(0.68, -0.55, 0.27, 1.55);
        }
        
        /* CREEPY SMILE FACE */
        .smile-container {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            width: clamp(300px, 60vw, 600px);
            height: clamp(300px, 60vw, 600px);
            opacity: 0;
            pointer-events: none;
            mix-blend-mode: screen;
        }
        .smile-container::before {
            content: '';
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            width: 120%;
            height: 120%;
            background: radial-gradient(circle, rgba(180,0,0,0.2) 0%, rgba(0,0,0,0.9) 75%);
            filter: blur(80px);
            opacity: 0.8;
        }
        .smile-container::after {
            content: '';
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            width: 70%;
            height: 70%;
            border-radius: 50%;
            border: 2px solid rgba(180,0,0,0.4);
            filter: blur(12px);
            opacity: 0.6;
        }
        
        /* SUBLIMINAL FLASH */
        .subliminal-flash {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: #000;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            pointer-events: none;
            z-index: 10000;
        }
        
        .subliminal-flash.active {
            animation: subliminalFlash 0.1s;
        }
        
        @keyframes subliminalFlash {
            0%, 100% { opacity: 0; }
            50% { opacity: 1; }
        }
        
        .subliminal-image {
            font-size: clamp(40px, 15vw, 180px);
            color: #8a0000;
            font-weight: 700;
            text-shadow: 0 0 50px rgba(138, 0, 0, 1);
            opacity: 0.95;
        }
        
        /* FINAL DISTORTION */
        @keyframes finalDistortion {
            0% { 
                filter: blur(0) contrast(1);
            }
            25% {
                filter: blur(3px) contrast(2) saturate(3);
            }
            50% {
                filter: blur(0) contrast(1.5) saturate(2) hue-rotate(10deg);
            }
            75% {
                filter: blur(5px) contrast(3) saturate(0);
            }
            100% {
                filter: blur(0) contrast(1);
            }
        }
        
        /* EXPERIENCE CONTAINER */
        #experience { 
            display: none; 
            position: fixed; 
            top: 0; left: 0; 
            width: 100%; height: 100%; 
            background: #000; 
        }
        
        #content { 
            position: absolute; 
            top: 50%; 
            left: 50%; 
            transform: translate(-50%, -50%); 
            width: 90%; 
            max-width: 1000px; 
            text-align: center;
            padding: 0 15px;
        }
        
        /* HYPNOTIC TEXT STYLES */
        .line { 
            font-size: clamp(22px, 4.5vw, 38px);
            line-height: 2.2; 
            color: #4a4a4a; 
            opacity: 0; 
            margin: 0; 
            letter-spacing: clamp(1px, 0.6vw, 3px);
            position: relative;
            text-shadow: 0 0 15px rgba(0,0,0,0.8);
            transition: all 0.3s ease;
        }
        .line.active { 
            animation: hypnoticAppear 1.2s forwards; 
        }

        .line.spotlight {
            position: relative;
        }
        .line.spotlight::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 115%;
            height: 190%;
            background: radial-gradient(circle, rgba(255,255,255,0.05) 0%, rgba(120,0,0,0.25) 45%, rgba(0,0,0,0.95) 100%);
            opacity: 0;
            filter: blur(25px);
            transition: opacity 0.6s ease;
            z-index: -1;
        }
        .line.spotlight.active::before,
        .line.spotlight::before {
            opacity: 1;
        }
        .line.hemorrhage {
            position: relative;
            color: #8a0000;
            text-shadow:
                0 0 25px rgba(138,0,0,0.9),
                0 0 55px rgba(80,0,0,0.65);
            animation: hemorrhageDrip 3.6s ease-in-out infinite;
        }
        .line.hemorrhage::after {
            content: '';
            position: absolute;
            left: 50%;
            bottom: -18%;
            width: 60%;
            height: 2px;
            transform: translateX(-50%);
            background: linear-gradient(90deg, transparent, rgba(138,0,0,0.85), transparent);
            filter: blur(4px);
            animation: hemorrhagePulse 2.4s ease-in-out infinite;
        }
        @keyframes hemorrhageDrip {
            0%, 100% { letter-spacing: clamp(1px, 0.6vw, 4px); filter: drop-shadow(0 0 12px rgba(138,0,0,0.7)); }
            50% { letter-spacing: clamp(5px, 1.2vw, 12px); filter: drop-shadow(0 0 28px rgba(200,0,0,1)); }
        }
        @keyframes hemorrhagePulse {
            0%, 100% { opacity: 0.4; }
            50% { opacity: 0.9; }
        }
        .line.never {
            position: relative;
            animation: neverCollapse 8s ease-in forwards;
        }
        .line.never::after {
            content: attr(data-echo);
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: rgba(138, 0, 0, 0.25);
            font-size: 140%;
            letter-spacing: 1.2em;
            text-transform: uppercase;
            opacity: 0;
            filter: blur(14px);
            animation: neverEcho 7s ease-in-out infinite;
            pointer-events: none;
        }
        @keyframes neverCollapse {
            0% { filter: blur(0); letter-spacing: inherit; opacity: 1; }
            40% { filter: blur(1px); letter-spacing: 0.3em; opacity: 0.9; }
            60% { filter: blur(5px); letter-spacing: 0.8em; opacity: 0.6; }
            100% { filter: blur(9px); letter-spacing: 1.2em; opacity: 0.35; }
        }
        @keyframes neverEcho {
            0%, 100% { opacity: 0; filter: blur(14px); }
            50% { opacity: 0.65; filter: blur(4px); }
        }
            70% {
                opacity: 1;
                transform: scale(1.02);
                filter: blur(0);
            }
            100% { 
                opacity: 1; 
                transform: scale(1); 
                filter: blur(0);
            }
        }
        
        .line.blood { 
            color: #5a0000; 
            font-weight: 700; 
            text-shadow: 0 0 25px rgba(90, 0, 0, 0.7); 
            animation: bloodPulse 3s infinite;
        }
        @keyframes bloodPulse {
            0%, 100% { 
                opacity: 0.8;
                text-shadow: 0 0 20px rgba(90, 0, 0, 0.6);
            }
            50% { 
                opacity: 1;
                text-shadow: 0 0 35px rgba(90, 0, 0, 0.9);
            }
        }
        
        .line .cold { 
            color: #2a4a5a; 
            text-shadow: 0 0 12px rgba(42, 74, 90, 0.5); 
            letter-spacing: clamp(2px, 0.8vw, 5px);
        }
        .line .pain { 
            color: #5a0000;
            animation: painPulseHeart 1.2s infinite;
        }
        @keyframes painPulseHeart {
            0%, 100% {
                color: #5a0000;
                transform: scale(1);
                text-shadow: 0 0 8px rgba(90, 0, 0, 0.5);
            }
            50% {
                color: #8a0000;
                transform: scale(1.04);
                text-shadow: 0 0 22px rgba(138, 0, 0, 0.9);
            }
        }
        
        .line .death { 
            color: #3a3a3a;
            text-shadow: 0 0 12px rgba(0, 0, 0, 0.7);
            letter-spacing: clamp(4px, 1.2vw, 7px);
            opacity: 0.75;
            animation: deathStroopEffect 5s ease-in-out forwards;
        }
        @keyframes deathStroopEffect {
            0% { 
                color: #3a3a3a;
                text-shadow: 0 0 12px rgba(0, 0, 0, 0.7);
            }
            60% {
                color: #2a2a2a;
            }
            100% { 
                color: #4a0000;
                text-shadow: 0 0 18px rgba(74, 0, 0, 0.8);
                opacity: 0.9;
            }
        }
        
        .line .scream { 
            color: #6a0000;
            animation: screamVibrate 0.08s infinite, screamIntensity 0.4s ease-out;
            font-weight: 700;
        }
        @keyframes screamVibrate {
            0%, 100% { 
                transform: translate(0, 0) scale(1);
                letter-spacing: 0.05em;
            }
            20% { transform: translate(-1px, 1px) scale(1.02); }
            40% { transform: translate(1px, -1px) scale(0.99); }
            60% { transform: translate(-1px, -1px) scale(1.01); }
            80% { transform: translate(1px, 1px) scale(1); }
        }
        @keyframes screamIntensity {
            0% { 
                opacity: 0.5; 
                text-shadow: 0 0 5px rgba(106, 0, 0, 0.5); 
            }
            100% { 
                opacity: 1; 
                text-shadow: 0 0 35px rgba(138, 0, 0, 1);
                color: #8a0000;
            }
        }
        
        .line .void { 
            color: #2a2a2a;
            letter-spacing: clamp(5px, 1.4vw, 9px);
            animation: voidDissolve 4s ease-in-out infinite;
        }
        @keyframes voidDissolve {
            0%, 100% { 
                opacity: 0.65;
                letter-spacing: clamp(5px, 1.4vw, 9px);
                filter: blur(0);
                text-shadow: 0 0 15px rgba(0, 0, 0, 0.8);
            }
            50% { 
                opacity: 0.3;
                letter-spacing: clamp(8px, 2vw, 14px);
                filter: blur(1px);
                text-shadow: 0 0 25px rgba(0, 0, 0, 1);
            }
        }
        
        .line .machine-word { 
            color: #4a4a4a;
            letter-spacing: 2px;
            font-weight: 700;
            animation: mechanicalPulse 1.5s ease-in-out infinite;
            font-family: 'Courier Prime', monospace;
        }
        @keyframes mechanicalPulse {
            0%, 100% {
                letter-spacing: 2px;
                opacity: 0.8;
                text-shadow: 0 0 8px rgba(74, 74, 74, 0.5);
            }
            50% {
                letter-spacing: 1px;
                opacity: 0.95;
                text-shadow: 0 0 15px rgba(74, 74, 74, 0.7);
            }
        }
        
        .line .cold {
            color: #3a5a5a;
            animation: freezeEffect 6s ease-in forwards;
        }
        @keyframes freezeEffect {
            0% {
                color: #4a4a4a;
                filter: blur(0);
                letter-spacing: 0;
            }
            100% {
                color: #2a4a5a;
                letter-spacing: 0.35em;
                filter: blur(0.5px);
                opacity: 0.55;
            }
        }
        
        .line .filth { 
            color: #3a2a1a; 
            text-shadow: 0 0 12px rgba(58, 42, 26, 0.7); 
        }
        
        /* BREAKING FOURTH WALL - INTENSE */
        .line.break-wall {
            color: #ddd !important;
            font-size: clamp(26px, 5.5vw, 52px) !important;
            text-shadow: 0 0 40px rgba(221,221,221,0.4);
            animation: breakWallHypnotic 0.4s forwards, textHypnoticBreath 4s infinite;
            z-index: 1000;
            font-weight: 700;
            letter-spacing: clamp(2px, 1vw, 6px);
        }
        @keyframes breakWallHypnotic {
            0% { 
                opacity: 0; 
                transform: scale(0.85); 
                filter: blur(15px);
            }
            60% {
                opacity: 1;
                transform: scale(1.08);
                filter: blur(0);
            }
            100% { 
                opacity: 1; 
                transform: scale(1); 
                filter: blur(0);
            }
        }
        @keyframes textHypnoticBreath {
            0%, 100% { 
                transform: scale(1); 
                text-shadow: 0 0 30px rgba(221,221,221,0.3);
            }
            50% { 
                transform: scale(1.04); 
                text-shadow: 0 0 50px rgba(221,221,221,0.6);
            }
        }
        
        /* GLITCH - MORE INTENSE */
        .line.glitched {
            animation: textGlitchIntense 0.15s infinite;
        }
        @keyframes textGlitchIntense {
            0% { 
                transform: translate(0);
                text-shadow: -4px 0 #6a0000, 4px 0 #006a6a;
                filter: hue-rotate(0deg) contrast(1.2);
            }
            20% {
                transform: translate(-7px, 4px);
                text-shadow: -8px 0 #8a0000, 8px 0 #008a8a;
                filter: hue-rotate(90deg) contrast(1.4);
            }
            40% {
                transform: translate(7px, -4px);
                text-shadow: 8px 0 #8a0000, -8px 0 #008a8a;
                filter: hue-rotate(180deg) contrast(1.6);
            }
            60% {
                transform: translate(-4px, -3px);
                text-shadow: -6px 0 #8a0000, 6px 0 #008a8a;
                filter: hue-rotate(270deg) contrast(1.3);
            }
            80% {
                transform: translate(4px, 3px);
                text-shadow: 6px 0 #8a0000, -6px 0 #008a8a;
                filter: hue-rotate(360deg) contrast(1.5);
            }
            100% {
                transform: translate(0);
                text-shadow: -4px 0 #6a0000, 4px 0 #006a6a;
                filter: hue-rotate(0deg) contrast(1.2);
            }
        }
        
        /* DISTORTION - MORE ORGANIC */
        .line.distorted {
            animation: distortOrganic 0.5s;
        }
        @keyframes distortOrganic {
            0%, 100% { 
                transform: scale(1, 1) skew(0deg); 
                letter-spacing: clamp(1px, 0.6vw, 3px);
                opacity: 1;
            }
            20% { 
                transform: scale(1.15, 0.85) skew(-2deg); 
                letter-spacing: clamp(6px, 2vw, 10px);
                opacity: 0.8;
            }
            40% { 
                transform: scale(0.85, 1.15) skew(2deg); 
                letter-spacing: clamp(0px, 0.1vw, 0.5px);
                opacity: 0.9;
            }
            60% { 
                transform: scale(1.08, 0.92) skew(-1deg); 
                letter-spacing: clamp(3px, 1.2vw, 6px);
                opacity: 0.85;
            }
            80% { 
                transform: scale(0.92, 1.08) skew(1deg); 
                letter-spacing: clamp(2px, 0.8vw, 4px);
                opacity: 0.95;
            }
        }
        
        /* SHAKE - MORE VIOLENT */
        .shake { 
            animation: shakeViolent 0.5s; 
        }
        @keyframes shakeViolent { 
            0%, 100% { transform: translate(-50%, -50%); } 
            10% { transform: translate(calc(-50% - 30px), calc(-50% + 15px)) rotate(-2deg); } 
            20% { transform: translate(calc(-50% + 35px), calc(-50% - 12px)) rotate(2deg); } 
            30% { transform: translate(calc(-50% - 28px), calc(-50% + 18px)) rotate(-1deg); } 
            40% { transform: translate(calc(-50% + 32px), calc(-50% - 15px)) rotate(1.5deg); } 
            50% { transform: translate(calc(-50% - 25px), calc(-50% + 10px)) rotate(-1.5deg); } 
            60% { transform: translate(calc(-50% + 28px), calc(-50% - 8px)) rotate(1deg); } 
            70% { transform: translate(calc(-50% - 20px), calc(-50% + 12px)) rotate(-1deg); } 
            80% { transform: translate(calc(-50% + 22px), calc(-50% - 10px)) rotate(0.5deg); } 
            90% { transform: translate(calc(-50% - 15px), calc(-50% + 8px)) rotate(-0.5deg); } 
        }
        
        /* VISUAL EFFECTS - ENHANCED */
        .text-trail { animation: trailIntense 1.2s; }
        @keyframes trailIntense { 
            0% { 
                text-shadow: 12px 0 20px currentColor, 
                             24px 0 35px currentColor, 
                             36px 0 50px currentColor; 
                opacity: 1;
            } 
            100% { 
                text-shadow: 0 0 0 transparent; 
                opacity: 1;
            } 
        }
        
        .double-vision { animation: doubleVisionIntense 0.5s; }
        @keyframes doubleVisionIntense { 
            0%, 100% { text-shadow: 0 0 0 transparent; } 
            50% { 
                text-shadow: 15px 0 0 rgba(80,80,80,0.7), 
                             -15px 0 0 rgba(80,80,80,0.7); 
            } 
        }
        
        .time-freeze { animation: freezeIntense 2.5s; }
        @keyframes freezeIntense { 
            0%, 100% { opacity: 1; filter: blur(0) brightness(1) contrast(1); } 
            50% { opacity: 0.15; filter: blur(8px) brightness(0.3) contrast(1.5); } 
        }
        
        /* BLACKOUT - DEEPER */
        .blackout {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: #000;
            opacity: 0;
            pointer-events: none;
            z-index: 500;
        }
        .blackout.active {
            animation: blackoutDeep 0.2s forwards;
        }
        @keyframes blackoutDeep {
            to { opacity: 1; }
        }
        
        /* STROBE - MORE VIOLENT */
        .strobe {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: #fff;
            opacity: 0;
            pointer-events: none;
            z-index: 550;
        }
        .strobe.active {
            animation: strobeViolent 0.03s infinite;
        }
        @keyframes strobeViolent {
            0%, 100% { opacity: 0; }
            50% { opacity: 0.95; }
        }
        
        /* CHROMATIC - MORE INTENSE */
        .chromatic {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            z-index: 560;
            opacity: 0;
            mix-blend-mode: screen;
        }
        .chromatic.active {
            animation: chromaticIntense 0.2s infinite;
            opacity: 0.75;
        }
        @keyframes chromaticIntense {
            0% { 
                background: radial-gradient(circle, rgba(139,0,0,0.5) 0%, transparent 40%);
                transform: translate(-5px, 0);
            }
            50% { 
                background: radial-gradient(circle, rgba(0,139,139,0.5) 0%, transparent 40%);
                transform: translate(5px, 0);
            }
            100% { 
                background: radial-gradient(circle, rgba(139,0,0,0.5) 0%, transparent 40%);
                transform: translate(-5px, 0);
            }
        }
        
        /* WATER/BLOOD DROPS - ENHANCED */
        .water-drop {
            position: fixed;
            width: 3px;
            background: linear-gradient(to bottom, transparent, rgba(42, 74, 90, 0.8), transparent);
            pointer-events: none;
            z-index: 610;
            opacity: 0;
        }
        .water-drop.active {
            animation: dropFallSlow 3s linear forwards;
        }
        @keyframes dropFallSlow {
            0% { 
                opacity: 0;
                top: -10px;
            }
            15% {
                opacity: 0.9;
            }
            100% {
                opacity: 0.4;
                top: 100%;
            }
        }
        
        .blood-drop {
            position: fixed;
            width: 4px;
            background: linear-gradient(to bottom, transparent, rgba(90, 0, 0, 0.95), rgba(90, 0, 0, 0.5));
            pointer-events: none;
            z-index: 620;
            opacity: 0;
        }
        .blood-drop.active {
            animation: bloodDripSlow 4s ease-in forwards;
        }
        @keyframes bloodDripSlow {
            0% { 
                opacity: 0;
                top: -20px;
            }
            12% {
                opacity: 1;
            }
            100% {
                opacity: 0.7;
                top: 100%;
                filter: blur(1.5px);
            }
        }
        
        /* FOG BREATH */
        .breath-fog {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 400px;
            height: 400px;
            background: radial-gradient(circle, rgba(100,100,100,0.08) 0%, transparent 65%);
            border-radius: 50%;
            pointer-events: none;
            opacity: 0;
            z-index: 630;
            filter: blur(30px);
        }
        .breath-fog.active {
            animation: breathFogSlow 5s ease-in-out forwards;
        }
        @keyframes breathFogSlow {
            0% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.4);
            }
            35% {
                opacity: 0.5;
                transform: translate(-50%, -50%) scale(1);
            }
            100% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(1.8);
            }
        }
        
        /* SCREEN CRACK */
        .screen-crack {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            opacity: 0;
            z-index: 640;
            background: 
                linear-gradient(45deg, transparent 48%, rgba(90,90,90,0.25) 49%, rgba(90,90,90,0.25) 51%, transparent 52%),
                linear-gradient(-45deg, transparent 48%, rgba(80,80,80,0.2) 49%, rgba(80,80,80,0.2) 51%, transparent 52%),
                linear-gradient(23deg, transparent 48%, rgba(70,70,70,0.15) 49%, rgba(70,70,70,0.15) 51%, transparent 52%);
        }
        .screen-crack.active {
            animation: crackAppearSlow 0.4s forwards;
        }
        @keyframes crackAppearSlow {
            0% {
                opacity: 0;
                transform: scale(0.85);
            }
            60% {
                opacity: 1;
                transform: scale(1.1);
            }
            100% {
                opacity: 0.4;
                transform: scale(1);
            }
        }
        
        /* WET STAINS */
        .wet-stain {
            position: fixed;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(30,30,50,0.4) 0%, transparent 65%);
            pointer-events: none;
            opacity: 0;
            z-index: 650;
            filter: blur(8px);
        }
        .wet-stain.active {
            animation: stainSpreadSlow 4s ease-out forwards;
        }
        @keyframes stainSpreadSlow {
            0% {
                opacity: 0;
                transform: scale(0);
            }
            35% {
                opacity: 0.7;
            }
            100% {
                opacity: 0.4;
                transform: scale(1);
            }
        }
        
        /* OVERLAYS - OPPRESSIVE */
        .breath-overlay { 
            position: fixed; 
            top: 0; left: 0; 
            width: 100%; height: 100%; 
            background: radial-gradient(circle, transparent 10%, #000 100%); 
            pointer-events: none; 
            animation: breatheOppressive 7s infinite; 
            z-index: 100; 
            opacity: 0.3;
        }
        @keyframes breatheOppressive { 
            0%, 100% { 
                opacity: 0.2; 
                transform: scale(1); 
            } 
            50% { 
                opacity: 0.85; 
                transform: scale(1.05); 
            } 
        }
        .vignette {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            z-index: 50;
            --focus-x: 50%;
            --focus-y: 50%;
            --focus-inner: 46%;
            --focus-outer: 68%;
            --focus-opacity: 1;
            transition: opacity 2s ease;
            opacity: 1;
        }
        .vignette::after {
            content: '';
            position: absolute;
            inset: 0;
            background: radial-gradient(circle at var(--focus-x) var(--focus-y),
                rgba(0,0,0,0) var(--focus-inner),
                rgba(0,0,0,0.78) var(--focus-outer),
                rgba(0,0,0,0.98) 100%);
            opacity: var(--focus-opacity);
            transition: background 1.4s ease, opacity 1.6s ease, filter 1s ease;
        }
        .vignette.focused::after,
        .vignette.focus-ring::after {
            background: radial-gradient(circle at var(--focus-x) var(--focus-y),
                rgba(0,0,0,0) calc(var(--focus-inner) - 14%),
                rgba(0,0,0,0.88) calc(var(--focus-outer) - 10%),
                rgba(0,0,0,0.99) 100%);
        }
        .vignette.collapsing::after {
            background: radial-gradient(circle at var(--focus-x) var(--focus-y),
                rgba(0,0,0,0) calc(var(--focus-inner) - 18%),
                rgba(0,0,0,0.92) calc(var(--focus-outer) - 14%),
                rgba(0,0,0,1) 100%);
        }
        .vignette.focus-lock::after {
            background: radial-gradient(circle at var(--focus-x) var(--focus-y),
                rgba(0,0,0,0) 12%,
                rgba(0,0,0,0.9) 26%,
                rgba(0,0,0,1) 100%);
        }
        .vignette.pulse::after {
            animation: vignettePulse 1.4s ease;
        }
        @keyframes vignettePulse {
            0% { filter: brightness(1); }
            40% { filter: brightness(1.35); }
            100% { filter: brightness(1); }
        }
        
        .static { 
            position: fixed; 
            top: 0; left: 0; 
            width: 100%; height: 100%; 
            pointer-events: none; 
            opacity: 0.12; 
            z-index: 200; 
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 400 400' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)'/%3E%3C/svg%3E"); 
            animation: staticMoveErratic 0.15s steps(12) infinite; 
            transition: opacity 4s; 
        }
        @keyframes staticMoveErratic { 
            0% { transform: translate(0, 0); } 
            20% { transform: translate(-6%, 6%); } 
            40% { transform: translate(6%, -6%); } 
            60% { transform: translate(-5%, -5%); }
            80% { transform: translate(5%, 5%); } 
            100% { transform: translate(-3%, 3%); } 
        }
        
        .blood-screen { 
            position: fixed; 
            top: 0; left: 0; 
            width: 100%; height: 100%; 
            background: radial-gradient(circle at center, transparent 0%, rgba(90,0,0,0.6) 100%); 
            pointer-events: none; 
            opacity: 0; 
            z-index: 150; 
            transition: opacity 2.5s; 
        }
        .blood-screen.active { opacity: 1; }
        
        .red-flicker { 
            position: fixed; 
            top: 0; left: 0; 
            width: 100%; height: 100%; 
            background: rgba(90, 0, 0, 0.3); 
            pointer-events: none; 
            opacity: 0; 
            z-index: 80; 
        }
        .red-flicker.active { animation: redFlickerIntense 0.06s infinite; }
        @keyframes redFlickerIntense { 
            0%, 100% { opacity: 0; } 
            50% { opacity: 0.35; } 
        }
        
        /* PERIPHERAL HORROR */
        .peripheral-horror {
            position: fixed;
            width: 180px;
            height: 100%;
            pointer-events: none;
            opacity: 0;
            z-index: 130;
            background: radial-gradient(circle, rgba(15,0,0,0.98) 0%, transparent 75%);
        }
        .peripheral-horror.left { left: 0; top: 0; }
        .peripheral-horror.right { right: 0; top: 0; }
        .peripheral-horror.active {
            animation: peripheralFlashIntense 0.15s;
        }
        @keyframes peripheralFlashIntense {
            0%, 100% { opacity: 0; }
            50% { opacity: 0.95; }
        }
        
        /* SHADOWS */
        .shadow { 
            position: fixed; 
            width: 300px; 
            height: 100%; 
            background: radial-gradient(circle, rgba(0,0,0,0.99) 0%, transparent 65%); 
            pointer-events: none; 
            opacity: 0; 
            z-index: 120; 
        }
        .shadow.left { left: 0; top: 0; }
        .shadow.right { right: 0; top: 0; }
        .shadow.active { animation: shadowPassSlow 3s; }
        @keyframes shadowPassSlow { 
            0%, 100% { opacity: 0; } 
            50% { opacity: 0.98; } 
        }
        
        /* GRAIN */
        .grain { 
            position: fixed; 
            top: 0; left: 0; 
            width: 100%; height: 100%; 
            pointer-events: none; 
            opacity: 0; 
            z-index: 210; 
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='grainFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='3' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23grainFilter)' opacity='0.4'/%3E%3C/svg%3E"); 
            animation: grainMoveErratic 0.08s steps(10) infinite; 
            transition: opacity 4s; 
        }
        @keyframes grainMoveErratic { 
            0% { transform: translate(0, 0); } 
            25% { transform: translate(-4%, 4%); } 
            50% { transform: translate(4%, -4%); } 
            75% { transform: translate(-4%, -4%); } 
            100% { transform: translate(4%, 4%); } 
        }
        /* WATCHING YOU */
        .watching-overlay {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            opacity: 0;
            z-index: 600;
            background: radial-gradient(circle at var(--x, 50%) var(--y, 50%),
                transparent 0%,
                rgba(120,0,0,0.12) 18%,
                rgba(0,0,0,0.92) 52%);
            transition: opacity 0.6s ease;
            mix-blend-mode: multiply;
        }
        .watching-overlay.active {
            opacity: 1;
            animation: watchingPulseSlow 5s ease-in-out;
        }
        @keyframes watchingPulseSlow {
            0%, 100% {
                opacity: 1;
                background: radial-gradient(circle at var(--x, 50%) var(--y, 50%),
                    transparent 0%,
                    rgba(120,0,0,0.12) 18%,
                    rgba(0,0,0,0.92) 52%);
            }
            50% {
                opacity: 0.6;
                background: radial-gradient(circle at var(--x, 50%) var(--y, 50%),
                    rgba(120,0,0,0.25) 5%,
                    rgba(0,0,0,0.98) 65%);
            }
        }

        .gaze-focus {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            opacity: 0;
            z-index: 140;
            background: radial-gradient(circle at var(--gx, 50%) var(--gy, 50%),
                rgba(255,255,255,0.02) 0%,
                rgba(180,0,0,0.18) 12%,
                rgba(0,0,0,0.82) 48%,
                rgba(0,0,0,0.98) 100%);
            transition: opacity 0.6s ease, background-size 0.8s ease;
            background-size: 140% 140%;
            mix-blend-mode: screen;
        }
        .gaze-focus.active {
            opacity: 1;
            animation: gazePulse 5s ease-in-out;
        }
        @keyframes gazePulse {
            0% { background-size: 120% 120%; filter: saturate(1); }
            50% { background-size: 165% 165%; filter: saturate(1.5); }
            100% { background-size: 130% 130%; filter: saturate(1.1); }
        }

        /* SCREEN TEAR */
        .screen-tear {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            opacity: 0;
            z-index: 570;
        }
        .screen-tear.active {
            animation: tearIntense 0.6s;
        }
        @keyframes tearIntense {
            0% { 
                opacity: 0;
                transform: translateY(0);
            }
            12% {
                opacity: 1;
                transform: translateY(-25px);
                background: linear-gradient(transparent 46%, #ddd 46%, #ddd 54%, transparent 54%);
            }
            25% {
                transform: translateY(20px);
                background: linear-gradient(transparent 66%, #ddd 66%, #ddd 74%, transparent 74%);
            }
            38% {
                transform: translateY(-15px);
                background: linear-gradient(transparent 26%, #ddd 26%, #ddd 34%, transparent 34%);
            }
            100% {
                opacity: 0;
                transform: translateY(0);
            }
        }
        
        /* TIME DISTORTION */
        .time-distortion {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            opacity: 0;
            z-index: 580;
        }
        .time-distortion.active {
            animation: timeWarpIntense 4s;
        }
        @keyframes timeWarpIntense {
            0%, 100% { 
                opacity: 0;
                filter: blur(0);
            }
            25% {
                opacity: 0.4;
                filter: blur(15px);
            }
            50% { 
                opacity: 0.7;
                filter: blur(8px);
                background: radial-gradient(circle, transparent 30%, rgba(0,0,30,0.6) 100%);
            }
            75% {
                opacity: 0.4;
                filter: blur(20px);
            }
        }
        
        /* SUBLIMINAL */
        .subliminal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: clamp(36px, 9vw, 84px);
            color: rgba(80, 80, 80, 0.08);
            pointer-events: none;
            opacity: 0;
            z-index: 590;
            font-weight: 700;
            letter-spacing: clamp(3px, 1.5vw, 10px);
        }
        .subliminal.active {
            animation: subliminalFlashQuick 0.04s;
        }
        @keyframes subliminalFlashQuick {
            0%, 100% { opacity: 0; }
            50% { opacity: 0.2; }
        }
        
        /* HEARTBEAT */
        .heartbeat {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(90, 0, 0, 0.15);
            pointer-events: none;
            opacity: 0;
            z-index: 85;
        }
        .heartbeat.active {
            animation: heartbeatPulseSlow 1.4s infinite;
        }
        @keyframes heartbeatPulseSlow {
            0%, 100% { opacity: 0; transform: scale(1); }
            12% { opacity: 0.4; transform: scale(1.015); }
            24% { opacity: 0; transform: scale(1); }
            36% { opacity: 0.5; transform: scale(1.02); }
            48% { opacity: 0; transform: scale(1); }
        }
        
        /* REALITY GLITCH */
        .reality-glitch {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            opacity: 0;
            z-index: 595;
            mix-blend-mode: difference;
        }
        .reality-glitch.active {
            animation: realityBreakIntense 0.4s;
        }
        @keyframes realityBreakIntense {
            0%, 100% { 
                opacity: 0;
                background: transparent;
            }
            20% {
                opacity: 0.9;
                background: repeating-linear-gradient(0deg, #8a0000 0px, #8a0000 2px, #008a8a 2px, #008a8a 4px);
            }
            40% {
                opacity: 0.7;
                background: repeating-linear-gradient(90deg, #008a00 0px, #008a00 3px, #8a008a 3px, #8a008a 6px);
            }
            60% {
                opacity: 0.95;
                background: repeating-linear-gradient(45deg, #8a8a00 0px, #8a8a00 2px, #00008a 2px, #00008a 4px);
            }
        }
        /* OBSESSIVE WORD FIELD */
        #obsessive-words {
            position: fixed;
            inset: 0;
            pointer-events: none;
            overflow: hidden;
            z-index: 70;
            opacity: 0.22;
            transition: opacity 6s ease, filter 5s ease;
        }
        #obsessive-words.word-phase-0 {
            opacity: 0.22;
            filter: blur(7px) saturate(0.7);
        }
        #obsessive-words.word-phase-1 {
            opacity: 0.32;
            filter: blur(6px) saturate(0.85);
        }
        #obsessive-words.word-phase-2 {
            opacity: 0.48;
            filter: blur(4.8px) saturate(1.05);
        }
        #obsessive-words.word-phase-3 {
            opacity: 0.62;
            filter: blur(3.6px) saturate(1.2);
        }
        #obsessive-words.word-phase-4 {
            opacity: 0.78;
            filter: blur(2.6px) saturate(1.4);
        }
        #obsessive-words.word-flood {
            opacity: 0.92;
            filter: blur(1.6px) saturate(1.65) contrast(1.2);
        }
        #obsessive-words.word-flood::after {
            content: '';
            position: absolute;
            inset: 0;
            background: radial-gradient(circle, rgba(120,0,0,0.04) 0%, rgba(0,0,0,0.75) 120%);
            mix-blend-mode: screen;
            animation: wordVeilBreath 8s ease-in-out infinite;
        }
        @keyframes wordVeilBreath {
            0%, 100% { opacity: 0.35; }
            50% { opacity: 0.7; }
        }

        /* OBSESSIVE WORDS */
        .obsessive-word {
            position: fixed;
            font-family: 'Courier Prime', monospace;
            font-size: clamp(12px, 2.1vw, 22px);
            color: rgba(160, 160, 160, 0.85);
            pointer-events: none;
            opacity: 0;
            z-index: 70;
            letter-spacing: 2px;
            font-weight: 600;
            --targetOpacity: 0.18;
            --wordScale: 1;
            --wordDuration: 14s;
            --driftX: 0px;
            --driftY: 0px;
            filter: blur(8px);
            text-transform: uppercase;
            transition:
                opacity 6s ease,
                transform 7s cubic-bezier(0.33, 0, 0.2, 1),
                filter 5s ease,
                letter-spacing 6s ease;
            mix-blend-mode: screen;
        }
        .obsessive-word.active {
            opacity: var(--targetOpacity);
            filter: blur(3px);
            transform: translate3d(var(--driftX), var(--driftY), 0) scale(var(--wordScale));
            animation:
                wordPulse var(--wordDuration) ease-in-out infinite alternate,
                wordFlicker calc(var(--wordDuration) * 0.5) steps(6) infinite;
        }
        .obsessive-word.seed {
            font-size: clamp(28px, 6vw, 60px);
            letter-spacing: 18px;
            color: rgba(255, 255, 255, 0.18);
            filter: blur(14px);
            text-shadow:
                0 0 35px rgba(255, 255, 255, 0.2),
                0 0 120px rgba(180, 0, 0, 0.45);
            mix-blend-mode: screen;
            animation: seedExpand 18s ease-in-out infinite alternate;
        }
        .obsessive-word.seed.active {
            animation: seedExpand 18s ease-in-out infinite alternate;
            opacity: 0.24;
            transform: scale(1.05);
        }
        .obsessive-word.seed-awaken {
            color: rgba(220, 20, 20, 0.28);
            text-shadow:
                0 0 45px rgba(200, 0, 0, 0.5),
                0 0 120px rgba(120, 0, 0, 0.65);
            animation: seedExpand 14s ease-in-out infinite alternate-reverse;
            filter: blur(10px);
        }
        .obsessive-word.focused-word {
            color: rgba(220, 40, 40, 0.9);
            text-shadow:
                0 0 25px rgba(150, 0, 0, 0.9),
                0 0 55px rgba(255, 0, 0, 0.35);
            mix-blend-mode: lighten;
            letter-spacing: 4px;
        }
        .obsessive-word.sigil {
            color: rgba(200, 0, 0, 0.58);
            text-shadow:
                0 0 30px rgba(200, 0, 0, 0.6),
                0 0 80px rgba(80, 0, 0, 0.8);
            animation: sigilGlimmer 10s ease-in-out infinite;
        }
        .obsessive-word.whisper {
            color: rgba(90, 90, 90, 0.55);
            filter: blur(4px);
            --targetOpacity: 0.14;
        }
        .obsessive-word.rorschach {
            color: rgba(180, 0, 0, 0.7);
            letter-spacing: 8px;
            filter: blur(6px);
            --targetOpacity: 0.32;
            animation:
                wordPulse var(--wordDuration) ease-in-out infinite alternate,
                rorschachPulse calc(var(--wordDuration) * 1.3) ease-in-out infinite;
        }
        .obsessive-word.silhouette {
            text-shadow:
                0 0 40px rgba(140, 0, 0, 0.65),
                0 0 90px rgba(0, 0, 0, 0.7);
            mix-blend-mode: screen;
        }
        .obsessive-word.halo {
            color: rgba(255, 255, 255, 0.65);
            text-shadow:
                0 0 40px rgba(255, 255, 255, 0.7),
                0 0 90px rgba(150, 0, 0, 0.7);
            --targetOpacity: 0.4;
        }
        .obsessive-word.mirror {
            filter: blur(5px);
        }
        .obsessive-word.overrun {
            mix-blend-mode: lighten;
            filter: blur(2.4px);
            text-shadow:
                0 0 45px rgba(255, 40, 40, 0.35),
                0 0 90px rgba(120, 0, 0, 0.45);
        }
        .obsessive-word.never-spiral {
            color: rgba(210, 20, 20, 0.7);
            letter-spacing: 10px;
            animation:
                neverSpiralDrift 14s ease-in-out infinite alternate,
                wordFlicker 6s steps(8) infinite;
        }
        .obsessive-word.smile-foreshadow {
            color: rgba(255, 255, 255, 0.5);
            text-shadow:
                0 0 25px rgba(200, 200, 200, 0.45),
                0 0 55px rgba(150, 0, 0, 0.55);
            filter: blur(3px);
            animation: smilePhantom 9s ease-in-out forwards;
        }
        .obsessive-word.dissolve {
            animation: wordFadeAway 6s forwards;
        }
        @keyframes wordPulse {
            0% { letter-spacing: 2px; filter: blur(3px); }
            50% { letter-spacing: 10px; filter: blur(6px); }
            100% { letter-spacing: 4px; filter: blur(3px); }
        }
        @keyframes wordFlicker {
            0%, 100% { opacity: 1; }
            48% { opacity: 0.7; }
            50% { opacity: 0.35; text-shadow: 0 0 30px rgba(200, 0, 0, 0.5); }
            52% { opacity: 0.85; }
        }
        @keyframes seedExpand {
            0% { letter-spacing: 12px; filter: blur(18px); opacity: 0.12; transform: scale(0.9); }
            45% { letter-spacing: 22px; filter: blur(8px); opacity: 0.22; transform: scale(1.05); }
            100% { letter-spacing: 36px; filter: blur(4px); opacity: 0.28; transform: scale(1.2); }
        }
        @keyframes rorschachPulse {
            0% { filter: blur(6px); text-shadow: 0 0 40px rgba(120, 0, 0, 0.6); }
            50% { filter: blur(3px); text-shadow: 0 0 80px rgba(200, 0, 0, 0.85); }
            100% { filter: blur(6px); text-shadow: 0 0 45px rgba(90, 0, 0, 0.6); }
        }
        @keyframes wordFadeAway {
            0% { opacity: var(--targetOpacity); filter: blur(3px); }
            100% { opacity: 0; filter: blur(12px); }
        }
        @keyframes sigilGlimmer {
            0%, 100% { opacity: 0.45; filter: blur(3px); }
            40% { opacity: 0.85; filter: blur(1.2px); }
            60% { opacity: 0.65; filter: blur(2.4px); }
        }
        @keyframes neverSpiralDrift {
            0% { transform: translate3d(calc(var(--driftX) * -0.3), calc(var(--driftY) * -0.3), 0) scale(0.8); }
            50% { transform: translate3d(calc(var(--driftX) * 0.4), calc(var(--driftY) * 0.4), 0) scale(1.05); }
            100% { transform: translate3d(calc(var(--driftX) * 0.6), calc(var(--driftY) * 0.6), 0) scale(1.2); }
        }
        @keyframes smilePhantom {
            0% { opacity: 0; filter: blur(8px); }
            40% { opacity: 0.55; filter: blur(3px); }
            70% { opacity: 0.35; filter: blur(4px); }
            100% { opacity: 0; filter: blur(12px); }
        }
        /* PAREIDOLIA WORDS - формируют образы */
        .obsessive-word.pareidolia {
            filter: blur(3px);
            opacity: 0;
            animation: pareidoliaForm 8s ease-in-out forwards;
        }
        @keyframes pareidoliaForm {
            0% {
                opacity: 0;
                filter: blur(8px);
            }
            40% {
                opacity: 0.4;
                filter: blur(3px);
            }
            60% {
                opacity: 0.6;
                filter: blur(2px);
            }
            100% {
                opacity: 0.35;
                filter: blur(3px);
            }
        }
        
        /* PERIPHERAL SHADOW MOVEMENT - замена курсора */
        .peripheral-shadow {
            position: fixed;
            width: 250px;
            height: 400px;
            background: radial-gradient(ellipse, rgba(20, 0, 0, 0.4) 0%, transparent 60%);
            pointer-events: none;
            opacity: 0;
            z-index: 150;
            filter: blur(40px);
            transition: opacity 2s ease, transform 5s ease-in-out;
        }
        .peripheral-shadow.active {
            opacity: 0.85;
        }
        @keyframes shadowDrift {
            0%, 100% {
                transform: translate(0, 0);
                opacity: 0.5;
            }
            25% {
                transform: translate(15vw, -10vh);
                opacity: 0.7;
            }
            50% {
                transform: translate(-10vw, 12vh);
                opacity: 0.6;
            }
            75% {
                transform: translate(12vw, 8vh);
                opacity: 0.8;
            }
        }
        
        /* FORGOTTEN WORDS */
        .forgotten-word { 
            position: fixed; 
            font-family: 'Courier Prime', monospace; 
            font-size: clamp(11px, 2vw, 16px);
            color: #1a1a1a; 
            pointer-events: none; 
            opacity: 0; 
            z-index: 65; 
            letter-spacing: 1px; 
            filter: blur(8px); 
        }
        .forgotten-word.active { animation: forgottenFadeInSlow 4s forwards; }
        @keyframes forgottenFadeInSlow { 
            0% { 
                opacity: 0; 
                filter: blur(15px); 
                transform: scale(0.7); 
            } 
            100% { 
                opacity: 0.4; 
                filter: blur(8px); 
                transform: scale(1); 
            } 
        }
        
        /* EMERGENCY EXIT - SUBTLE */
        #emergency-exit {
            position: fixed;
            bottom: 10px;
            right: 10px;
            padding: clamp(8px, 1.5vw, 12px) clamp(12px, 2.5vw, 20px);
            background: rgba(30, 0, 0, 0.15);
            color: rgba(80, 80, 80, 0.25);
            border: 1px solid rgba(80, 80, 80, 0.15);
            font-family: 'Courier Prime', monospace;
            font-size: clamp(9px, 1.5vw, 11px);
            cursor: pointer;
            z-index: 11000;
            opacity: 0.2;
            transition: all 0.4s;
            min-height: 40px;
            touch-action: manipulation;
        }
        #emergency-exit:hover, #emergency-exit:active {
            opacity: 0.8;
            background: rgba(50, 0, 0, 0.3);
            border-color: rgba(100, 100, 100, 0.4);
        }
        
        /* MOBILE OPTIMIZATIONS */
        @media (max-height: 700px) {
            #warning {
                padding: 25px 15px;
            }
            #warning-content {
                justify-content: flex-start;
                padding-top: 40px;
                padding-bottom: 40px;
            }
            #warning h1 {
                margin-bottom: 40px;
                font-size: clamp(30px, 6.5vw, 56px);
            }
            .warning-block {
                margin-bottom: 35px;
            }
            #warning p {
                margin-bottom: 14px;
                line-height: 1.9;
            }
            #warning .critical {
                margin-top: 35px;
                margin-bottom: 14px;
            }
            #warning button {
                margin-top: 35px;
                padding: clamp(13px, 2.8vw, 20px) clamp(28px, 6.5vw, 60px);
            }
        }
        
        @media (max-width: 600px) {
            #warning {
                padding: 20px 12px;
            }
            #warning-content {
                padding: 20px 12px;
            }
            #warning h1 {
                margin-bottom: 35px;
                font-size: clamp(28px, 7vw, 52px);
            }
            .warning-block {
                margin-bottom: 30px;
            }
            #warning p {
                font-size: clamp(14px, 3.8vw, 19px);
                line-height: 2;
                margin-bottom: 14px;
            }
            #warning .ominous {
                font-size: clamp(15px, 4vw, 20px);
            }
            #warning .critical {
                font-size: clamp(17px, 4.8vw, 24px);
                margin-top: 30px;
            }
            #warning .epilepsy-warning {
                font-size: clamp(16px, 4.2vw, 22px);
                margin-bottom: 12px;
            }
            #warning .subtle-warning {
                font-size: clamp(13px, 3.2vw, 17px);
            }
            #warning .disclaimer {
                font-size: clamp(11px, 2.8vw, 14px);
                margin-top: 18px;
                margin-bottom: 30px;
            }
            #warning button {
                font-size: clamp(16px, 4.5vw, 23px);
                margin-top: 35px;
            }
            .line {
                line-height: 2;
            }
            #content {
                width: 95%;
            }
        }
        
        @media (max-height: 500px) {
            #warning {
                overflow-y: auto;
                justify-content: flex-start;
                padding: 15px 10px;
            }
            #warning-content {
                padding-top: 25px;
                padding-bottom: 25px;
            }
            #warning h1 {
                margin-bottom: 25px;
                font-size: clamp(26px, 6vw, 44px);
            }
            .warning-block {
                margin-bottom: 25px;
            }
            #warning p {
                margin-bottom: 10px;
                line-height: 1.8;
            }
            #warning .critical {
                margin-top: 25px;
                margin-bottom: 10px;
            }
            #warning .subtle-warning {
                margin-top: 20px;
                margin-bottom: 8px;
            }
            #warning .disclaimer {
                margin-top: 15px;
                margin-bottom: 20px;
            }
            #warning button {
                margin-top: 25px;
                margin-bottom: 25px;
                min-height: 50px;
            }
        }
        
        @media (max-width: 400px) {
            #warning h1 {
                font-size: clamp(24px, 8vw, 40px);
            }
            #warning p {
                font-size: clamp(13px, 4.2vw, 17px);
            }
            #warning button {
                font-size: clamp(15px, 5vw, 20px);
                padding: clamp(12px, 3.5vw, 18px) clamp(22px, 7vw, 50px);
            }
        }
    </style>
</head>
<body>
    
    <div id="warning">
        <div id="warning-content">
            <h1>ПРЕДУПРЕЖДЕНИЕ</h1>
            
            <div class="warning-block">
                <p class="ominous" style="--delay: 0.5s">Это не обычный текст.</p>
                <p style="--delay: 1s">Это опыт.</p>
                <p style="--delay: 1.5s">Опыт, который изменит ваше восприятие.</p>
                <p class="ominous" style="--delay: 2s">Вы не сможете забыть то, что увидите.</p>
            </div>
            
            <div class="warning-block">
                <p class="critical" style="--x: 2; margin-top: 45px;">⚠ КРИТИЧЕСКОЕ ПРЕДУПРЕЖДЕНИЕ ⚠</p>
                <p class="epilepsy-warning" style="--delay: 2.8s">ИНТЕНСИВНЫЕ СТРОБОСКОПИЧЕСКИЕ ЭФФЕКТЫ</p>
                <p class="epilepsy-warning" style="--delay: 3s">БЫСТРЫЕ ВИЗУАЛЬНЫЕ ИЗМЕНЕНИЯ</p>
                <p class="epilepsy-warning" style="--delay: 3.2s">НЕ РЕКОМЕНДУЕТСЯ ПРИ ЭПИЛЕПСИИ</p>
            </div>
            
            <div class="warning-block">
                <p class="subtle-warning" style="--delay: 3.7s">Рекомендуется использовать наушники</p>
                <p class="subtle-warning" style="--delay: 4s">Выключите свет для полного эффекта</p>
                <p class="subtle-warning" style="--delay: 4.3s">Убедитесь, что вас никто не потревожит</p>
            </div>
            
            <p class="critical" style="--x: -2; margin-top: 50px; margin-bottom: 25px;">Вы готовы?</p>
            
            <p class="disclaimer">Продолжая, вы принимаете на себя полную ответственность за происходящее. Создатель предупредил вас о природе этого опыта.</p>
            
            <button id="enter">ВОЙТИ</button>
        </div>
    </div>

    <div id="experience">
        <div class="blackout"></div>
        <div class="strobe"></div>
        <div class="chromatic"></div>
        <div class="watching-overlay"></div>
        <div class="gaze-focus"></div>
        <div class="breath-overlay"></div>
        <div class="vignette"></div>
        <div class="static"></div>
        <div class="blood-screen"></div>
        <div class="red-flicker"></div>
        <div class="grain"></div>
        <div class="heartbeat"></div>
        <div class="peripheral-horror left"></div>
        <div class="peripheral-horror right"></div>
        <div class="shadow left"></div>
        <div class="shadow right"></div>
        <div class="screen-tear"></div>
        <div class="time-distortion"></div>
        <div class="reality-glitch"></div>
        <div class="subliminal"></div>
        <div class="breath-fog"></div>
        <div class="screen-crack"></div>
        <div id="water-drops"></div>
        <div id="blood-drops"></div>
        <div id="wet-stains"></div>
        <div id="obsessive-words"></div>
        <div id="forgotten-words"></div>
        <div class="peripheral-shadow" id="shadow-left"></div>
        <div class="peripheral-shadow" id="shadow-right"></div>
        <div class="peripheral-shadow" id="shadow-top"></div>
        <div id="final-horror-container">
            <div class="smile-container"></div>
        </div>
        <div class="subliminal-flash">
            <div class="subliminal-image"></div>
        </div>
        <div id="content"></div>
        <button id="emergency-exit">ВЫХОД</button>
    </div>

    <script>
        // PERFECTED HYPNOTIC IMMERSION
        const story = [
            'Ты стоишь в дверях.|2000',
            'Перед тобой — <span class="void">лужа</span>.|2000|obsess:лужа|water',
            '<span class="death">Тёмная</span>.|1500',
            'Расползается.|2000|peripheral|wetstain',
            '|4500|blackout:4500|silence|sound:void_hum',
            'Ты всё ещё здесь?|2500|break|subliminal:ЗДЕСЬ',
            'Ты чувствуешь это?|2200|break|cursormove',
            'Твоя рука.|2000|break',
            'Она не твоя.|3000|break|reality',
            'Ты считаешь секунды.|2500',
            'Десять.|1000|sound:tick|heartbeat',
            'Девять.|1000|sound:tick|heartbeat',
            'Восемь.|1000|sound:tick|heartbeat',
            'Семь.|1000|sound:tick|heartbeat',
            'Шесть.|1000|sound:tick|heartbeat',
            'Пять.|1000|sound:tick|heartbeat',
            'Четыре.|1000|sound:tick|heartbeat',
            'Три.|1000|sound:tick|heartbeat',
            'Два.|1000|sound:tick|heartbeat',
            'Один.|3000|sound:tick|heartbeat',
            'Ты входишь.|2500|sound:step|trail|cursormove',
            'Он смотрит на тебя.|2000',
            'Не узнаёт.|2500',
            'В его глазах — <span class="void">страх</span>.|3500|shadow|peripheral',
            'Ты для него <span class="death">чужой</span>.|4000|distorted',
            '|3500|blackout:3500|silence',
            'Посмотри на свои руки.|3000|break|subliminal:РУКИ',
            'Прямо сейчас.|2500|break|peripheralshadow',
            'Они трясутся?|3500|break|watching',
            'Он отступает к стене.|2500',
            'Прикрывает себя руками.|2500',
            'Руки как <span class="death">ветки</span>.|2000',
            'Сухие. <span class="death">Ломкие</span>.|3000',
            'Ты идёшь к нему.|2500|sound:step|peripheralshadow',
            'Каждый шаг.|1500|sound:step',
            'Ближе.|1500|sound:step|peripheral',
            'Ближе.|1800|sound:step|peripheral',
            'Он <span class="scream">кричит</span>.|3000|double|chromatic|sound:scream',
            'Не словами.|2000',
            '<span class="void">Звуком</span>.|2000',
            '<span class="void">Животным</span>.|3000|shake|screentear',
            '|5000|blackout:5000|silence',
            'Сколько времени прошло?|2500|break|timedistort',
            'Минута?|1200|break',
            'Час?|1200|break',
            'День?|2000|break',
            'Ты уже не помнишь, когда вошёл.|3000|break|subliminal:ЗАБЫЛ',
            'Ты рвёшь с него майку.|2000',
            'Она легко рвётся.|2000|sound:tear',
            'Как <span class="void">бумага</span>.|1500',
            'Снимаешь штаны.|1500',
            'Трусы.|1500',
            'Он <span class="death">голый</span> перед тобой.|3000|freeze',
            'Ты смотришь.|2500|watching',
            '<span class="death">Рёбра. Раз. Два. Три. Четыре. Пять</span>.|3000',
            'Все пять. Можно пересчитать пальцем.|2500',
            'Позвоночник — <span class="death">бугры</span> под кожей.|2000',
            'Ноги — <span class="death">спички</span>.|2000',
            'Живот — <span class="void">яма</span>.|2500',
            'Это был твой <span class="death">отец</span>.|4000|shadow|heartbeat',
            'Ты помнишь его другим?|3000|break|obsess:помнишь',
            '|3500|blackout:3500|silence',
            'Нет.|2500|break',
            'Ты не помнишь.|3000|break|subliminal:ЗАБВЕНИЕ',
            'Ты тащишь его к душу.|2000|sound:step|cursormove',
            'За локоть.|1500',
            'Он лёгкий.|1500',
            'Невесомый почти.|2000',
            'Ставишь под воду.|2000',
            'Включаешь.|2000',
            '<span class="cold">Холодная</span>.|2000|sound:water|obsess:вода|water',
            'Он вскрикивает.|2000',
            'Рот открыт. <span class="void">Беззубый</span>.|2500',
            'Чёрная дыра вместо рта.|2500|peripheral',
            'Ты ждёшь.|3000|sound:waterambient',
            'Вода течёт по его телу.|2000|obsess:вода|water',
            '<span class="cold">Холодная</span>.|2000',
            'Он дрожит.|2500|sound:breathing',
            'Весь.|1500',
            'Ты стоишь. Смотришь.|3000|watching',
            'Тридцать секунд.|2500',
            'Может, минута.|3000',
            'Время <span class="void">размазалось</span>.|3000|timedistort',
            '|6000|blackout:6000|silence',
            'Твоя спина болит?|3000|break|subliminal:БОЛИТ',
            'От того, как ты сидишь?|2500|break',
            'Ты сутулишься.|2000|break',
            'Как он.|3000|break|distorted',
            'Он дрожит всем телом.|2500|heartbeat',
            'Ты включаешь горячую.|2000',
            'Теплеет.|1500',
            'Он затихает.|3000',
            'Ты берёшь мочалку.|2000',
            'Намыливаешь.|1500',
            'Начинаешь <span class="machine-word">тереть</span>.|2000|sound:scrub|sound:metallic',
            'Спина.|1200',
            'Круговыми движениями.|1500',
            '<span class="machine-word">Сильно</span>.|1500',
            'Его кожа краснеет.|2000|redFlicker',
            'Ты трёшь <span class="machine-word">сильнее</span>.|2000|shake|sound:scrub',
            'Хочешь <span class="void">стереть</span>.|1500',
            'До <span class="death">костей</span>.|3000',
            '<span class="machine-word">Ты трёшь. Трёшь. Трёшь</span>.|2500|obsess:трёшь|sound:scrub',
            '<span class="machine-word">Монотонно</span>.|2000',
            '<span class="machine-word">Скрип. Скрип. Скрип</span>.|3000|obsess:скрип',
            'Как ногти по доске.|2500|reality',
            'Ты моешь его пах.|2000',
            '<span class="machine-word">Каждый день</span> моешь.|2000|obsess:каждый день',
            '<span class="death">Увядшую плоть</span>.|2500',
            'Потому что он обоссался. <span class="machine-word">Снова</span>.|3000|obsess:снова',
            'Задница.|2000',
            'Ты раздвигаешь.|1500',
            'Он дёргается.|1500',
            'Ты держишь крепче.|2000',
            '<span class="machine-word">Моешь</span>.|1500',
            '<span class="filth">Дерьмо. Размазанное. Вонючее</span>.|3000|obsess:грязь',
            'Запах.|2000',
            'Ты чувствуешь его сейчас?|3000|break|subliminal:ЗАПАХ|breathfog',
            'Нет.|2000|break',
            'Но он в твоей голове.|3000|break|peripheral',
            'Вода <span class="filth">коричневая</span> стекает в слив.|3000|water',
            'С твоего <span class="death">отца</span>.|2500|shadow',
            'Ты продолжаешь.|2000',
            '<span class="machine-word">Моешь. Моешь. Моешь</span>.|2500|obsess:моешь|sound:scrub',
            'Не можешь <span class="void">остановиться</span>.|3000|shake|cursormove',
            'Твои руки <span class="machine-word">трут. Трут. Трут</span>.|2500|heartbeat',
            'Автоматически.|2000',
            '<span class="void">Машина из мяса</span>.|3000|distorted',
            '|4000|blackout:4000|silence',
            'Это напоминает тебе что-то?|2500|break',
            'Твою жизнь.|2000|break|watching',
            'Каждый.|1000|break',
            'Гребаный.|1000|break',
            'День.|3000|break|reality|crack',
            'Его кожа <span class="pain">красная</span>.|2000|redFlicker',
            'Почти <span class="pain">кровь</span>.|3000|blood|obsess:кровь|blooddrop',
            '— <span class="pain">Больно</span>.|4000|double',
            'Шёпот. Еле слышный.|2500',
            'Ты слышал?|2500|break|subliminal:БОЛЬНО',
            '<span class="pain">Больно</span>.|3500',
            'Ты смотришь на руки.|2500',
            'Мочалка в <span class="pain">крови</span>.|2500|blood|obsess:кровь|blooddrop',
            'На спине — <span class="pain">кровь. Полосы</span>.|3000|blood|chromatic|blooddrop',
            'Ты <span class="pain">содрал кожу</span>.|2500|blood|blooddrop|sound:metallic',
            '|2500|strobe:1500',
            'Со своего <span class="death">отца</span>.|4500|shake|redFlicker|screentear|blooddrop',
            'Вода смывает <span class="pain">кровь</span>. Розовая.|3000|sound:water|water|blooddrop',
            'Как у новорождённого.|2500',
            'Ты одеваешь его.|2000',
            'Как сломанную <span class="void">куклу</span>.|2500',
            'Голова висит.|2000',
            'Руки не слушаются.|2000',
            'Ведёшь в комнату.|2000|sound:step|cursormove',
            'Сажаешь на диван.|3000',
            'Он смотрит в <span class="void">пустоту</span>.|3000|obsess:пустота',
            'Ты уходишь на кухню.|2000',
            '<span class="machine-word">Моешь руки. Долго</span>.|2500|sound:water|obsess:моешь|water',
            'Его <span class="filth">грязь</span> въелась.|2000|obsess:грязь',
            'В твою кожу. В твою <span class="pain">кровь</span>.|3000|shake',
            'Ты трёшь <span class="machine-word">сильнее</span>.|2000|heartbeat|sound:scrub',
            'Твоя кожа <span class="pain">слезает</span>.|3000|blood|blooddrop',
            'Розовая. Сырая.|2500|redFlicker',
            '|5000|blackout:5000|silence|sound:pressure',
            'Чем ты отличаешься от него?|3000|break|timedistort',
            'Ты.|1500|break',
            'Смотрящий в экран.|2500|break|watching',
            'Наблюдатель.|2000|break',
            'Соучастник.|3000|break|reality',
            'Твоя мышь.|2000|break|cursormove',
            'Движется сама.|3000|break|subliminal:НЕТ КОНТРОЛЯ',
            'Ты смотришь в окно.|2500',
            'Там люди живут.|2000',
            'Они не знают.|2000',
            'Какой <span class="void">ад</span> здесь.|3500|shadow|peripheral',
            '<span class="machine-word">Три года. Каждый день</span>.|3000|obsess:каждый день',
            'Тысяча девяносто пять дней.|3000|timedistort',
            '<span class="void">Лужа</span>. Вода. <span class="filth">Грязь</span>. <span class="pain">Кровь</span>.|3500|obsess:лужа|water|blooddrop',
            'Ты <span class="void">сходишь с ума</span>.|2500|shake|double|redFlicker',
            '<span class="machine-word">Медленно</span>.|2000',
            'Но верно.|2000',
            'Он теряет <span class="void">память</span>.|2000',
            'Ты теряешь <span class="void">себя</span>.|4000|freeze|obsess:теряю',
            'Иногда ночью.|2500|shadow',
            'Ты стоишь над ним.|2000|watching',
            'Думаешь. <span class="death">Подушка</span>.|2500',
            'Просто прижать.|2000',
            'И всё <span class="death">кончится</span>.|3500|freeze',
            'Ты держишь <span class="death">подушку</span>.|2500|heartbeat',
            'Подносишь к его лицу.|2500|peripheral|breathfog',
            'Руки <span class="void">трясутся</span>.|2500|shake',
            'Твои руки.|2000|break|subliminal:ТВОИ РУКИ',
            'Прямо сейчас.|2000|break|cursormove',
            '<span class="scream">Сейчас</span>.|2500',
            '<span class="scream">Сейчас</span>.|2500|redFlicker',
            '<span class="scream">СЕЙЧАС</span>.|4000|shake|redFlicker|screentear',
            '|3000|strobe:1200',
            'Но не делаешь.|2500|freeze',
            'Почему?|2500|break',
            'Страх?|1500|break',
            'Любовь?|1500|break',
            'Или ты уже мёртв внутри?|4500|break|reality',
            'Отходишь.|4000|timedistort',
            'Утром <span class="machine-word">снова</span> — <span class="void">лужа</span>.|2500|sound:machine|obsess:снова|water|wetstain',
            'Он не узнаёт.|2000',
            'Ты входишь.|2500|sound:step|cursormove',
            'И всё <span class="machine-word">сначала</span>.|3500|trail|obsess:сначала',
            'Внутри что-то <span class="pain">ломается</span>.|3000|shake|blood|chromatic|crack',
            'Хруст.|2000|reality|sound:crack',
            'Ты теряешь <span class="void">человечность</span>.|4000|distorted',
            'Ты — <span class="machine-word">машина</span>.|2500|sound:machine',
            'Которая <span class="machine-word">моет. Одевает. Кормит</span>.|3500|obsess:моешь',
            'Ты смотришь в зеркало.|2500|double|watching',
            'Не узнаёшь <span class="void">себя</span>.|2000|sound:distant_voices',
            'Глаза <span class="void">пустые</span>. Как у него.|3500|freeze|obsess:пустота',
            'Кто смотрит оттуда?|3000|break|peripheral',
            'Это ты?|2500|break|subliminal:КТО ТЫ',
            '|7000|blackout:7000|silence',
            'Когда ты в последний раз.|2500|break',
            'Чувствовал что-то?|3000|break|watching',
            'Вспомни.|2500|break',
            'Вспомни сейчас.|3000|break|cursormove',
            'Вы похожи.|2500|timedistort',
            '<span class="death">Отец и сын</span>.|2000',
            'Оба <span class="void">разрушаетесь</span>.|4000|shadow|heartbeat',
            'Параллельно.|2500',
            'Ты берёшь его руку.|2500',
            '<span class="cold">Холодная</span>. <span class="death">Мёртвая</span> почти.|3500',
            'Стиральная <span class="machine-word">машина</span> гудит.|2500|sound:machine',
            'Вода шумит.|2000|sound:water|water',
            '<span class="machine-word">Каждый день</span>.|3500|trail|obsess:каждый день',
            'Ты держишь <span class="death">мёртвую</span> руку.|2500',
            '<span class="death">Живого трупа</span>.|2500|distorted',
            'Который был твоим <span class="death">отцом</span>.|4000',
            'Который учил тебя не плакать.|3500',
            'Ты не плачешь.|2500',
            'Не можешь.|2500',
            'Внутри — <span class="void">пустота</span>.|3000|freeze|obsess:пустота',
            'Как в его <span class="void">глазах</span>.|4000|shake',
            'Вы ждёте <span class="death">смерти</span>.|3500|blood|redFlicker|peripheral|blooddrop',
            'Чьей. Не важно.|2500',
            'Лишь бы <span class="death">кончилось</span>.|4000|double',
            'Но не кончается.|3000|obsess:не кончается',
            'Никогда.|2500|timedistort',
            'Он дышит. Ты дышишь.|3500|sound:breathing|heartbeat',
            '<span class="machine-word">Завтра то же</span>.|2500|obsess:завтра',
            '<span class="void">Лужа</span>. Вода. <span class="pain">Кровь</span>.|3000|blood|water|blooddrop',
            '<span class="machine-word">И дальше. И дальше</span>.|3000|shake|obsess:и дальше',
            'В <span class="void">аду</span>.|2500',
            'Который называется.|2500|freeze|watching',
            '<span class="scream">Любовь. Долг. Семья</span>.|5000|shake|blood|redFlicker|chromatic|crack',
            'Вода течёт.|2500|sound:water|obsess:вода|water',
            '<span class="machine-word">Машина</span> гудит.|2500|sound:machine',
            'И ты ждёшь <span class="death">конца</span>.|3500',
            'Который не приходит.|4000|shadow|obsess:не приходит',
            'Никогда.|3000|reality',
            '|8000|blackout:8000|silence',
            'Ты понял?|3000|break|subliminal:ПОНЯЛ',
            'Это не его история.|3000|break|watching',
            'Это твоя.|2500|break|cursormove',
            'Просто.|2000|break',
            'Ты.|2000|break',
            'Ещё.|2000|break',
            'Не.|2000|break',
            'Знаешь.|3000|break|timedistort',
            'Об этом.|4000|break|reality|peripheral',
            '<span class="void">Никогда</span>.|7000|shake|blood|redFlicker|freeze|chromatic|obsess:никогда|blooddrop|crack',
            '|2000|silence',
            '|12000|finalhorror',
            '|15000|blackout:15000|silence'
        ];

        let audioContext, ambientLayers = [], progressionLevel = 0;
        let obsessiveWords = [], forgottenWords = [];
        let realMouseX = window.innerWidth / 2, realMouseY = window.innerHeight / 2;
        let isWatching = false;
        let currentLineElement = null;
        let wordStormInterval = null, wordPatternInterval = null;
        let obsessionPhase = 0;
        let obsessionEscalationInterval = null;
        let wordFloodInterval = null;
        let wordFloodActive = false;
        let smileForeshadowed = false;
        let vignettePulseTimeout = null;
        let subliminalMessages = ['ЗАБУДЬ', 'БЕЗЫСХОДНОСТЬ', 'ПОВТОР', 'РАСПАД', 'ПУСТОТА', 'БОЛЬ', 'ЦИКЛ', 'НЕТ ВЫХОДА', 'ПОВИНУЙСЯ', 'СТРАХ', 'ТОНЕШЬ', 'ТЕРЯЕШЬСЯ'];
        let waterDrops = [], bloodDrops = [], wetStains = [];
        let lastActivityTime = Date.now();
        let isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        
        const FORGOTTEN = [
            'отец', 'помню', 'забыл', 'кто я', 'где я', 'раньше', 'было', 'имя', 'лицо', 'голос', 
            'давно', 'тогда', 'помнишь', 'стёрлось', 'исчезло', 'потерял', 'не помню', 'узнаю', 
            'был', 'когда', 'там', 'здесь', 'дома', 'мама', 'детство', 'счастье', 'смех', 'свет',
            'любовь', 'надежда', 'будущее', 'прошлое', 'человек', 'живой', 'помощь', 'конец', 'начало',
            'выход', 'спасение', 'жизнь', 'смерть', 'боль', 'страх', 'время', 'дни', 'годы'
        ];
        const RORSCHACH_POOL = [
            'ГЛАЗА', 'ТЫ', 'ОН', 'СТРАХ', 'ВОДА', 'КРОВЬ', 'СМОТРИТ', 'ЖДИ', 'НИКОГДА', 'МОЛЧИ',
            'ГНИЁТ', 'ПУСТО', 'БОЛЬ', 'ТЕМНО', 'ХОЛОД', 'ДОЛГ', 'СМОТРИ', 'СЛЫШИШЬ', 'БЕЗ ВЫХОДА',
            'ДЫШИ', 'УТОНИ', 'ШЕПОТ', 'ПАМЯТЬ', 'РАСПАД', 'ПРОПАДИ', 'СТЕРЕТЬ', 'ГЛУБОКО'
        ];


        // REAL mouse tracking
        document.addEventListener('mousemove', (e) => {
            realMouseX = e.clientX;
            realMouseY = e.clientY;
            lastActivityTime = Date.now();

            if (!isWatching) {
                const watching = document.querySelector('.watching-overlay');
                const gaze = document.querySelector('.gaze-focus');
                watching.style.setProperty('--x', (realMouseX / window.innerWidth * 100) + '%');
                watching.style.setProperty('--y', (realMouseY / window.innerHeight * 100) + '%');
                gaze.style.setProperty('--gx', (realMouseX / window.innerWidth * 100) + '%');
                gaze.style.setProperty('--gy', (realMouseY / window.innerHeight * 100) + '%');
            }
        });

        document.addEventListener('touchstart', () => {
            lastActivityTime = Date.now();
        });

        document.addEventListener('touchmove', (e) => {
            lastActivityTime = Date.now();
            if (e.touches && e.touches[0]) {
                realMouseX = e.touches[0].clientX;
                realMouseY = e.touches[0].clientY;
                if (!isWatching) {
                    const watching = document.querySelector('.watching-overlay');
                    const gaze = document.querySelector('.gaze-focus');
                    watching.style.setProperty('--x', (realMouseX / window.innerWidth * 100) + '%');
                    watching.style.setProperty('--y', (realMouseY / window.innerHeight * 100) + '%');
                    gaze.style.setProperty('--gx', (realMouseX / window.innerWidth * 100) + '%');
                    gaze.style.setProperty('--gy', (realMouseY / window.innerHeight * 100) + '%');
                }
            }
        });

        function bindControlButtons() {
            const warning = document.getElementById('warning');
            const experience = document.getElementById('experience');
            const enterButton = document.getElementById('enter');
            const emergencyExit = document.getElementById('emergency-exit');

            if (emergencyExit) {
                emergencyExit.addEventListener('click', () => {
                    if (confirm('Прервать опыт?')) {
                        location.reload();
                    }
                });
            }

            if (enterButton && warning && experience) {
                enterButton.addEventListener('click', async () => {
                    // IMMEDIATE START - NO DELAY
                    warning.style.display = 'none';
                    experience.style.display = 'block';

                    // Fullscreen attempt (silent fail on mobile)
                    try {
                        const elem = document.documentElement;
                        if (elem.requestFullscreen) {
                            await elem.requestFullscreen();
                        } else if (elem.webkitRequestFullscreen) {
                            elem.webkitRequestFullscreen();
                        } else if (elem.msRequestFullscreen) {
                            elem.msRequestFullscreen();
                        }
                    } catch (err) {}

                    // Audio initialization
                    try {
                        audioContext = new (window.AudioContext || window.webkitAudioContext)();
                        if (audioContext.state === 'suspended') {
                            await audioContext.resume();
                        }
                        const buffer = audioContext.createBuffer(1, 1, 22050);
                        const source = audioContext.createBufferSource();
                        source.buffer = buffer;
                        source.connect(audioContext.destination);
                        source.start(0);
                        initAtmosphere();
                    } catch (err) {}

                    // START IMMEDIATELY
                    setTimeout(startExperience, 1500);
                    setInterval(triggerRandomSubliminal, 12000);
                });
            }
        }

        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', bindControlButtons);
        } else {
            bindControlButtons();
        }

        function createWaterDrop() {
            const drop = document.createElement('div');
            drop.className = 'water-drop';
            drop.style.left = Math.random() * 100 + '%';
            drop.style.height = (40 + Math.random() * 60) + 'px';
            document.getElementById('water-drops').appendChild(drop);
            drop.classList.add('active');
            setTimeout(() => drop.remove(), 3000);
        }

        function createBloodDrop() {
            const drop = document.createElement('div');
            drop.className = 'blood-drop';
            drop.style.left = Math.random() * 100 + '%';
            drop.style.height = (50 + Math.random() * 90) + 'px';
            document.getElementById('blood-drops').appendChild(drop);
            drop.classList.add('active');
            setTimeout(() => drop.remove(), 4000);
            if (navigator.vibrate && Math.random() < 0.3) {
                navigator.vibrate(120);
            }
        }

        function createWetStain() {
            const stain = document.createElement('div');
            stain.className = 'wet-stain';
            const size = 120 + Math.random() * 250;
            stain.style.width = size + 'px';
            stain.style.height = size + 'px';
            stain.style.left = Math.random() * 100 + '%';
            stain.style.top = Math.random() * 100 + '%';
            document.getElementById('wet-stains').appendChild(stain);
            stain.classList.add('active');
        }

        function triggerBreathFog() {
            const fog = document.querySelector('.breath-fog');
            fog.classList.add('active');
            setTimeout(() => fog.classList.remove('active'), 5000);
        }

        function triggerScreenCrack() {
            const crack = document.querySelector('.screen-crack');
            crack.classList.add('active');
            if (navigator.vibrate) {
                navigator.vibrate([350, 120, 350]);
            }
        }

        // ПЕРИФЕРИЙНЫЕ ТЕНИ - замена курсору
        function triggerPeripheralShadows() {
            if (isMobile) return;
            const shadows = ['shadow-left', 'shadow-right', 'shadow-top'];
            const shadowId = shadows[Math.floor(Math.random() * shadows.length)];
            const shadow = document.getElementById(shadowId);
            if (!shadow) return;

            let left = 0;
            let top = 0;
            if (shadowId === 'shadow-left') {
                left = -160 + Math.random() * 90;
                top = Math.random() * (window.innerHeight - 220);
            } else if (shadowId === 'shadow-right') {
                left = window.innerWidth - 120 + Math.random() * 90;
                top = Math.random() * (window.innerHeight - 220);
            } else {
                left = Math.random() * (window.innerWidth - 220);
                top = -160 + Math.random() * 120;
            }

            shadow.style.left = left + 'px';
            shadow.style.top = top + 'px';
            const scale = 1 + progressionLevel * 0.6 + Math.random() * 0.3;
            const rotate = (Math.random() - 0.5) * 14;
            const driftX = (Math.random() - 0.5) * 120;
            const driftY = (Math.random() - 0.5) * 90;
            shadow.style.transition = 'transform 5.5s ease-in-out, opacity 2s ease';
            shadow.style.transform = `translate(${driftX}px, ${driftY}px) scale(${scale}) rotate(${rotate}deg)`;
            shadow.style.opacity = 0.25 + progressionLevel * 0.5;
            shadow.classList.add('active');
            if (Math.random() < 0.6) {
                spawnAmbientWordFromPool();
            }
            setTimeout(() => {
                shadow.classList.remove('active');
                shadow.style.transform = '';
                shadow.style.opacity = '';
            }, 8000);

            if (navigator.vibrate && Math.random() < 0.3) {
                navigator.vibrate([50, 100, 50]);
            }
        }

        // ПАРЕЙДОЛИЯ - создание образов из слов
        function createPareidoliaPattern(type = 'eyes') {
            const container = document.getElementById('obsessive-words');
            const words = ['СМОТРИТ', 'ВИДИШЬ', 'ГЛАЗА', 'ПУСТОТА', 'ТЬМА', 'ЗДЕСЬ', 'ОН', 'ТЫ'];

            if (type === 'eyes') {
                // Создаем два "глаза" из слов
                const leftEyeX = window.innerWidth * 0.35;
                const rightEyeX = window.innerWidth * 0.65;
                const eyeY = window.innerHeight * 0.4;
                
                for (let i = 0; i < 30; i++) {
                    const word = words[Math.floor(Math.random() * words.length)];
                    const wordEl = document.createElement('div');
                    wordEl.className = 'obsessive-word pareidolia';
                    wordEl.textContent = word;
                    
                    // Распределяем слова вокруг двух центров (глаз)
                    const isLeftEye = Math.random() < 0.5;
                    const centerX = isLeftEye ? leftEyeX : rightEyeX;
                    const angle = Math.random() * Math.PI * 2;
                    const radius = Math.random() * 80 + 20;
                    
                    wordEl.style.left = (centerX + Math.cos(angle) * radius) + 'px';
                    wordEl.style.top = (eyeY + Math.sin(angle) * radius) + 'px';
                    wordEl.style.fontSize = (10 + Math.random() * 8) + 'px';
                    
                    container.appendChild(wordEl);
                    
                    setTimeout(() => {
                        wordEl.remove();
                    }, 12000);
                }
            } else if (type === 'figure') {
                // Создаем сгорбленный силуэт
                const centerX = window.innerWidth * 0.5;
                const topY = window.innerHeight * 0.3;
                
                // Голова
                for (let i = 0; i < 15; i++) {
                    const wordEl = document.createElement('div');
                    wordEl.className = 'obsessive-word pareidolia';
                    wordEl.textContent = words[Math.floor(Math.random() * words.length)];
                    const angle = Math.random() * Math.PI * 2;
                    const radius = Math.random() * 40 + 10;
                    wordEl.style.left = (centerX + Math.cos(angle) * radius) + 'px';
                    wordEl.style.top = (topY + Math.sin(angle) * radius) + 'px';
                    wordEl.style.fontSize = (8 + Math.random() * 6) + 'px';
                    container.appendChild(wordEl);
                    setTimeout(() => wordEl.remove(), 12000);
                }
                
                // Сгорбленная спина
                for (let i = 0; i < 20; i++) {
                    const wordEl = document.createElement('div');
                    wordEl.className = 'obsessive-word pareidolia';
                    wordEl.textContent = words[Math.floor(Math.random() * words.length)];
                    const t = i / 20;
                    const x = centerX - 30 + t * 60;
                    const y = topY + 50 + Math.pow(t, 2) * 150;
                    wordEl.style.left = x + 'px';
                    wordEl.style.top = y + 'px';
                    wordEl.style.fontSize = (8 + Math.random() * 6) + 'px';
                    container.appendChild(wordEl);
                    setTimeout(() => wordEl.remove(), 12000);
                }
            }
        }

        function setVignetteBase(inner, outer) {
            const vignette = document.querySelector('.vignette');
            if (!vignette) return;
            const safeInner = clamp(inner, 10, 52);
            const safeOuter = clamp(outer, safeInner + 6, 90);
            vignette.dataset.baseInner = safeInner;
            vignette.dataset.baseOuter = safeOuter;
            if (!vignette.classList.contains('focus-lock')) {
                vignette.style.setProperty('--focus-inner', safeInner + '%');
                vignette.style.setProperty('--focus-outer', safeOuter + '%');
            }
        }

        function alignVignetteToElement(element, intensity = 0.3, options = {}) {
            const vignette = document.querySelector('.vignette');
            if (!vignette || !element) return;
            const rect = element.getBoundingClientRect();
            const centerX = ((rect.left + rect.width / 2) / window.innerWidth) * 100;
            const centerY = ((rect.top + rect.height / 2) / window.innerHeight) * 100;
            vignette.style.setProperty('--focus-x', centerX.toFixed(2) + '%');
            vignette.style.setProperty('--focus-y', centerY.toFixed(2) + '%');
            if (vignette.classList.contains('focus-lock') && !options.overrideLock) {
                return;
            }
            const baseInner = parseFloat(vignette.dataset.baseInner ?? '46');
            const baseOuter = parseFloat(vignette.dataset.baseOuter ?? '68');
            const targetInner = clamp(baseInner - intensity * 16, 8, baseInner);
            const targetOuter = clamp(baseOuter - intensity * 18, targetInner + 8, baseOuter);
            vignette.style.setProperty('--focus-inner', targetInner + '%');
            vignette.style.setProperty('--focus-outer', targetOuter + '%');
            vignette.classList.add('pulse');
            if (vignettePulseTimeout) {
                clearTimeout(vignettePulseTimeout);
            }
            vignettePulseTimeout = setTimeout(() => {
                vignette.classList.remove('pulse');
                if (!vignette.classList.contains('focus-lock')) {
                    const restoreInner = parseFloat(vignette.dataset.baseInner ?? targetInner);
                    const restoreOuter = parseFloat(vignette.dataset.baseOuter ?? targetOuter);
                    vignette.style.setProperty('--focus-inner', restoreInner + '%');
                    vignette.style.setProperty('--focus-outer', restoreOuter + '%');
                }
                vignettePulseTimeout = null;
            }, 1400);
        }

        function computeFocusIntensity(effects = [], text = '') {
            let intensity = 0.18 + progressionLevel * 0.45;
            const lower = text.toLowerCase();
            if (effects.includes('blood') || /кров/.test(lower)) intensity += 0.3;
            if (effects.includes('shake') || effects.includes('screentear') || effects.includes('watching')) intensity += 0.2;
            if (effects.includes('peripheral') || effects.includes('shadow')) intensity += 0.1;
            if (/страх/.test(lower) || /глаз/.test(lower)) intensity += 0.15;
            if (/никогда/.test(lower)) intensity = Math.max(intensity, 0.9);
            return clamp(intensity, 0.15, 1);
        }

        function pulseWordsAroundLine(element, intensity = 0.5) {
            if (!element) return;
            const rect = element.getBoundingClientRect();
            const baseX = ((rect.left + rect.width / 2) / window.innerWidth) * 100;
            const baseY = ((rect.top + rect.height / 2) / window.innerHeight) * 100;
            const count = Math.floor(5 + intensity * 18);
            for (let i = 0; i < count; i++) {
                const angle = Math.random() * Math.PI * 2;
                const radius = (6 + Math.random() * 18) * (1 + intensity * 0.8);
                const left = clamp(baseX + Math.cos(angle) * radius, 2, 98);
                const top = clamp(baseY + Math.sin(angle) * radius, 4, 96);
                const word = RORSCHACH_POOL[Math.floor(Math.random() * RORSCHACH_POOL.length)];
                const classes = ['sigil'];
                if (Math.random() < 0.4) classes.push('mirror');
                createObsessiveWordElement(word, left, top, classes, { opacity: 0.22 + intensity * 0.4, scale: 0.9 + intensity * 0.9, unlockDelay: 6000 + Math.random() * 3000 });
            }
        }

        function igniteObsessionField() {
            const container = document.getElementById('obsessive-words');
            if (!container) return;
            if (!container.classList.contains('word-phase-0')) {
                container.classList.add('word-phase-0');
            }
            if (!container.dataset.seeded) {
                const seed = createObsessiveWordElement('Смотри', 50, 48, ['seed'], { opacity: 0.22, scale: 1.05, duration: 28, driftX: 0, driftY: 0, unlockDelay: 10000, preserveCase: true });
                if (seed) {
                    setTimeout(() => seed.classList.add('seed-awaken'), 9000);
                }
                container.dataset.seeded = 'true';
            }
            applyObsessionPhase(0);
            if (!obsessionEscalationInterval) {
                obsessionEscalationInterval = setInterval(() => {
                    if (obsessionPhase < 4) {
                        applyObsessionPhase(obsessionPhase + 1);
                    } else {
                        densifyAmbientWords(true);
                        reorganizeObsessiveWords(true);
                    }
                }, 14000);
            }
        }

        function applyObsessionPhase(targetPhase = obsessionPhase) {
            const container = document.getElementById('obsessive-words');
            if (!container) return;
            const nextPhase = clamp(targetPhase, 0, 4);
            if (nextPhase <= obsessionPhase && container.classList.contains(`word-phase-${obsessionPhase}`)) {
                return;
            }
            obsessionPhase = Math.max(obsessionPhase, nextPhase);
            for (let i = 0; i <= 4; i++) {
                container.classList.remove(`word-phase-${i}`);
            }
            container.classList.add(`word-phase-${obsessionPhase}`);
            container.dataset.phase = obsessionPhase;
            if (obsessionPhase >= 1) {
                densifyAmbientWords(true);
            }
            if (obsessionPhase >= 2) {
                spawnRorschachCluster();
            }
            if (obsessionPhase >= 3) {
                setTimeout(() => createPareidoliaPattern(Math.random() < 0.6 ? 'eyes' : 'figure'), 600);
            }
            if (obsessionPhase >= 4) {
                triggerWordFlood();
            }
        }

        function syncObsessionPhase() {
            const target = Math.min(4, Math.floor(progressionLevel * 5));
            if (target > obsessionPhase) {
                applyObsessionPhase(target);
            }
        }

        function triggerWordFlood() {
            const container = document.getElementById('obsessive-words');
            if (!container || wordFloodActive) return;
            wordFloodActive = true;
            container.classList.add('word-flood');
            obsessiveWords.forEach(word => {
                if (!word) return;
                word.classList.add('overrun');
                const currentOpacity = parseFloat(word.style.getPropertyValue('--targetOpacity')) || 0.25;
                const currentScale = parseFloat(word.style.getPropertyValue('--wordScale')) || 1;
                word.style.setProperty('--targetOpacity', Math.min(0.9, currentOpacity + 0.3).toFixed(2));
                word.style.setProperty('--wordScale', Math.min(2.4, currentScale + 0.4).toFixed(2));
            });
            let bursts = 0;
            wordFloodInterval = setInterval(() => {
                for (let i = 0; i < 14; i++) {
                    spawnAmbientWordFromPool();
                }
                if (Math.random() < 0.7) {
                    spawnRorschachCluster();
                }
                if (bursts % 2 === 0) {
                    createPareidoliaPattern(Math.random() < 0.6 ? 'eyes' : 'figure');
                }
                bursts++;
                if (bursts > 18) {
                    clearInterval(wordFloodInterval);
                    wordFloodInterval = null;
                }
            }, 900);
        }

        function manifestSmilePreview() {
            const container = document.getElementById('obsessive-words');
            if (!container) return;
            const centerX = 50;
            const centerY = 52 + (Math.random() - 0.5) * 6;
            const mouthRadius = 14 + progressionLevel * 10;
            for (let angle = 0; angle <= Math.PI; angle += 0.08) {
                const left = clamp(centerX + Math.cos(angle) * mouthRadius, 4, 96);
                const top = clamp(centerY + Math.sin(angle) * mouthRadius * 0.5, 6, 94);
                createObsessiveWordElement('УЛЫБКА', left, top, ['smile-foreshadow'], { opacity: 0.22 + progressionLevel * 0.3, scale: 0.8 + Math.random() * 0.4, unlockDelay: 7000 });
                createObsessiveWordElement('УЛЫБКА', 100 - left, top + (Math.random() - 0.5) * 2, ['smile-foreshadow', 'mirror'], { opacity: 0.18 + progressionLevel * 0.25, scale: 0.75 + Math.random() * 0.35, unlockDelay: 7000 });
            }
            const eyeOffsetX = 12 + progressionLevel * 6;
            const eyeOffsetY = 12;
            for (let side = -1; side <= 1; side += 2) {
                for (let i = 0; i < 10; i++) {
                    const angle = (Math.PI * 2 / 10) * i;
                    const left = clamp(centerX + side * eyeOffsetX + Math.cos(angle) * 4, 4, 96);
                    const top = clamp(centerY - eyeOffsetY + Math.sin(angle) * 4, 6, 94);
                    createObsessiveWordElement(side === -1 ? 'ОН' : 'ТЫ', left, top, ['smile-foreshadow'], { opacity: 0.26 + progressionLevel * 0.2, scale: 0.7 + Math.random() * 0.2, unlockDelay: 6500 });
                }
            }
        }

        function triggerNeverSpiral(element) {
            if (!element) return;
            const rect = element.getBoundingClientRect();
            const centerX = ((rect.left + rect.width / 2) / window.innerWidth) * 100;
            const centerY = ((rect.top + rect.height / 2) / window.innerHeight) * 100;
            const arms = 4 + Math.floor(progressionLevel * 4);
            const steps = 10 + Math.floor(progressionLevel * 14);
            for (let arm = 0; arm < arms; arm++) {
                for (let step = 0; step < steps; step++) {
                    const angle = (step / steps) * Math.PI * 2 + arm * (Math.PI / 2);
                    const radius = (step + 1) * (0.9 + progressionLevel * 1.4);
                    const left = clamp(centerX + Math.cos(angle) * radius, 2, 98);
                    const top = clamp(centerY + Math.sin(angle) * radius, 4, 96);
                    createObsessiveWordElement('НИКОГДА', left, top, ['never-spiral'], { opacity: 0.2 + progressionLevel * 0.4, scale: 0.85 + step / steps, unlockDelay: 10000 + step * 120, duration: 18 + Math.random() * 6 });
                }
            }
        }

        // ДЫХАНИЕ И ТРЕМОР ТЕКСТА
        function applyBreathingToText(lineElement) {
            setTimeout(() => {
                lineElement.classList.add('breathing');
            }, 200);
        }

        function applyTremorToText(lineElement) {
            setTimeout(() => {
                lineElement.classList.add('tremor');
            }, 100);
        }
            };
            animate();
            if (navigator.vibrate) {
                navigator.vibrate([60, 120, 60, 120, 60]);
            }
        }

        function triggerRandomSubliminal() {
            if (progressionLevel < 0.4) return;
            const msg = subliminalMessages[Math.floor(Math.random() * subliminalMessages.length)];
            const subliminal = document.querySelector('.subliminal');
            subliminal.textContent = msg;
            subliminal.classList.add('active');
            setTimeout(() => subliminal.classList.remove('active'), 40);
        }

        function initAtmosphere() {
            if (!audioContext) return;
            try {
                // DEEPEST INFRASOUND - максимальное физическое давление
                ambientLayers.push(createDrone(12, 0.06, 'lowpass', 40, 28));
                ambientLayers.push(createDrone(13.5, 0.06, 'lowpass', 40, 28));
                ambientLayers.push(createDrone(15, 0.05, 'lowpass', 60, 22));
                ambientLayers.push(createDrone(17, 0.05, 'lowpass', 70, 22));
                ambientLayers.push(createDrone(19, 0.045, 'lowpass', 85, 20));
                
                // Binaural horror - МАКСИМАЛЬНАЯ ИНТЕНСИВНОСТЬ
                ambientLayers.push(createDrone(38, 0.04, 'lowpass', 110, 12));
                ambientLayers.push(createDrone(38.9, 0.04, 'lowpass', 110, 12));
                
                // MAXIMUM Dissonance
                ambientLayers.push(createDrone(90, 0, 'bandpass', 200, 12));
                ambientLayers.push(createDrone(97, 0, 'bandpass', 200, 12));
                ambientLayers.push(createDrone(105, 0, 'bandpass', 230, 10));
                ambientLayers.push(createDrone(112, 0, 'bandpass', 230, 10));
                
                // Tritone - максимальный дискомфорт
                ambientLayers.push(createDrone(210, 0, 'bandpass', 380, 8));
                ambientLayers.push(createDrone(297, 0, 'bandpass', 380, 8));
                
                // METALLIC HELL
                ambientLayers.push(createDrone(650, 0, 'bandpass', 680, 18));
                ambientLayers.push(createDrone(975, 0, 'bandpass', 980, 15));
                
                // High frequency discomfort
                ambientLayers.push(createDrone(440, 0, 'bandpass', 480, 6));
                ambientLayers.push(createDrone(443, 0, 'bandpass', 480, 6));
                
                // CONTINUOUS PRESSURE
                const pressureOsc = audioContext.createOscillator();
                const pressureGain = audioContext.createGain();
                const pressureFilter = audioContext.createBiquadFilter();
                pressureOsc.type = 'sine';
                pressureOsc.frequency.value = 16;
                pressureFilter.type = 'lowpass';
                pressureFilter.frequency.value = 32;
                pressureFilter.Q.value = 20;
                pressureOsc.connect(pressureFilter);
                pressureFilter.connect(pressureGain);
                pressureGain.connect(audioContext.destination);
                pressureGain.gain.setValueAtTime(0, audioContext.currentTime);
                pressureGain.gain.linearRampToValueAtTime(0.1, audioContext.currentTime + 30);
                pressureOsc.start();
                ambientLayers.push({ osc: pressureOsc, gain: pressureGain, filter: pressureFilter });
                
                createShepardTone();
                createRandomScreams();
                createSubsonicPulse();
                createMetallicAmbient();
                createDistantEchoes();
                
                setInterval(() => {
                    ambientLayers.forEach(layer => {
                        if (layer && layer.gain) {
                            const time = audioContext.currentTime;
                            const currentGain = layer.gain.gain.value;
                            const variation = 0.04 * (1 + progressionLevel * 6);
                            layer.gain.gain.cancelScheduledValues(time);
                            layer.gain.gain.setValueAtTime(currentGain, time);
                            layer.gain.gain.linearRampToValueAtTime(
                                currentGain + variation * (Math.random() - 0.5), 
                                time + 1 + Math.random() * 2.5
                            );
                        }
                    });
                }, 1000);
            } catch (err) {}
        }

        function createDrone(freq, initialGain, filterType, filterFreq, Q) {
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            const filter = audioContext.createBiquadFilter();
            osc.type = 'sine';
            osc.frequency.value = freq;
            filter.type = filterType;
            filter.frequency.value = filterFreq;
            filter.Q.value = Q;
            osc.connect(filter);
            filter.connect(gain);
            gain.connect(audioContext.destination);
            gain.gain.setValueAtTime(0, audioContext.currentTime);
            if (initialGain > 0) {
                gain.gain.linearRampToValueAtTime(initialGain, audioContext.currentTime + 20);
            }
            osc.start();
            return { osc, gain, filter, baseFreq: freq, baseGain: initialGain };
        }

        function createShepardTone() {
            const shepardLayers = [];
            for (let i = 0; i < 6; i++) {
                const freq = 50 * Math.pow(2, i);
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                osc.type = 'sine';
                osc.frequency.value = freq;
                osc.connect(gain);
                gain.connect(audioContext.destination);
                const envelope = Math.exp(-Math.pow((i - 3), 2) / 4);
                gain.gain.setValueAtTime(0, audioContext.currentTime);
                osc.start();
                shepardLayers.push({ osc, gain, envelope });
            }
            setInterval(() => {
                shepardLayers.forEach(layer => {
                    const time = audioContext.currentTime;
                    const targetGain = layer.envelope * 0.03 * (1 + progressionLevel * 3.5);
                    layer.gain.gain.linearRampToValueAtTime(targetGain, time + 1);
                    const currentFreq = layer.osc.frequency.value;
                    const newFreq = currentFreq / 1.015;
                    layer.osc.frequency.linearRampToValueAtTime(newFreq, time + 0.5);
                    if (newFreq < 50 * 0.9) {
                        layer.osc.frequency.setValueAtTime(newFreq * 2, time + 0.5);
                    }
                });
            }, 400);
            ambientLayers.push(...shepardLayers);
        }

        function createRandomScreams() {
            setInterval(() => {
                if (progressionLevel < 0.4 || Math.random() > (0.18 + progressionLevel * 0.3)) return;
                const now = audioContext.currentTime;
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                const filter = audioContext.createBiquadFilter();
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(900 + Math.random() * 900, now);
                osc.frequency.exponentialRampToValueAtTime(280 + Math.random() * 300, now + 0.5);
                filter.type = 'bandpass';
                filter.frequency.value = 1200 + Math.random() * 1500;
                filter.Q.value = 18;
                osc.connect(filter);
                filter.connect(gain);
                gain.connect(audioContext.destination);
                const maxGain = 0.1 * Math.pow(progressionLevel, 0.7);
                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(maxGain, now + 0.06);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.5);
                osc.start(now);
                try { osc.stop(now + 0.5); } catch(e) {}
                if (navigator.vibrate && Math.random() < 0.5) {
                    navigator.vibrate([120, 60, 120]);
                }
            }, 4500);
        }

        function createSubsonicPulse() {
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            const filter = audioContext.createBiquadFilter();
            osc.type = 'sine';
            osc.frequency.value = 11;
            filter.type = 'lowpass';
            filter.frequency.value = 45;
            osc.connect(filter);
            filter.connect(gain);
            gain.connect(audioContext.destination);
            gain.gain.setValueAtTime(0, audioContext.currentTime);
            osc.start();
            ambientLayers.push({ osc, gain, filter });
            setInterval(() => {
                if (progressionLevel > 0.6) {
                    const time = audioContext.currentTime;
                    gain.gain.linearRampToValueAtTime(0.06 * progressionLevel, time + 0.1);
                    gain.gain.linearRampToValueAtTime(0, time + 0.35);
                }
            }, 2500);
        }

        function createMetallicAmbient() {
            setInterval(() => {
                if (progressionLevel < 0.3 || Math.random() > 0.3) return;
                const now = audioContext.currentTime;
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                const filter = audioContext.createBiquadFilter();
                osc.type = 'triangle';
                const baseFreq = 750 + Math.random() * 2200;
                osc.frequency.value = baseFreq;
                filter.type = 'bandpass';
                filter.frequency.value = baseFreq;
                filter.Q.value = 28;
                osc.connect(filter);
                filter.connect(gain);
                gain.connect(audioContext.destination);
                const maxGain = 0.06 * progressionLevel;
                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(maxGain, now + 2.5);
                gain.gain.linearRampToValueAtTime(0, now + 9);
                filter.frequency.linearRampToValueAtTime(baseFreq * 0.65, now + 9);
                osc.start(now);
                try { osc.stop(now + 9); } catch(e) {}
            }, 10000);
        }

        function createDistantEchoes() {
            setInterval(() => {
                if (progressionLevel < 0.45 || Math.random() > 0.22) return;
                const now = audioContext.currentTime;
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                const filter = audioContext.createBiquadFilter();
                const delay = audioContext.createDelay();
                const delayGain = audioContext.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(180 + Math.random() * 420, now);
                osc.frequency.exponentialRampToValueAtTime(90 + Math.random() * 220, now + 4.5);
                filter.type = 'bandpass';
                filter.frequency.value = 320;
                filter.Q.value = 18;
                delay.delayTime.value = 0.9;
                delayGain.gain.value = 0.65;
                osc.connect(filter);
                filter.connect(gain);
                filter.connect(delay);
                delay.connect(delayGain);
                delayGain.connect(gain);
                gain.connect(audioContext.destination);
                const maxGain = 0.05 * Math.pow(progressionLevel, 1.3);
                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(maxGain, now + 1.2);
                gain.gain.linearRampToValueAtTime(0, now + 5.5);
                osc.start(now);
                try { osc.stop(now + 5.5); } catch(e) {}
            }, 13000);
        }

        function updateAtmosphere(progress) {
            if (!audioContext) return;
            try {
                const time = audioContext.currentTime;
                // DEEPEST INFRASOUND - нарастает агрессивно
                for (let i = 0; i < 5; i++) {
                    if (ambientLayers[i]) {
                        const infraGain = (0.06 - i * 0.01) + progress * 0.18;
                        ambientLayers[i].gain.gain.linearRampToValueAtTime(infraGain, time + 2);
                    }
                }
                // Binaural - МАКСИМУМ
                if (ambientLayers[5] && ambientLayers[6]) {
                    const bassGain = 0.04 + progress * 0.18;
                    ambientLayers[5].gain.gain.linearRampToValueAtTime(bassGain, time + 2);
                    ambientLayers[6].gain.gain.linearRampToValueAtTime(bassGain, time + 2);
                    const newFreq = 38 - progress * 20;
                    ambientLayers[5].osc.frequency.linearRampToValueAtTime(newFreq, time + 2);
                    ambientLayers[6].osc.frequency.linearRampToValueAtTime(newFreq + 0.9, time + 2);
                }
                // Dissonance layers
                for (let i = 7; i < 11; i++) {
                    if (ambientLayers[i] && progress > 0.15) {
                        const disGain = Math.pow((progress - 0.15) / 0.85, 1.3) * 0.2;
                        ambientLayers[i].gain.gain.linearRampToValueAtTime(disGain, time + 2);
                    }
                }
                // Tritone
                if (ambientLayers[11] && ambientLayers[12] && progress > 0.4) {
                    const tritoneGain = Math.pow((progress - 0.4) / 0.6, 1.8) * 0.25;
                    ambientLayers[11].gain.gain.linearRampToValueAtTime(tritoneGain, time + 2);
                    ambientLayers[12].gain.gain.linearRampToValueAtTime(tritoneGain, time + 2);
                }
                // METALLIC
                if (ambientLayers[13] && ambientLayers[14] && progress > 0.5) {
                    const metallicGain = Math.pow((progress - 0.5) / 0.5, 2.2) * 0.16;
                    ambientLayers[13].gain.gain.linearRampToValueAtTime(metallicGain, time + 2);
                    ambientLayers[14].gain.gain.linearRampToValueAtTime(metallicGain, time + 2);
                }
                // High frequency
                if (ambientLayers[15] && ambientLayers[16] && progress > 0.55) {
                    const detunedGain = Math.pow((progress - 0.55) / 0.45, 1.8) * 0.14;
                    ambientLayers[15].gain.gain.linearRampToValueAtTime(detunedGain, time + 2);
                    ambientLayers[16].gain.gain.linearRampToValueAtTime(detunedGain, time + 2);
                }
            } catch (err) {}
        }

        async function triggerFinalHorror() {
            // Максимальная интенсивность звука
            if (audioContext) {
                ambientLayers.forEach(layer => {
                    if (layer && layer.gain) {
                        const time = audioContext.currentTime;
                        const currentGain = layer.gain.gain.value;
                        layer.gain.gain.linearRampToValueAtTime(currentGain * 2.5, time + 2);
                    }
                });
            }
            
            const container = document.getElementById('final-horror-container');
            const smileContainer = container.querySelector('.smile-container');
            const content = document.getElementById('content');
            content.style.display = 'none';
            container.style.display = 'block';
            
            // Страшные слова связанные с рассказом
            const horrorWords = [
                'ЗАБЫЛ', 'НЕ ПОМНИТ', 'ПУСТОТА', 'СМЕРТЬ', 'ВОДА', 'МАШИНА', 'КАЖДЫЙ ДЕНЬ',
                'БОЛЬ', 'СТРАХ', 'РАСПАД', 'ХОЛОД', 'ЛУЖА', 'КРОВЬ', 'РУКИ', 'ГЛАЗА',
                'ОТЕЦ', 'СЫН', 'БЕЗУМИЕ', 'НИКОГДА', 'ПОВТОР', 'ЦИКЛ', 'УЖАС', 'КОНЕЦ',
                'КРИК', 'ТЬМА', 'РАЗРУШЕНИЕ', 'ПУСТЫЕ', 'ТРУП', 'ЖИВОЙ ТРУП', 'ДЕМЕНЦИЯ',
                'ПОТЕРЯН', 'ЗАБВЕНИЕ', 'БЕЗЫСХОДНОСТЬ', 'АД', 'ЛЮБОВЬ', 'ДОЛГ', 'СЕМЬЯ'
            ];
            
            // Создаем в 50 раз больше слов для плотности
            const wordElements = [];
            for (let i = 0; i < 200; i++) {
                const word = horrorWords[Math.floor(Math.random() * horrorWords.length)];
                const wordEl = document.createElement('div');
                wordEl.className = 'final-word';
                wordEl.textContent = word;
                wordEl.style.left = Math.random() * window.innerWidth + 'px';
                wordEl.style.top = Math.random() * window.innerHeight + 'px';
                wordEl.style.fontSize = (12 + Math.random() * 14) + 'px';
                container.appendChild(wordEl);
                wordElements.push(wordEl);
                
                // Постепенное появление
                setTimeout(() => {
                    wordEl.style.opacity = Math.random() * 0.7 + 0.3;
                }, i * 15);
            }
            
            // Пауза 2 секунды
            await new Promise(resolve => setTimeout(resolve, 2000));
            
            // Постепенно делаем слова кровавыми
            for (let i = 0; i < wordElements.length; i++) {
                setTimeout(() => {
                    wordElements[i].classList.add('bloodify');
                    if (i % 20 === 0 && navigator.vibrate) {
                        navigator.vibrate(80);
                    }
                }, i * 20);
            }
            
            // Звук нарастающего ужаса
            if (audioContext) {
                const now = audioContext.currentTime;
                const terror = audioContext.createOscillator();
                const terrorGain = audioContext.createGain();
                const terrorFilter = audioContext.createBiquadFilter();
                terror.type = 'sawtooth';
                terror.frequency.setValueAtTime(40, now);
                terror.frequency.linearRampToValueAtTime(8, now + 4);
                terrorFilter.type = 'lowpass';
                terrorFilter.frequency.value = 200;
                terrorFilter.Q.value = 15;
                terror.connect(terrorFilter);
                terrorFilter.connect(terrorGain);
                terrorGain.connect(audioContext.destination);
                terrorGain.gain.setValueAtTime(0, now);
                terrorGain.gain.linearRampToValueAtTime(0.15, now + 4);
                terror.start(now);
                setTimeout(() => { try { terror.stop(); } catch(e) {} }, 4000);
            }
            
            await new Promise(resolve => setTimeout(resolve, 4000));
            
            // Формируем жуткий смайлик из слов
            const smileWidth = Math.min(window.innerWidth * 0.6, 600);
            const smileHeight = Math.min(window.innerHeight * 0.6, 600);
            const centerX = window.innerWidth / 2;
            const centerY = window.innerHeight / 2;
            
            // Контуры лица (круг)
            const faceWords = [];
            for (let angle = 0; angle < Math.PI * 2; angle += 0.15) {
                const radius = smileWidth * 0.45;
                const x = centerX + Math.cos(angle) * radius;
                const y = centerY + Math.sin(angle) * radius;
                faceWords.push({ x, y });
            }
            
            // Левый глаз
            const leftEyeWords = [];
            for (let angle = 0; angle < Math.PI * 2; angle += 0.3) {
                const radius = smileWidth * 0.08;
                const x = centerX - smileWidth * 0.2 + Math.cos(angle) * radius;
                const y = centerY - smileHeight * 0.15 + Math.sin(angle) * radius;
                leftEyeWords.push({ x, y });
            }
            
            // Правый глаз
            const rightEyeWords = [];
            for (let angle = 0; angle < Math.PI * 2; angle += 0.3) {
                const radius = smileWidth * 0.08;
                const x = centerX + smileWidth * 0.2 + Math.cos(angle) * radius;
                const y = centerY - smileHeight * 0.15 + Math.sin(angle) * radius;
                rightEyeWords.push({ x, y });
            }
            
            // Жуткая улыбка (широкая, до ушей)
            const smileWords = [];
            for (let t = 0; t <= 1; t += 0.02) {
                const angle = Math.PI + t * Math.PI * 0.7;
                const radius = smileWidth * 0.35;
                const x = centerX + Math.cos(angle) * radius;
                const y = centerY + smileHeight * 0.05 + Math.sin(angle) * radius * 0.6;
                smileWords.push({ x, y });
            }
            
            const allSmilePositions = [...faceWords, ...leftEyeWords, ...rightEyeWords, ...smileWords];
            
            // Анимация формирования смайлика
            for (let i = 0; i < Math.min(wordElements.length, allSmilePositions.length); i++) {
                const pos = allSmilePositions[i];
                setTimeout(() => {
                    wordElements[i].classList.add('positioned');
                    wordElements[i].style.left = pos.x + 'px';
                    wordElements[i].style.top = pos.y + 'px';
                    wordElements[i].style.fontSize = '16px';
                }, i * 15);
            }
            
            // Звук формирования
            if (audioContext) {
                playSound('scream');
                setTimeout(() => playSound('crack'), 1000);
                setTimeout(() => playSound('scream'), 2000);
            }
            
            await new Promise(resolve => setTimeout(resolve, 3000));
            
            // Смайлик полностью сформирован - пауза для давления
            smileContainer.style.opacity = '1';
            
            if (navigator.vibrate) {
                navigator.vibrate([200, 100, 200, 100, 200]);
            }
            
            await new Promise(resolve => setTimeout(resolve, 2000));
            
            // Серия сублиминальных вспышек с ужасающими образами
            const subliminal = document.querySelector('.subliminal-flash');
            const subliminalImg = subliminal.querySelector('.subliminal-image');
            
            const flashImages = ['😱', '💀', '🩸', '👁️', '🔪', '⚠️'];
            
            for (let i = 0; i < 12; i++) {
                subliminalImg.textContent = flashImages[Math.floor(Math.random() * flashImages.length)];
                subliminal.classList.add('active');
                
                if (audioContext) {
                    const now = audioContext.currentTime;
                    const flash = audioContext.createOscillator();
                    const flashGain = audioContext.createGain();
                    flash.type = 'square';
                    flash.frequency.value = 1200 + Math.random() * 1800;
                    flash.connect(flashGain);
                    flashGain.connect(audioContext.destination);
                    flashGain.gain.setValueAtTime(0.08, now);
                    flashGain.gain.exponentialRampToValueAtTime(0.001, now + 0.05);
                    flash.start(now);
                    try { flash.stop(now + 0.05); } catch(e) {}
                }
                
                await new Promise(resolve => setTimeout(resolve, 100));
                subliminal.classList.remove('active');
                await new Promise(resolve => setTimeout(resolve, Math.random() * 300 + 100));
            }
            
            // Финальная distortion
            container.style.animation = 'finalDistortion 2s';
            
            if (audioContext) {
                ambientLayers.forEach(layer => {
                    if (layer && layer.gain) {
                        const time = audioContext.currentTime;
                        layer.gain.gain.linearRampToValueAtTime(0, time + 2);
                    }
                });
            }
            
            await new Promise(resolve => setTimeout(resolve, 2000));
            
            // Все исчезает в черноту
            container.style.opacity = '0';
            container.style.transition = 'opacity 1s';
        }

        function increaseIntensity(lineIndex) {
            progressionLevel = lineIndex / story.length;
            updateAtmosphere(progressionLevel);
            densifyAmbientWords();
            if (progressionLevel > 0.25) {
                reorganizeObsessiveWords();
            }
            syncObsessionPhase();
            const staticLayer = document.querySelector('.static');
            if (staticLayer) {
                staticLayer.style.opacity = 0.12 + progressionLevel * 0.55;
            }
            const vignette = document.querySelector('.vignette');
            if (vignette) {
                const baseInner = 46 - progressionLevel * 22;
                const baseOuter = 68 - progressionLevel * 26;
                setVignetteBase(baseInner, baseOuter);
                if (progressionLevel > 0.7) {
                    vignette.classList.add('collapsing');
                } else {
                    vignette.classList.remove('collapsing');
                }
            }
            const breath = document.querySelector('.breath-overlay');
            if (breath) {
                breath.style.animation = `breatheOppressive ${Math.max(0.5, 7 - progressionLevel * 6.5)}s infinite`;
            }
            const grain = document.querySelector('.grain');
            if (grain) {
                grain.style.opacity = progressionLevel * 0.6;
            }
            if (!smileForeshadowed && progressionLevel > 0.62) {
                manifestSmilePreview();
                smileForeshadowed = true;
            }
            if (progressionLevel > 0.5 && Math.random() < (progressionLevel - 0.5) * 0.2) {
                createPareidoliaPattern(Math.random() < 0.55 ? 'eyes' : 'figure');
            }
            if (progressionLevel > 0.45 && Math.random() < (progressionLevel - 0.45) * 0.15) {
                triggerWatching();
            }
            if (progressionLevel > 0.35 && Math.random() < (progressionLevel - 0.35) * 0.18) {
                triggerPeripheralHorror();
            }
            if (progressionLevel > 0.25 && Math.random() < (progressionLevel - 0.25) * 0.9) {
                addForgottenWord();
            }
            if (progressionLevel > 0.84) {
                triggerWordFlood();
            }
            if (progressionLevel > 0.5 && Math.random() < 0.04) {
                triggerScreenTear();
            }
        }

        function clamp(value, min, max) {
            return Math.min(max, Math.max(min, value));
        }

        function currentMaxObsessiveWords() {
            return Math.floor(60 + progressionLevel * 260);
        }

        function enforceObsessiveLimit(limit) {
            while (obsessiveWords.length >= limit) {
                const old = obsessiveWords.shift();
                if (old && old.parentNode) {
                    old.classList.add('dissolve');
                    setTimeout(() => old.remove(), 6000);
                }
            }
        }

        function createObsessiveWordElement(text, leftPercent, topPercent, classNames = [], overrides = {}) {
            const limit = overrides.limit || currentMaxObsessiveWords();
            enforceObsessiveLimit(limit);
            const container = document.getElementById('obsessive-words');
            const wordEl = document.createElement('div');
            wordEl.className = 'obsessive-word';
            classNames.forEach(cls => wordEl.classList.add(cls));
            const content = overrides.preserveCase ? text : text.toUpperCase();
            wordEl.textContent = content;
            const left = clamp(leftPercent, 2, 98);
            const top = clamp(topPercent, 4, 96);
            wordEl.style.left = left + '%';
            wordEl.style.top = top + '%';
            const opacity = overrides.opacity ?? (0.1 + progressionLevel * 0.4 + Math.random() * 0.08);
            const scale = overrides.scale ?? (0.85 + progressionLevel * 0.6 + Math.random() * 0.4);
            const duration = overrides.duration ?? (10 + Math.random() * 12);
            const driftX = overrides.driftX ?? ((Math.random() - 0.5) * (24 + progressionLevel * 140));
            const driftY = overrides.driftY ?? ((Math.random() - 0.5) * (20 + progressionLevel * 110));
            wordEl.style.setProperty('--targetOpacity', opacity.toFixed(2));
            wordEl.style.setProperty('--wordScale', scale.toFixed(2));
            wordEl.style.setProperty('--wordDuration', duration.toFixed(2) + 's');
            wordEl.style.setProperty('--driftX', driftX.toFixed(1) + 'px');
            wordEl.style.setProperty('--driftY', driftY.toFixed(1) + 'px');
            wordEl.dataset.locked = 'true';
            container.appendChild(wordEl);
            requestAnimationFrame(() => wordEl.classList.add('active'));
            obsessiveWords.push(wordEl);
            const unlockDelay = overrides.unlockDelay ?? (4000 + Math.random() * 4000);
            setTimeout(() => { wordEl.dataset.locked = 'false'; }, unlockDelay);
            return wordEl;
        }

        function spawnAmbientWordFromPool(pool = RORSCHACH_POOL) {
            const text = pool[Math.floor(Math.random() * pool.length)];
            const spread = 40 + progressionLevel * 35;
            const baseX = clamp(50 + (Math.random() - 0.5) * spread, 2, 98);
            const baseY = clamp(50 + (Math.random() - 0.5) * spread * 0.8, 4, 96);
            const classes = [];
            let mirrored = false;
            if (progressionLevel > 0.45 && Math.random() < 0.6) {
                classes.push('rorschach', 'silhouette');
                mirrored = true;
            } else if (Math.random() < 0.4) {
                classes.push('whisper');
                mirrored = true;
            }
            createObsessiveWordElement(text, baseX, baseY, classes, {});
            if (mirrored) {
                createObsessiveWordElement(text, 100 - baseX + (Math.random() - 0.5) * 4, baseY + (Math.random() - 0.5) * 4, classes.concat('mirror'), {});
            } else if (Math.random() < 0.25) {
                createObsessiveWordElement(text, 100 - baseX + (Math.random() - 0.5) * 6, baseY + (Math.random() - 0.5) * 3, ['whisper', 'mirror'], {});
            }
        }

        function densifyAmbientWords(force = false) {
            const limit = currentMaxObsessiveWords();
            const target = Math.floor(limit * (0.3 + progressionLevel * 0.55));
            if (force) {
                for (let i = 0; i < 4 + Math.floor(progressionLevel * 6); i++) {
                    spawnAmbientWordFromPool();
                }
            }
            while (obsessiveWords.length < target) {
                spawnAmbientWordFromPool();
            }
        }

        function reorganizeObsessiveWords(forcePattern = false) {
            const swirl = Math.min(1, progressionLevel * 1.5 + 0.2);
            obsessiveWords.forEach((word) => {
                if (!word || word.dataset.locked === 'true' || word.classList.contains('rorschach')) return;
                const jitterX = (Math.random() - 0.5) * (20 + swirl * 60);
                const jitterY = (Math.random() - 0.5) * (18 + swirl * 48);
                word.style.setProperty('--driftX', jitterX.toFixed(1) + 'px');
                word.style.setProperty('--driftY', jitterY.toFixed(1) + 'px');
                const currentOpacity = parseFloat(word.style.getPropertyValue('--targetOpacity')) || 0.2;
                const newOpacity = clamp(currentOpacity + (Math.random() - 0.5) * 0.08 + swirl * 0.05, 0.08, 0.7);
                word.style.setProperty('--targetOpacity', newOpacity.toFixed(2));
                if (Math.random() < 0.35) {
                    const left = clamp(parseFloat(word.style.left) + (Math.random() - 0.5) * swirl * 8, 2, 98);
                    const top = clamp(parseFloat(word.style.top) + (Math.random() - 0.5) * swirl * 7, 3, 97);
                    word.style.left = left + '%';
                    word.style.top = top + '%';
                }
            });
            if (progressionLevel > 0.55 && (forcePattern || Math.random() < 0.35)) {
                spawnRorschachCluster();
            }
        }

        function spawnRorschachCluster() {
            const centerX = 50 + (Math.random() - 0.5) * 10;
            const centerY = 45 + (Math.random() - 0.5) * 12;
            const rings = 3 + Math.floor(Math.random() * 2);
            for (let ring = 0; ring < rings; ring++) {
                const points = 10 + ring * 4;
                const radius = 6 + ring * (6 + progressionLevel * 12);
                for (let i = 0; i < points; i++) {
                    const angle = (i / points) * Math.PI;
                    const offsetX = Math.cos(angle) * radius;
                    const offsetY = Math.sin(angle) * radius * 1.6;
                    const leftA = clamp(centerX + offsetX, 3, 97);
                    const leftB = clamp(centerX - offsetX, 3, 97);
                    const top = clamp(centerY + offsetY, 5, 95);
                    const text = RORSCHACH_POOL[Math.floor(Math.random() * RORSCHACH_POOL.length)];
                    createObsessiveWordElement(text, leftA, top, ['rorschach', 'silhouette'], {opacity: 0.22 + progressionLevel * 0.35, scale: 1.1 + ring * 0.1, unlockDelay: 9000 + Math.random() * 4000});
                    createObsessiveWordElement(text, leftB, top + (Math.random() - 0.5) * 2, ['rorschach', 'silhouette', 'mirror'], {opacity: 0.22 + progressionLevel * 0.35, scale: 1.1 + ring * 0.1, unlockDelay: 9000 + Math.random() * 4000});
                }
            }
        }

        function triggerParanoiaEcho() {
            const baseX = clamp((realMouseX / window.innerWidth) * 100 || 50, 5, 95);
            const baseY = clamp((realMouseY / window.innerHeight) * 100 || 50, 5, 95);
            const count = 6 + Math.floor(Math.random() * 6) + Math.floor(progressionLevel * 10);
            for (let i = 0; i < count; i++) {
                const angle = Math.random() * Math.PI * 2;
                const radius = 4 + Math.random() * (12 + progressionLevel * 18);
                const left = clamp(baseX + Math.cos(angle) * radius, 4, 96);
                const top = clamp(baseY + Math.sin(angle) * radius, 4, 96);
                const word = RORSCHACH_POOL[Math.floor(Math.random() * RORSCHACH_POOL.length)];
                createObsessiveWordElement(word, left, top, ['halo', 'rorschach'], {opacity: 0.28 + progressionLevel * 0.3, unlockDelay: 7000});
                if (Math.random() < 0.8) {
                    createObsessiveWordElement(word, 100 - left + (Math.random() - 0.5) * 3, top + (Math.random() - 0.5) * 3, ['halo', 'mirror'], {opacity: 0.2 + progressionLevel * 0.25, unlockDelay: 7000});
                }
            }
        }

        function createWordHalo(element) {
            if (!element) return;
            const rect = element.getBoundingClientRect();
            const centerX = (rect.left + rect.width / 2) / window.innerWidth * 100;
            const centerY = (rect.top + rect.height / 2) / window.innerHeight * 100;
            const layers = 8 + Math.floor(progressionLevel * 16);
            for (let i = 0; i < layers; i++) {
                const angle = (i / layers) * Math.PI * 2 + Math.random() * 0.4;
                const radius = 3 + Math.random() * (10 + progressionLevel * 16);
                const left = clamp(centerX + Math.cos(angle) * radius, 4, 96);
                const top = clamp(centerY + Math.sin(angle) * radius, 4, 96);
                const word = RORSCHACH_POOL[Math.floor(Math.random() * RORSCHACH_POOL.length)];
                createObsessiveWordElement(word, left, top, ['halo'], {opacity: 0.32 + progressionLevel * 0.3, unlockDelay: 8000});
                createObsessiveWordElement(word, 100 - left + (Math.random() - 0.5) * 2, top + (Math.random() - 0.5) * 2, ['halo', 'mirror'], {opacity: 0.28 + progressionLevel * 0.25, unlockDelay: 8000});
            }
        }

        function addObsessiveWord(word) {
            if (!word) return;
            densifyAmbientWords();
            const left = clamp(45 + (Math.random() - 0.5) * 30, 5, 95);
            const top = clamp(40 + (Math.random() - 0.5) * 24, 5, 95);
            const focusText = word.toUpperCase();
            createObsessiveWordElement(focusText, left, top, ['focused-word'], {opacity: 0.26 + progressionLevel * 0.4, unlockDelay: 6500});
            createObsessiveWordElement(focusText, 100 - left + (Math.random() - 0.5) * 4, top + (Math.random() - 0.5) * 3, ['focused-word', 'mirror'], {opacity: 0.22 + progressionLevel * 0.4, unlockDelay: 6500});
        }

        function addForgottenWord() {
            if (forgottenWords.length > 350) return;
            const word = FORGOTTEN[Math.floor(Math.random() * FORGOTTEN.length)];
            const wordEl = document.createElement('div');
            wordEl.className = 'forgotten-word';
            wordEl.textContent = word.toUpperCase();
            wordEl.style.left = (1 + Math.random() * 98) + '%';
            wordEl.style.top = (1 + Math.random() * 98) + '%';
            wordEl.style.transform = `rotate(${(Math.random() - 0.5) * 45}deg)`;
            document.getElementById('forgotten-words').appendChild(wordEl);
            setTimeout(() => wordEl.classList.add('active'), 100);
            forgottenWords.push(wordEl);
        }

        function triggerBlackout(duration) {
            const blackout = document.querySelector('.blackout');
            blackout.classList.add('active');
            setTimeout(() => blackout.classList.remove('active'), duration);
        }

        function triggerStrobe(duration) {
            const strobe = document.querySelector('.strobe');
            strobe.classList.add('active');
            setTimeout(() => strobe.classList.remove('active'), duration);
            if (navigator.vibrate) {
                const pattern = [];
                for (let i = 0; i < duration / 80; i++) {
                    pattern.push(50, 30);
                }
                navigator.vibrate(pattern);
            }
        }

        function triggerChromatic() {
            const chromatic = document.querySelector('.chromatic');
            chromatic.classList.add('active');
            setTimeout(() => chromatic.classList.remove('active'), 300);
        }

        function triggerWatching() {
            isWatching = true;
            const watching = document.querySelector('.watching-overlay');
            const gaze = document.querySelector('.gaze-focus');
            const lineSnapshot = currentLineElement;
            let focusX = realMouseX;
            let focusY = realMouseY;
            if (lineSnapshot) {
                const rect = lineSnapshot.getBoundingClientRect();
                focusX = rect.left + rect.width / 2;
                focusY = rect.top + rect.height / 2;
                lineSnapshot.classList.add('spotlight');
                createWordHalo(lineSnapshot);
                pulseWordsAroundLine(lineSnapshot, 0.8);
            }
            const xPercent = (focusX / window.innerWidth) * 100;
            const yPercent = (focusY / window.innerHeight) * 100;
            watching.style.setProperty('--x', xPercent + '%');
            watching.style.setProperty('--y', yPercent + '%');
            gaze.style.setProperty('--gx', xPercent + '%');
            gaze.style.setProperty('--gy', yPercent + '%');
            watching.classList.add('active');
            gaze.classList.add('active');
            const vignette = document.querySelector('.vignette');
            if (vignette) {
                const prevInner = vignette.style.getPropertyValue('--focus-inner') || (vignette.dataset.baseInner ? vignette.dataset.baseInner + '%' : '46%');
                const prevOuter = vignette.style.getPropertyValue('--focus-outer') || (vignette.dataset.baseOuter ? vignette.dataset.baseOuter + '%' : '68%');
                vignette.dataset.prevInnerStyle = prevInner;
                vignette.dataset.prevOuterStyle = prevOuter;
                vignette.style.setProperty('--focus-x', xPercent.toFixed(2) + '%');
                vignette.style.setProperty('--focus-y', yPercent.toFixed(2) + '%');
                vignette.style.setProperty('--focus-inner', '14%');
                vignette.style.setProperty('--focus-outer', '30%');
                vignette.classList.add('focused', 'focus-ring', 'focus-lock', 'pulse');
                if (vignettePulseTimeout) {
                    clearTimeout(vignettePulseTimeout);
                    vignettePulseTimeout = null;
                }
            }
            densifyAmbientWords(true);
            reorganizeObsessiveWords(true);
            setTimeout(() => {
                watching.classList.remove('active');
                gaze.classList.remove('active');
                if (vignette) {
                    const baseInner = vignette.dataset.baseInner ? vignette.dataset.baseInner + '%' : vignette.dataset.prevInnerStyle || '46%';
                    const baseOuter = vignette.dataset.baseOuter ? vignette.dataset.baseOuter + '%' : vignette.dataset.prevOuterStyle || '68%';
                    vignette.style.setProperty('--focus-inner', baseInner);
                    vignette.style.setProperty('--focus-outer', baseOuter);
                    vignette.classList.remove('focused', 'focus-ring', 'focus-lock', 'pulse');
                    delete vignette.dataset.prevInnerStyle;
                    delete vignette.dataset.prevOuterStyle;
                    if (vignettePulseTimeout) {
                        clearTimeout(vignettePulseTimeout);
                        vignettePulseTimeout = null;
                    }
                }
                if (lineSnapshot) {
                    lineSnapshot.classList.remove('spotlight');
                }
                isWatching = false;
            }, 5200);
            if (navigator.vibrate) {
                navigator.vibrate([120, 60, 120, 60, 120]);
            }
        }

        function triggerPeripheralHorror() {
            const side = Math.random() < 0.5 ? 'left' : 'right';
            const peripheral = document.querySelector(`.peripheral-horror.${side}`);
            peripheral.classList.add('active');
            setTimeout(() => peripheral.classList.remove('active'), 150);
            if (navigator.vibrate && Math.random() < 0.4) {
                navigator.vibrate(60);
            }
        }

        function triggerScreenTear() {
            const tear = document.querySelector('.screen-tear');
            tear.classList.add('active');
            setTimeout(() => tear.classList.remove('active'), 600);
        }

        function triggerTimeDistortion() {
            const distortion = document.querySelector('.time-distortion');
            distortion.classList.add('active');
            setTimeout(() => distortion.classList.remove('active'), 4000);
        }

        function triggerRealityGlitch() {
            const glitch = document.querySelector('.reality-glitch');
            glitch.classList.add('active');
            setTimeout(() => glitch.classList.remove('active'), 400);
            if (navigator.vibrate) {
                navigator.vibrate([60, 40, 60, 40, 60]);
            }
        }

        async function startExperience() {
            const content = document.getElementById('content');
            igniteObsessionField();
            if (!wordStormInterval) {
                wordStormInterval = setInterval(() => densifyAmbientWords(), 3600);
            }
            if (!wordPatternInterval) {
                wordPatternInterval = setInterval(() => reorganizeObsessiveWords(), 5200);
            }
            densifyAmbientWords(true);
            try {
                for (let i = 0; i < story.length; i++) {
                    const parts = story[i].split('|');
                    const text = parts[0];
                    const wait = parseInt(parts[1]);
                    const effects = parts.slice(2);
                    increaseIntensity(i);
                    content.innerHTML = '';
                    currentLineElement = null;
                    if (text.trim()) {
                        const div = document.createElement('div');
                        div.className = 'line';
                        div.innerHTML = text;
                        content.appendChild(div);
                        currentLineElement = div;
                        const plainText = div.textContent.replace(/\s+/g, ' ').trim();
                        const focusIntensity = computeFocusIntensity(effects, plainText);
                        alignVignetteToElement(div, focusIntensity);
                        if (/никогда/i.test(plainText)) {
                            div.classList.add('never');
                            const echoText = plainText.toUpperCase().replace(/[.,!?…:;]+/g, '');
                            div.dataset.echo = echoText || 'НИКОГДА';
                            reorganizeObsessiveWords(true);
                            densifyAmbientWords(true);
                            triggerParanoiaEcho();
                            setTimeout(() => triggerNeverSpiral(div), 250);
                            alignVignetteToElement(div, 1, { overrideLock: true });
                        }
                        if (/кров/i.test(plainText) || effects.includes('blood')) {
                            div.classList.add('hemorrhage');
                        }
                        if (focusIntensity > 0.55) {
                            setTimeout(() => pulseWordsAroundLine(div, focusIntensity), 260);
                        }
                        setTimeout(() => div.classList.add('active'), 100);
                        
                        // АВТОМАТИЧЕСКОЕ ПРИМЕНЕНИЕ ПСИХОЛОГИЧЕСКИХ ЭФФЕКТОВ
                        // Дыхание для эмоциональных моментов
                        if (progressionLevel > 0.3 && (
                            text.includes('смотришь') || 
                            text.includes('видишь') || 
                            text.includes('чувствуешь') ||
                            text.includes('дышит') ||
                            text.includes('ждёшь')
                        )) {
                            applyBreathingToText(div);
                        }
                        
                        // Тремор для тревожных моментов
                        if (progressionLevel > 0.4 && (
                            text.includes('страх') ||
                            text.includes('трясутся') ||
                            text.includes('боль') ||
                            text.includes('кричит') ||
                            text.includes('ломается')
                        )) {
                            applyTremorToText(div);
                        }
                        
                        for (const effect of effects) {
                            if (effect === 'break') {
                                div.classList.add('break-wall');
                            }
                            else if (effect === 'glitch') {
                                setTimeout(() => div.classList.add('glitched'), 100);
                                setTimeout(() => div.classList.remove('glitched'), 2000);
                            }
                            else if (effect === 'shake') {
                                content.classList.add('shake');
                            }
                            else if (effect === 'distorted') {
                                setTimeout(() => div.classList.add('distorted'), 100);
                            }
                            else if (effect === 'watching') {
                                triggerWatching();
                                // Добавляем парейдолию глаз при watching
                                if (Math.random() < 0.4) {
                                    setTimeout(() => createPareidoliaPattern('eyes'), 500);
                                }
                            }
                            else if (effect === 'cursormove' || effect === 'peripheralshadow') {
                                triggerParanoiaEcho();
                                triggerPeripheralShadows();
                            }
                            else if (effect === 'peripheral') {
                                triggerPeripheralHorror();
                                // Иногда добавляем фигуру
                                if (Math.random() < 0.25) {
                                    setTimeout(() => createPareidoliaPattern('figure'), 800);
                                }
                            }
                            else if (effect === 'chromatic') {
                                triggerChromatic();
                            }
                            else if (effect === 'screentear') {
                                triggerScreenTear();
                            }
                            else if (effect === 'timedistort') {
                                triggerTimeDistortion();
                            }
                            else if (effect === 'reality') {
                                triggerRealityGlitch();
                            }
                            else if (effect === 'heartbeat') {
                                const hb = document.querySelector('.heartbeat');
                                hb.classList.add('active');
                                setTimeout(() => hb.classList.remove('active'), 3500);
                            }
                            else if (effect === 'water') {
                                for (let j = 0; j < 4; j++) {
                                    setTimeout(() => createWaterDrop(), j * 250);
                                }
                            }
                            else if (effect === 'blooddrop') {
                                for (let j = 0; j < 3; j++) {
                                    setTimeout(() => createBloodDrop(), j * 350);
                                }
                            }
                            else if (effect === 'wetstain') {
                                createWetStain();
                            }
                            else if (effect === 'breathfog') {
                                triggerBreathFog();
                            }
                            else if (effect === 'crack') {
                                triggerScreenCrack();
                            }
                            else if (effect === 'finalhorror') {
                                await triggerFinalHorror();
                            }
                            else if (effect === 'silence') {
                                if (audioContext) {
                                    ambientLayers.forEach(layer => {
                                        if (layer && layer.gain) {
                                            const time = audioContext.currentTime;
                                            const current = layer.gain.gain.value;
                                            layer.gain.gain.linearRampToValueAtTime(current * 0.08, time + 0.5);
                                            setTimeout(() => {
                                                layer.gain.gain.linearRampToValueAtTime(current, time + 2.5);
                                            }, 1000);
                                        }
                                    });
                                }
                            }
                            else if (effect.startsWith('subliminal:')) {
                                const msg = effect.split(':')[1];
                                const subliminal = document.querySelector('.subliminal');
                                subliminal.textContent = msg;
                                subliminal.classList.add('active');
                                setTimeout(() => subliminal.classList.remove('active'), 40);
                            }
                            else if (effect.startsWith('blackout:')) {
                                const duration = parseInt(effect.split(':')[1]);
                                setTimeout(() => triggerBlackout(duration), 100);
                            }
                            else if (effect.startsWith('strobe:')) {
                                const duration = parseInt(effect.split(':')[1]);
                                setTimeout(() => triggerStrobe(duration), 100);
                            }
                            else if (effect === 'shadow') {
                                const side = Math.random() < 0.5 ? 'left' : 'right';
                                const shadowEl = document.querySelector(`.shadow.${side}`);
                                shadowEl.classList.add('active');
                                setTimeout(() => shadowEl.classList.remove('active'), 3000);
                            }
                            else if (effect === 'blood') {
                                div.classList.add('blood');
                                div.classList.add('hemorrhage');
                                densifyAmbientWords(true);
                                reorganizeObsessiveWords(true);
                                document.querySelector('.blood-screen').classList.add('active');
                                setTimeout(() => document.querySelector('.blood-screen').classList.remove('active'), 4000);
                            }
                            else if (effect === 'redFlicker') {
                                const flickerEl = document.querySelector('.red-flicker');
                                flickerEl.classList.add('active');
                                setTimeout(() => flickerEl.classList.remove('active'), 3000);
                            }
                            else if (effect === 'trail') {
                                setTimeout(() => div.classList.add('text-trail'), 100);
                            }
                            else if (effect === 'double') {
                                setTimeout(() => div.classList.add('double-vision'), 100);
                            }
                            else if (effect === 'freeze') {
                                setTimeout(() => div.classList.add('time-freeze'), 100);
                            }
                            else if (effect.startsWith('obsess:')) {
                                addObsessiveWord(effect.split(':')[1]);
                            }
                            else if (effect.startsWith('sound:')) {
                                playSound(effect.split(':')[1]);
                            }
                        }
                        if (effects.includes('shake')) {
                            setTimeout(() => content.classList.remove('shake'), 500);
                        }
                    }
                    await new Promise(resolve => setTimeout(resolve, wait));
                }
                // Fade out
                if (audioContext) {
                    const time = audioContext.currentTime;
                    ambientLayers.forEach(layer => {
                        if (layer && layer.gain) {
                            layer.gain.gain.linearRampToValueAtTime(0, time + 12);
                        }
                    });
                }
                setTimeout(() => {
                    if (audioContext) {
                        ambientLayers.forEach(layer => {
                            if (layer && layer.osc) {
                                try { layer.osc.stop(); } catch(e) {}
                            }
                        });
                    }
                    if (wordStormInterval) {
                        clearInterval(wordStormInterval);
                        wordStormInterval = null;
                    }
                    if (wordPatternInterval) {
                        clearInterval(wordPatternInterval);
                        wordPatternInterval = null;
                    }
                    if (obsessionEscalationInterval) {
                        clearInterval(obsessionEscalationInterval);
                        obsessionEscalationInterval = null;
                    }
                    if (wordFloodInterval) {
                        clearInterval(wordFloodInterval);
                        wordFloodInterval = null;
                    }
                    location.reload();
                }, 15000);
            } catch (err) {}
        }

        function playSound(type) {
            if (!audioContext) return;
            const now = audioContext.currentTime;
            if (type === 'tick') {
                const osc1 = audioContext.createOscillator();
                const osc2 = audioContext.createOscillator();
                const gain = audioContext.createGain();
                const filter = audioContext.createBiquadFilter();
                osc1.type = 'sine';
                osc2.type = 'sine';
                osc1.frequency.setValueAtTime(52, now);
                osc1.frequency.exponentialRampToValueAtTime(32, now + 0.1);
                osc2.frequency.setValueAtTime(104, now);
                osc2.frequency.exponentialRampToValueAtTime(64, now + 0.1);
                filter.type = 'lowpass';
                filter.frequency.value = 140;
                filter.Q.value = 10;
                osc1.connect(filter);
                osc2.connect(filter);
                filter.connect(gain);
                gain.connect(audioContext.destination);
                gain.gain.setValueAtTime(0.4, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.18);
                osc1.start(now);
                osc2.start(now);
                try {
                    osc1.stop(now + 0.18);
                    osc2.stop(now + 0.18);
                } catch(e) {}
                if (navigator.vibrate) {
                    navigator.vibrate(90);
                }
            }
            else if (type === 'step') {
                for (let i = 0; i < 2; i++) {
                    setTimeout(() => {
                        const noiseBuffer1 = audioContext.createBuffer(1, 8192, audioContext.sampleRate);
                        const noiseData1 = noiseBuffer1.getChannelData(0);
                        for (let j = 0; j < 8192; j++) {
                            noiseData1[j] = (Math.random() * 2 - 1) * Math.exp(-j / 1800);
                        }
                        const noise1 = audioContext.createBufferSource();
                        noise1.buffer = noiseBuffer1;
                        const filter1 = audioContext.createBiquadFilter();
                        filter1.type = 'lowpass';
                        filter1.frequency.value = 75 + Math.random() * 35;
                        filter1.Q.value = 4;
                        const gain1 = audioContext.createGain();
                        noise1.connect(filter1);
                        filter1.connect(gain1);
                        gain1.connect(audioContext.destination);
                        const t = audioContext.currentTime;
                        gain1.gain.setValueAtTime(0.5, t);
                        gain1.gain.exponentialRampToValueAtTime(0.01, t + 0.4);
                        noise1.start(t);
                        const noiseBuffer2 = audioContext.createBuffer(1, 4096, audioContext.sampleRate);
                        const noiseData2 = noiseBuffer2.getChannelData(0);
                        for (let j = 0; j < 4096; j++) {
                            noiseData2[j] = (Math.random() * 2 - 1) * (j < 600 ? 1 : Math.exp(-(j - 600) / 900));
                        }
                        const noise2 = audioContext.createBufferSource();
                        noise2.buffer = noiseBuffer2;
                        const filter2 = audioContext.createBiquadFilter();
                        filter2.type = 'bandpass';
                        filter2.frequency.value = 380 + Math.random() * 650;
                        filter2.Q.value = 14;
                        const gain2 = audioContext.createGain();
                        noise2.connect(filter2);
                        filter2.connect(gain2);
                        gain2.connect(audioContext.destination);
                        gain2.gain.setValueAtTime(0.28, t);
                        gain2.gain.exponentialRampToValueAtTime(0.01, t + 0.18);
                        noise2.start(t);
                        const noiseBuffer3 = audioContext.createBuffer(1, 2048, audioContext.sampleRate);
                        const noiseData3 = noiseBuffer3.getChannelData(0);
                        for (let j = 0; j < 2048; j++) {
                            noiseData3[j] = (Math.random() * 2 - 1) * (j < 250 ? 1 : 0);
                        }
                        const noise3 = audioContext.createBufferSource();
                        noise3.buffer = noiseBuffer3;
                        const filter3 = audioContext.createBiquadFilter();
                        filter3.type = 'highpass';
                        filter3.frequency.value = 1400 + Math.random() * 1100;
                        filter3.Q.value = 10;
                        const gain3 = audioContext.createGain();
                        noise3.connect(filter3);
                        filter3.connect(gain3);
                        gain3.connect(audioContext.destination);
                        gain3.gain.setValueAtTime(0.18, t);
                        gain3.gain.exponentialRampToValueAtTime(0.01, t + 0.1);
                        noise3.start(t);
                        const delay = audioContext.createDelay();
                        delay.delayTime.value = 0.1;
                        const delayGain = audioContext.createGain();
                        delayGain.gain.value = 0.35;
                        filter1.connect(delay);
                        delay.connect(delayGain);
                        delayGain.connect(audioContext.destination);
                        if (navigator.vibrate) {
                            navigator.vibrate([110, 35, 70]);
                        }
                    }, i * 600);
                }
            }
            else if (type === 'metallic') {
                const filter1 = audioContext.createBiquadFilter();
                const filter2 = audioContext.createBiquadFilter();
                const gain = audioContext.createGain();
                filter1.type = 'bandpass';
                filter1.frequency.value = 2400 + Math.random() * 2200;
                filter1.Q.value = 18;
                filter2.type = 'highpass';
                filter2.frequency.value = 1150;
                const buffer = audioContext.createBuffer(1, 16384, audioContext.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < 16384; i++) {
                    data[i] = (Math.random() * 2 - 1) * (1 - i / 16384);
                }
                const noise = audioContext.createBufferSource();
                noise.buffer = buffer;
                noise.playbackRate.value = 0.65;
                noise.connect(filter1);
                filter1.connect(filter2);
                filter2.connect(gain);
                gain.connect(audioContext.destination);
                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(0.2, now + 0.18);
                gain.gain.linearRampToValueAtTime(0.14, now + 1.4);
                gain.gain.linearRampToValueAtTime(0, now + 2);
                const lfo = audioContext.createOscillator();
                const lfoGain = audioContext.createGain();
                lfo.frequency.value = 3.8;
                lfoGain.gain.value = 450;
                lfo.connect(lfoGain);
                lfoGain.connect(filter1.frequency);
                noise.start(now);
                lfo.start(now);
                setTimeout(() => {
                    try {
                        noise.stop();
                        lfo.stop();
                    } catch(e) {}
                }, 2000);
                if (navigator.vibrate) {
                    navigator.vibrate([170, 90, 170, 90, 170]);
                }
            }
            else if (type === 'distant_voices') {
                for (let i = 0; i < 3; i++) {
                    setTimeout(() => {
                        const osc1 = audioContext.createOscillator();
                        const osc2 = audioContext.createOscillator();
                        const gain = audioContext.createGain();
                        const filter = audioContext.createBiquadFilter();
                        const delay = audioContext.createDelay();
                        const delayGain = audioContext.createGain();
                        osc1.type = 'sawtooth';
                        osc2.type = 'sine';
                        const baseFreq = 170 + Math.random() * 130;
                        osc1.frequency.setValueAtTime(baseFreq, now);
                        osc2.frequency.setValueAtTime(baseFreq * 1.01, now);
                        filter.type = 'bandpass';
                        filter.frequency.value = 280 + Math.random() * 220;
                        filter.Q.value = 10;
                        delay.delayTime.value = 0.35;
                        delayGain.gain.value = 0.45;
                        osc1.connect(filter);
                        osc2.connect(filter);
                        filter.connect(gain);
                        filter.connect(delay);
                        delay.connect(delayGain);
                        delayGain.connect(gain);
                        gain.connect(audioContext.destination);
                        const t = audioContext.currentTime;
                        gain.gain.setValueAtTime(0, t);
                        gain.gain.linearRampToValueAtTime(0.1, t + 0.6);
                        gain.gain.linearRampToValueAtTime(0.07, t + 2.5);
                        gain.gain.linearRampToValueAtTime(0, t + 3.5);
                        osc1.start(t);
                        osc2.start(t);
                        try {
                            osc1.stop(t + 3.5);
                            osc2.stop(t + 3.5);
                        } catch(e) {}
                    }, i * 1100 + Math.random() * 600);
                }
            }
            else if (type === 'void_hum') {
                const osc1 = audioContext.createOscillator();
                const osc2 = audioContext.createOscillator();
                const osc3 = audioContext.createOscillator();
                const gain = audioContext.createGain();
                const filter = audioContext.createBiquadFilter();
                osc1.type = 'sine';
                osc2.type = 'sine';
                osc3.type = 'triangle';
                osc1.frequency.value = 58;
                osc2.frequency.value = 58.5;
                osc3.frequency.value = 87;
                filter.type = 'lowpass';
                filter.frequency.value = 180;
                filter.Q.value = 14;
                osc1.connect(filter);
                osc2.connect(filter);
                osc3.connect(filter);
                filter.connect(gain);
                gain.connect(audioContext.destination);
                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(0.25, now + 2.5);
                gain.gain.linearRampToValueAtTime(0.2, now + 9);
                gain.gain.linearRampToValueAtTime(0, now + 11);
                filter.frequency.linearRampToValueAtTime(75, now + 11);
                osc1.start(now);
                osc2.start(now);
                osc3.start(now);
                setTimeout(() => {
                    try {
                        osc1.stop();
                        osc2.stop();
                        osc3.stop();
                    } catch(e) {}
                }, 11000);
            }
            else if (type === 'pressure') {
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                const filter = audioContext.createBiquadFilter();
                osc.type = 'sine';
                osc.frequency.value = 17;
                filter.type = 'lowpass';
                filter.frequency.value = 38;
                filter.Q.value = 22;
                osc.connect(filter);
                filter.connect(gain);
                gain.connect(audioContext.destination);
                const lfo = audioContext.createOscillator();
                const lfoGain = audioContext.createGain();
                lfo.frequency.value = 0.35;
                lfoGain.gain.value = 0.18;
                lfo.connect(lfoGain);
                lfoGain.connect(gain.gain);
                gain.gain.setValueAtTime(0.28, now);
                osc.start(now);
                lfo.start(now);
                setTimeout(() => {
                    try {
                        gain.gain.linearRampToValueAtTime(0, audioContext.currentTime + 1.2);
                        setTimeout(() => {
                            osc.stop();
                            lfo.stop();
                        }, 1200);
                    } catch(e) {}
                }, 4500);
                if (navigator.vibrate) {
                    navigator.vibrate([220, 110, 220, 110, 220, 110, 220]);
                }
            }
            else if (type === 'water' || type === 'waterambient') {
                const gain = audioContext.createGain();
                const filter1 = audioContext.createBiquadFilter();
                const filter2 = audioContext.createBiquadFilter();
                filter1.type = 'bandpass';
                filter1.frequency.value = 420 + Math.random() * 380;
                filter1.Q.value = 1.3;
                filter2.type = 'highpass';
                filter2.frequency.value = 170;
                const buffer = audioContext.createBuffer(1, 12288, audioContext.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < 12288; i++) {
                    data[i] = Math.random() * 2 - 1;
                }
                const noise = audioContext.createBufferSource();
                noise.buffer = buffer;
                noise.loop = true;
                noise.connect(filter1);
                filter1.connect(filter2);
                filter2.connect(gain);
                gain.connect(audioContext.destination);
                const duration = type === 'waterambient' ? 7000 : 4500;
                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(0.18, now + 0.7);
                gain.gain.linearRampToValueAtTime(0.14, now + (duration/1000) - 0.6);
                gain.gain.linearRampToValueAtTime(0, now + (duration/1000));
                const lfo = audioContext.createOscillator();
                const lfoGain = audioContext.createGain();
                lfo.frequency.value = 0.8;
                lfoGain.gain.value = 200;
                lfo.connect(lfoGain);
                lfoGain.connect(filter1.frequency);
                noise.start(now);
                lfo.start(now);
                setTimeout(() => {
                    try {
                        noise.stop();
                        lfo.stop();
                    } catch(e) {}
                }, duration);
            }
            else if (type === 'machine') {
                const noiseBuffer1 = audioContext.createBuffer(1, 44100, audioContext.sampleRate);
                const noiseData1 = noiseBuffer1.getChannelData(0);
                for (let i = 0; i < 44100; i++) {
                    noiseData1[i] = (Math.random() * 2 - 1) * 0.85;
                }
                const noise1 = audioContext.createBufferSource();
                noise1.buffer = noiseBuffer1;
                noise1.loop = true;
                const filter1 = audioContext.createBiquadFilter();
                filter1.type = 'lowpass';
                filter1.frequency.value = 115;
                filter1.Q.value = 18;
                const gain1 = audioContext.createGain();
                noise1.connect(filter1);
                filter1.connect(gain1);
                gain1.connect(audioContext.destination);
                gain1.gain.setValueAtTime(0, now);
                gain1.gain.linearRampToValueAtTime(0.2, now + 0.9);
                gain1.gain.setValueAtTime(0.2, now + 3.5);
                gain1.gain.linearRampToValueAtTime(0, now + 4.2);
                const noiseBuffer2 = audioContext.createBuffer(1, 44100, audioContext.sampleRate);
                const noiseData2 = noiseBuffer2.getChannelData(0);
                for (let i = 0; i < 44100; i++) {
                    noiseData2[i] = (Math.random() * 2 - 1) * 0.65;
                }
                const noise2 = audioContext.createBufferSource();
                noise2.buffer = noiseBuffer2;
                noise2.loop = true;
                const filter2 = audioContext.createBiquadFilter();
                filter2.type = 'bandpass';
                filter2.frequency.value = 230;
                filter2.Q.value = 28;
                const gain2 = audioContext.createGain();
                noise2.connect(filter2);
                filter2.connect(gain2);
                gain2.connect(audioContext.destination);
                gain2.gain.setValueAtTime(0, now);
                gain2.gain.linearRampToValueAtTime(0.14, now + 0.9);
                gain2.gain.setValueAtTime(0.14, now + 3.5);
                gain2.gain.linearRampToValueAtTime(0, now + 4.2);
                const lfo1 = audioContext.createOscillator();
                const lfoGain1 = audioContext.createGain();
                lfo1.frequency.value = 0.25;
                lfoGain1.gain.value = 22;
                lfo1.connect(lfoGain1);
                lfoGain1.connect(filter1.frequency);
                const lfo2 = audioContext.createOscillator();
                const lfoGain2 = audioContext.createGain();
                lfo2.frequency.value = 0.4;
                lfoGain2.gain.value = 35;
                lfo2.connect(lfoGain2);
                lfoGain2.connect(filter2.frequency);
                noise1.start(now);
                noise2.start(now);
                lfo1.start(now);
                lfo2.start(now);
                setTimeout(() => {
                    try {
                        noise1.stop();
                        noise2.stop();
                        lfo1.stop();
                        lfo2.stop();
                    } catch(e) {}
                }, 4200);
                if (navigator.vibrate) {
                    const pattern = [];
                    for (let i = 0; i < 9; i++) {
                        pattern.push(160, 220);
                    }
                    navigator.vibrate(pattern);
                }
            }
            else if (type === 'breathing') {
                for (let i = 0; i < 2; i++) {
                    setTimeout(() => {
                        const inhaleBuffer = audioContext.createBuffer(1, 22050, audioContext.sampleRate);
                        const inhaleData = inhaleBuffer.getChannelData(0);
                        for (let j = 0; j < 22050; j++) {
                            const envelope = Math.sin((j / 22050) * Math.PI);
                            inhaleData[j] = (Math.random() * 2 - 1) * envelope * 0.75;
                        }
                        const inhale = audioContext.createBufferSource();
                        inhale.buffer = inhaleBuffer;
                        const inhaleFilter = audioContext.createBiquadFilter();
                        inhaleFilter.type = 'bandpass';
                        inhaleFilter.frequency.value = 240 + Math.random() * 220;
                        inhaleFilter.Q.value = 3.5;
                        const inhaleGain = audioContext.createGain();
                        inhale.connect(inhaleFilter);
                        inhaleFilter.connect(inhaleGain);
                        inhaleGain.connect(audioContext.destination);
                        const t = audioContext.currentTime;
                        inhaleGain.gain.setValueAtTime(0, t);
                        inhaleGain.gain.linearRampToValueAtTime(0.25, t + 1);
                        inhaleGain.gain.linearRampToValueAtTime(0, t + 1.6);
                        inhaleFilter.frequency.linearRampToValueAtTime(360, t + 0.8);
                        inhale.start(t);
                        setTimeout(() => {
                            const exhaleBuffer = audioContext.createBuffer(1, 33075, audioContext.sampleRate);
                            const exhaleData = exhaleBuffer.getChannelData(0);
                            for (let j = 0; j < 33075; j++) {
                                const envelope = Math.sin((j / 33075) * Math.PI);
                                exhaleData[j] = (Math.random() * 2 - 1) * envelope * 0.65;
                            }
                            const exhale = audioContext.createBufferSource();
                            exhale.buffer = exhaleBuffer;
                            const exhaleFilter = audioContext.createBiquadFilter();
                            exhaleFilter.type = 'bandpass';
                            exhaleFilter.frequency.value = 190 + Math.random() * 160;
                            exhaleFilter.Q.value = 2.8;
                            const exhaleGain = audioContext.createGain();
                            exhale.connect(exhaleFilter);
                            exhaleFilter.connect(exhaleGain);
                            exhaleGain.connect(audioContext.destination);
                            const t2 = audioContext.currentTime;
                            exhaleGain.gain.setValueAtTime(0, t2);
                            exhaleGain.gain.linearRampToValueAtTime(0.2, t2 + 0.7);
                            exhaleGain.gain.linearRampToValueAtTime(0, t2 + 2);
                            exhaleFilter.frequency.linearRampToValueAtTime(170, t2 + 1.4);
                            exhale.start(t2);
                            try {
                                exhale.stop(t2 + 2);
                            } catch(e) {}
                        }, 1600);
                        try {
                            inhale.stop(t + 1.6);
                        } catch(e) {}
                    }, i * 4000);
                }
            }
            else if (type === 'scrub') {
                const noiseBuffer = audioContext.createBuffer(1, 22050, audioContext.sampleRate);
                const noiseData = noiseBuffer.getChannelData(0);
                for (let i = 0; i < 22050; i++) {
                    const cycle = Math.floor(i / 2000);
                    const intensity = 0.75 + Math.sin(cycle * 0.5) * 0.25;
                    noiseData[i] = (Math.random() * 2 - 1) * intensity;
                }
                const noise = audioContext.createBufferSource();
                noise.buffer = noiseBuffer;
                noise.playbackRate.value = 0.75 + Math.random() * 0.5;
                const filter1 = audioContext.createBiquadFilter();
                filter1.type = 'highpass';
                filter1.frequency.value = 580 + Math.random() * 450;
                filter1.Q.value = 3.5;
                const filter2 = audioContext.createBiquadFilter();
                filter2.type = 'bandpass';
                filter2.frequency.value = 1900 + Math.random() * 1600;
                filter2.Q.value = 10;
                const gain = audioContext.createGain();
                noise.connect(filter1);
                filter1.connect(filter2);
                filter2.connect(gain);
                gain.connect(audioContext.destination);
                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(0.14, now + 0.1);
                gain.gain.linearRampToValueAtTime(0.1, now + 0.3);
                gain.gain.linearRampToValueAtTime(0.14, now + 0.4);
                gain.gain.linearRampToValueAtTime(0, now + 0.6);
                const lfo = audioContext.createOscillator();
                const lfoGain = audioContext.createGain();
                lfo.frequency.value = 5.5 + Math.random() * 4.5;
                lfoGain.gain.value = 350;
                lfo.connect(lfoGain);
                lfoGain.connect(filter2.frequency);
                noise.start(now);
                lfo.start(now);
                setTimeout(() => {
                    try {
                        noise.stop();
                        lfo.stop();
                    } catch(e) {}
                }, 600);
                if (navigator.vibrate) {
                    navigator.vibrate([90, 50, 90, 50, 90]);
                }
            }
            else if (type === 'tear') {
                const tearBuffer = audioContext.createBuffer(1, 11025, audioContext.sampleRate);
                const tearData = tearBuffer.getChannelData(0);
                for (let i = 0; i < 11025; i++) {
                    const progress = i / 11025;
                    const intensity = Math.pow(progress, 0.3) * (1 - progress);
                    const fiber = Math.sin(i * 0.3) * 0.35;
                    tearData[i] = ((Math.random() * 2 - 1) * 0.75 + fiber) * intensity;
                }
                const tear = audioContext.createBufferSource();
                tear.buffer = tearBuffer;
                tear.playbackRate.value = 0.65 + Math.random() * 0.35;
                const tearFilter1 = audioContext.createBiquadFilter();
                tearFilter1.type = 'highpass';
                tearFilter1.frequency.value = 380;
                tearFilter1.Q.value = 3.5;
                const tearFilter2 = audioContext.createBiquadFilter();
                tearFilter2.type = 'bandpass';
                tearFilter2.frequency.value = 1150;
                tearFilter2.Q.value = 10;
                const tearGain = audioContext.createGain();
                tear.connect(tearFilter1);
                tearFilter1.connect(tearFilter2);
                tearFilter2.connect(tearGain);
                tearGain.connect(audioContext.destination);
                tearGain.gain.setValueAtTime(0.18, now);
                tearGain.gain.linearRampToValueAtTime(0.1, now + 0.18);
                tearGain.gain.exponentialRampToValueAtTime(0.01, now + 0.45);
                tearFilter2.frequency.linearRampToValueAtTime(580, now + 0.45);
                tear.start(now);
                try {
                    tear.stop(now + 0.45);
                } catch(e) {}
                if (navigator.vibrate) {
                    navigator.vibrate([70, 35, 100]);
                }
            }
            else if (type === 'scream') {
                const screamBuffer1 = audioContext.createBuffer(1, 22050, audioContext.sampleRate);
                const screamData1 = screamBuffer1.getChannelData(0);
                for (let i = 0; i < 22050; i++) {
                    const envelope = Math.sin((i / 22050) * Math.PI * 2);
                    const chaos = Math.sin(i * 0.05) * Math.sin(i * 0.012);
                    screamData1[i] = (Math.random() * 2 - 1) * Math.abs(envelope) * (0.85 + chaos * 0.15);
                }
                const scream1 = audioContext.createBufferSource();
                scream1.buffer = screamBuffer1;
                scream1.playbackRate.value = 1.15 + Math.random() * 0.35;
                const screamFilter1 = audioContext.createBiquadFilter();
                screamFilter1.type = 'bandpass';
                screamFilter1.frequency.value = 1750;
                screamFilter1.Q.value = 18;
                const screamGain1 = audioContext.createGain();
                scream1.connect(screamFilter1);
                screamFilter1.connect(screamGain1);
                screamGain1.connect(audioContext.destination);
                screamGain1.gain.setValueAtTime(0, now);
                screamGain1.gain.linearRampToValueAtTime(0.2, now + 0.1);
                screamGain1.gain.linearRampToValueAtTime(0.16, now + 0.35);
                screamGain1.gain.exponentialRampToValueAtTime(0.01, now + 0.7);
                screamFilter1.frequency.exponentialRampToValueAtTime(750, now + 0.7);
                const screamBuffer2 = audioContext.createBuffer(1, 11025, audioContext.sampleRate);
                const screamData2 = screamBuffer2.getChannelData(0);
                for (let i = 0; i < 11025; i++) {
                    const envelope = i < 2200 ? 1 : Math.exp(-(i - 2200) / 2200);
                    screamData2[i] = (Math.random() * 2 - 1) * envelope;
                }
                const scream2 = audioContext.createBufferSource();
                scream2.buffer = screamBuffer2;
                const screamFilter2 = audioContext.createBiquadFilter();
                screamFilter2.type = 'highpass';
                screamFilter2.frequency.value = 2900;
                screamFilter2.Q.value = 10;
                const screamGain2 = audioContext.createGain();
                scream2.connect(screamFilter2);
                screamFilter2.connect(screamGain2);
                screamGain2.connect(audioContext.destination);
                screamGain2.gain.setValueAtTime(0.14, now);
                screamGain2.gain.exponentialRampToValueAtTime(0.01, now + 0.35);
                scream1.start(now);
                scream2.start(now);
                try {
                    scream1.stop(now + 0.7);
                    scream2.stop(now + 0.35);
                } catch(e) {}
                if (navigator.vibrate) {
                    navigator.vibrate([170, 60, 220, 60, 170]);
                }
            }
            else if (type === 'crack') {
                const crackBuffer = audioContext.createBuffer(1, 2205, audioContext.sampleRate);
                const crackData = crackBuffer.getChannelData(0);
                for (let i = 0; i < 2205; i++) {
                    const envelope = i < 120 ? 1 : Math.exp(-(i - 120) / 320);
                    crackData[i] = (Math.random() * 2 - 1) * envelope;
                }
                const crack = audioContext.createBufferSource();
                crack.buffer = crackBuffer;
                const crackFilter1 = audioContext.createBiquadFilter();
                crackFilter1.type = 'highpass';
                crackFilter1.frequency.value = 780;
                crackFilter1.Q.value = 4.5;
                const crackFilter2 = audioContext.createBiquadFilter();
                crackFilter2.type = 'bandpass';
                crackFilter2.frequency.value = 2400 + Math.random() * 1600;
                crackFilter2.Q.value = 14;
                const crackGain = audioContext.createGain();
                crack.connect(crackFilter1);
                crackFilter1.connect(crackFilter2);
                crackFilter2.connect(crackGain);
                crackGain.connect(audioContext.destination);
                crackGain.gain.setValueAtTime(0.4, now);
                crackGain.gain.exponentialRampToValueAtTime(0.01, now + 0.18);
                crack.start(now);
                const thumpBuffer = audioContext.createBuffer(1, 4410, audioContext.sampleRate);
                const thumpData = thumpBuffer.getChannelData(0);
                for (let i = 0; i < 4410; i++) {
                    const envelope = Math.exp(-i / 850);
                    thumpData[i] = (Math.random() * 2 - 1) * envelope * 0.65;
                }
                const thump = audioContext.createBufferSource();
                thump.buffer = thumpBuffer;
                const thumpFilter = audioContext.createBiquadFilter();
                thumpFilter.type = 'lowpass';
                thumpFilter.frequency.value = 140;
                thumpFilter.Q.value = 7;
                const thumpGain = audioContext.createGain();
                thump.connect(thumpFilter);
                thumpFilter.connect(thumpGain);
                thumpGain.connect(audioContext.destination);
                thumpGain.gain.setValueAtTime(0.35, now);
                thumpGain.gain.exponentialRampToValueAtTime(0.01, now + 0.22);
                thump.start(now);
                try {
                    crack.stop(now + 0.18);
                    thump.stop(now + 0.22);
                } catch(e) {}
                if (navigator.vibrate) {
                    navigator.vibrate([130, 35, 90]);
                }
            }
        }

        // Prevent right-click
        document.addEventListener('contextmenu', e => e.preventDefault());
        // Prevent escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && document.getElementById('experience').style.display === 'block') {
                e.preventDefault();
            }
        });
    </script>
</body>
</html>
