<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>ВОДА</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Courier+Prime:wght@400;700&display=swap');
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            background: #000; 
            color: #fff; 
            font-family: 'Courier Prime', monospace; 
            overflow: hidden; 
            user-select: none;
            -webkit-user-select: none;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
            cursor: none;
        }
        
        /* HYPNOTIC CURSOR */
        #cursor { 
            position: fixed; 
            width: 20px; 
            height: 20px; 
            border: 1px solid rgba(80,0,0,0.4); 
            border-radius: 50%; 
            pointer-events: none; 
            z-index: 10000; 
            transition: all 0.08s ease-out;
            will-change: transform;
            mix-blend-mode: difference;
        }
        #cursor::before {
            content: '';
            position: absolute;
            width: 6px;
            height: 6px;
            background: rgba(139,0,0,0.5);
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: all 0.15s;
        }
        #cursor.watching {
            width: 80px;
            height: 80px;
            border-color: rgba(139,0,0,0.95);
            border-width: 2px;
            animation: watchingBreath 3s infinite;
        }
        #cursor.watching::before {
            width: 35px;
            height: 35px;
            background: rgba(139,0,0,0.8);
            animation: pupilContract 4s infinite;
        }
        @keyframes watchingBreath {
            0%, 100% { transform: scale(1); opacity: 0.6; }
            50% { transform: scale(1.15); opacity: 0.95; }
        }
        @keyframes pupilContract {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            30% { transform: translate(-50%, -50%) scale(0.6); }
            50% { transform: translate(-50%, -50%) scale(1.3); }
            70% { transform: translate(-50%, -50%) scale(0.8); }
        }
        #cursor.forced {
            border-color: rgba(139,0,0,0.9);
            border-width: 2px;
            animation: forcedPulse 0.6s infinite;
        }
        @keyframes forcedPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.4); }
        }
        
        @media (hover: none) and (pointer: coarse) {
            #cursor { display: none; }
        }
        
        /* CURSOR TRAIL */
        .cursor-trail {
            position: fixed;
            width: 3px;
            height: 3px;
            background: rgba(80, 0, 0, 0.5);
            border-radius: 50%;
            pointer-events: none;
            z-index: 9999;
            animation: trailFade 0.8s forwards;
        }
        @keyframes trailFade {
            to { opacity: 0; transform: scale(0); }
        }
        
        /* HYPNOTIC WARNING SCREEN */
        #warning { 
            position: fixed; 
            top: 0; left: 0; 
            width: 100%; height: 100%; 
            background: #000; 
            display: flex; 
            flex-direction: column; 
            justify-content: center; 
            align-items: center; 
            z-index: 10000; 
            padding: 20px;
            animation: warningPulse 8s infinite;
        }
        @keyframes warningPulse {
            0%, 100% { background: #000; }
            50% { background: #0a0000; }
        }
        
        #warning-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            max-width: 800px;
            opacity: 0;
            animation: hypnoticFadeIn 4s forwards;
        }
        @keyframes hypnoticFadeIn {
            0% { opacity: 0; transform: scale(0.95); }
            100% { opacity: 1; transform: scale(1); }
        }
        
        #warning h1 { 
            font-size: clamp(28px, 6vw, 56px);
            margin-bottom: 40px; 
            text-align: center; 
            color: #3a0000; 
            letter-spacing: clamp(3px, 1vw, 8px);
            animation: titleBreath 6s infinite;
            text-shadow: 0 0 30px rgba(58,0,0,0.6);
            font-weight: 400;
        }
        @keyframes titleBreath {
            0%, 100% { 
                opacity: 0.7; 
                letter-spacing: clamp(3px, 1vw, 8px);
                text-shadow: 0 0 20px rgba(58,0,0,0.4);
            }
            50% { 
                opacity: 0.95; 
                letter-spacing: clamp(5px, 1.5vw, 12px);
                text-shadow: 0 0 40px rgba(58,0,0,0.8);
            }
        }
        
        #warning p { 
            font-size: clamp(14px, 2vw, 18px);
            text-align: center; 
            line-height: 1.9; 
            margin-bottom: 18px; 
            color: #2a2a2a; 
            opacity: 0;
            animation: lineAppear 1s forwards;
            animation-delay: var(--delay, 0s);
        }
        @keyframes lineAppear {
            to { opacity: 0.8; }
        }
        
        #warning .critical {
            color: #3a0000;
            font-size: clamp(16px, 3vw, 24px);
            font-weight: 400;
            margin-top: 35px;
            margin-bottom: 10px;
            letter-spacing: 2px;
            animation: criticalPulse 4s infinite;
        }
        @keyframes criticalPulse {
            0%, 100% { 
                opacity: 0.6;
                text-shadow: 0 0 10px rgba(58,0,0,0.3);
            }
            50% { 
                opacity: 0.95;
                text-shadow: 0 0 25px rgba(58,0,0,0.7);
            }
        }
        
        #warning .epilepsy-warning {
            color: #2a0000;
            font-size: clamp(15px, 2.5vw, 20px);
            font-weight: 700;
            margin-bottom: 8px;
            opacity: 0;
            animation: epilepsyWarning 2s infinite;
        }
        @keyframes epilepsyWarning {
            0%, 100% { opacity: 0.7; }
            50% { opacity: 0.95; }
        }
        
        #warning .subliminal {
            font-size: clamp(10px, 1.5vw, 12px);
            color: #1a1a1a;
            margin-top: 25px;
            opacity: 0.25;
            line-height: 1.6;
        }
        
        #warning button { 
            font-family: 'Courier Prime', monospace; 
            font-size: clamp(15px, 2.5vw, 22px);
            padding: clamp(12px, 2.5vw, 20px) clamp(25px, 6vw, 60px);
            background: #000; 
            color: #3a0000; 
            border: 1px solid #2a0000; 
            cursor: pointer; 
            margin-top: 45px;
            transition: all 0.4s; 
            letter-spacing: clamp(2px, 0.8vw, 4px);
            min-height: 50px;
            touch-action: manipulation;
            font-weight: 400;
            opacity: 0;
            animation: buttonAppear 2s forwards 3s;
        }
        @keyframes buttonAppear {
            to { opacity: 0.7; }
        }
        
        #warning button:hover, #warning button:active { 
            background: #0a0000; 
            color: #4a0000; 
            border-color: #3a0000;
            box-shadow: 0 0 30px rgba(58,0,0,0.4);
            opacity: 1;
        }
        
        /* EXPERIENCE CONTAINER */
        #experience { 
            display: none; 
            position: fixed; 
            top: 0; left: 0; 
            width: 100%; height: 100%; 
            background: #000; 
        }
        
        #content { 
            position: absolute; 
            top: 50%; 
            left: 50%; 
            transform: translate(-50%, -50%); 
            width: 90%; 
            max-width: 1000px; 
            text-align: center;
            padding: 0 15px;
            z-index: 1000;
        }
        
        /* HYPNOTIC TEXT STYLES */
        .line { 
            font-size: clamp(24px, 4.8vw, 42px);
            line-height: 2.2; 
            color: #b8b8b8; 
            opacity: 0; 
            margin: 0; 
            letter-spacing: clamp(1px, 0.6vw, 3px);
            position: relative;
            text-shadow: 0 0 25px rgba(184,184,184,0.3), 2px 2px 4px rgba(0,0,0,0.8);
        }
        .line.active { 
            animation: hypnoticAppear 1.2s forwards; 
        }
        @keyframes hypnoticAppear {
            0% { 
                opacity: 0; 
                transform: scale(0.92); 
                filter: blur(8px);
            }
            70% {
                opacity: 1;
                transform: scale(1.02);
                filter: blur(0);
            }
            100% { 
                opacity: 1; 
                transform: scale(1); 
                filter: blur(0);
            }
        }
        
        .line.blood { 
            color: #5a0000; 
            font-weight: 700; 
            text-shadow: 0 0 25px rgba(90, 0, 0, 0.7); 
            animation: bloodPulse 3s infinite;
        }
        @keyframes bloodPulse {
            0%, 100% { 
                opacity: 0.8;
                text-shadow: 0 0 20px rgba(90, 0, 0, 0.6);
            }
            50% { 
                opacity: 1;
                text-shadow: 0 0 35px rgba(90, 0, 0, 0.9);
            }
        }
        
        .line .cold { 
            color: #2a4a5a; 
            text-shadow: 0 0 12px rgba(42, 74, 90, 0.5); 
            letter-spacing: clamp(2px, 0.8vw, 5px);
        }
        .line .pain { 
            color: #6a0000; 
            text-shadow: 0 0 18px rgba(106, 0, 0, 0.8); 
            font-weight: 700; 
        }
        .line .death { 
            color: #5a0000; 
            text-shadow: 0 0 30px rgba(90, 0, 0, 0.95); 
            letter-spacing: clamp(4px, 1.2vw, 7px);
            font-weight: 700;
            font-size: clamp(26px, 5vw, 42px);
            animation: deathPulse 2s ease-in-out infinite;
        }
        @keyframes deathPulse {
            0%, 100% { 
                opacity: 0.9;
                transform: scale(1);
                text-shadow: 0 0 25px rgba(90, 0, 0, 0.8);
            }
            50% { 
                opacity: 1;
                transform: scale(1.08);
                text-shadow: 0 0 45px rgba(138, 0, 0, 1);
            }
        }
        .line .scream { 
            color: #8a0000; 
            text-shadow: 0 0 30px rgba(138, 0, 0, 0.95); 
            animation: screamIntensity 0.12s infinite; 
            font-weight: 700;
        }
        @keyframes screamIntensity {
            0%, 100% { 
                opacity: 1; 
                text-shadow: 0 0 25px rgba(138, 0, 0, 0.9); 
                transform: scale(1);
            }
            50% { 
                opacity: 0.4; 
                text-shadow: 0 0 45px rgba(138, 0, 0, 1); 
                transform: scale(1.03);
            }
        }
        .line .void { 
            color: #4a0000; 
            opacity: 0.9; 
            letter-spacing: clamp(5px, 1.4vw, 9px);
            text-shadow: 0 0 25px rgba(74, 0, 0, 0.9);
            font-weight: 700;
            font-size: clamp(26px, 5vw, 42px);
            animation: voidPulse 2.5s ease-in-out infinite;
        }
        @keyframes voidPulse {
            0%, 100% { 
                opacity: 0.85;
                transform: scale(1);
                text-shadow: 0 0 20px rgba(74, 0, 0, 0.8);
            }
            50% { 
                opacity: 1;
                transform: scale(1.06);
                text-shadow: 0 0 40px rgba(106, 0, 0, 1);
            }
        }
        .line .machine-word { 
            color: #5a5a5a; 
            letter-spacing: 3px; 
            font-weight: 700; 
            text-shadow: 0 0 10px rgba(90, 90, 90, 0.6);
        }
        .line .filth { 
            color: #3a2a1a; 
            text-shadow: 0 0 12px rgba(58, 42, 26, 0.7); 
        }
        
        /* BREAKING FOURTH WALL - INTENSE */
        .line.break-wall {
            color: #ddd !important;
            font-size: clamp(26px, 5.5vw, 52px) !important;
            text-shadow: 0 0 40px rgba(221,221,221,0.4);
            animation: breakWallHypnotic 0.4s forwards, textHypnoticBreath 4s infinite;
            z-index: 1000;
            font-weight: 700;
            letter-spacing: clamp(2px, 1vw, 6px);
        }
        @keyframes breakWallHypnotic {
            0% { 
                opacity: 0; 
                transform: scale(0.85); 
                filter: blur(15px);
            }
            60% {
                opacity: 1;
                transform: scale(1.08);
                filter: blur(0);
            }
            100% { 
                opacity: 1; 
                transform: scale(1); 
                filter: blur(0);
            }
        }
        @keyframes textHypnoticBreath {
            0%, 100% { 
                transform: scale(1); 
                text-shadow: 0 0 30px rgba(221,221,221,0.3);
            }
            50% { 
                transform: scale(1.04); 
                text-shadow: 0 0 50px rgba(221,221,221,0.6);
            }
        }
        
        /* GLITCH - MORE INTENSE */
        .line.glitched {
            animation: textGlitchIntense 0.15s infinite;
        }
        @keyframes textGlitchIntense {
            0% { 
                transform: translate(0);
                text-shadow: -4px 0 #6a0000, 4px 0 #006a6a;
                filter: hue-rotate(0deg) contrast(1.2);
            }
            20% {
                transform: translate(-7px, 4px);
                text-shadow: -8px 0 #8a0000, 8px 0 #008a8a;
                filter: hue-rotate(90deg) contrast(1.4);
            }
            40% {
                transform: translate(7px, -4px);
                text-shadow: 8px 0 #8a0000, -8px 0 #008a8a;
                filter: hue-rotate(180deg) contrast(1.6);
            }
            60% {
                transform: translate(-4px, -3px);
                text-shadow: -6px 0 #8a0000, 6px 0 #008a8a;
                filter: hue-rotate(270deg) contrast(1.3);
            }
            80% {
                transform: translate(4px, 3px);
                text-shadow: 6px 0 #8a0000, -6px 0 #008a8a;
                filter: hue-rotate(360deg) contrast(1.5);
            }
            100% {
                transform: translate(0);
                text-shadow: -4px 0 #6a0000, 4px 0 #006a6a;
                filter: hue-rotate(0deg) contrast(1.2);
            }
        }
        
        /* DISTORTION - MORE ORGANIC */
        .line.distorted {
            animation: distortOrganic 0.5s;
        }
        @keyframes distortOrganic {
            0%, 100% { 
                transform: scale(1, 1) skew(0deg); 
                letter-spacing: clamp(1px, 0.6vw, 3px);
                opacity: 1;
            }
            20% { 
                transform: scale(1.15, 0.85) skew(-2deg); 
                letter-spacing: clamp(6px, 2vw, 10px);
                opacity: 0.8;
            }
            40% { 
                transform: scale(0.85, 1.15) skew(2deg); 
                letter-spacing: clamp(0px, 0.1vw, 0.5px);
                opacity: 0.9;
            }
            60% { 
                transform: scale(1.08, 0.92) skew(-1deg); 
                letter-spacing: clamp(3px, 1.2vw, 6px);
                opacity: 0.85;
            }
            80% { 
                transform: scale(0.92, 1.08) skew(1deg); 
                letter-spacing: clamp(2px, 0.8vw, 4px);
                opacity: 0.95;
            }
        }
        
        /* SHAKE - MORE VIOLENT */
        .shake { 
            animation: shakeViolent 0.5s; 
        }
        @keyframes shakeViolent { 
            0%, 100% { transform: translate(-50%, -50%); } 
            10% { transform: translate(calc(-50% - 30px), calc(-50% + 15px)) rotate(-2deg); } 
            20% { transform: translate(calc(-50% + 35px), calc(-50% - 12px)) rotate(2deg); } 
            30% { transform: translate(calc(-50% - 28px), calc(-50% + 18px)) rotate(-1deg); } 
            40% { transform: translate(calc(-50% + 32px), calc(-50% - 15px)) rotate(1.5deg); } 
            50% { transform: translate(calc(-50% - 25px), calc(-50% + 10px)) rotate(-1.5deg); } 
            60% { transform: translate(calc(-50% + 28px), calc(-50% - 8px)) rotate(1deg); } 
            70% { transform: translate(calc(-50% - 20px), calc(-50% + 12px)) rotate(-1deg); } 
            80% { transform: translate(calc(-50% + 22px), calc(-50% - 10px)) rotate(0.5deg); } 
            90% { transform: translate(calc(-50% - 15px), calc(-50% + 8px)) rotate(-0.5deg); } 
        }
        
        /* VISUAL EFFECTS - ENHANCED */
        .text-trail { animation: trailIntense 1.2s; }
        @keyframes trailIntense { 
            0% { 
                text-shadow: 12px 0 20px currentColor, 
                             24px 0 35px currentColor, 
                             36px 0 50px currentColor; 
                opacity: 1;
            } 
            100% { 
                text-shadow: 0 0 0 transparent; 
                opacity: 1;
            } 
        }
        
        .double-vision { animation: doubleVisionIntense 0.5s; }
        @keyframes doubleVisionIntense { 
            0%, 100% { text-shadow: 0 0 0 transparent; } 
            50% { 
                text-shadow: 15px 0 0 rgba(80,80,80,0.7), 
                             -15px 0 0 rgba(80,80,80,0.7); 
            } 
        }
        
        .time-freeze { animation: freezeIntense 2.5s; }
        @keyframes freezeIntense { 
            0%, 100% { opacity: 1; filter: blur(0) brightness(1) contrast(1); } 
            50% { opacity: 0.15; filter: blur(8px) brightness(0.3) contrast(1.5); } 
        }
        
        /* BLACKOUT - DEEPER */
        .blackout {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: #000;
            opacity: 0;
            pointer-events: none;
            z-index: 500;
        }
        .blackout.active {
            animation: blackoutDeep 0.2s forwards;
        }
        @keyframes blackoutDeep {
            to { opacity: 1; }
        }
        
        /* STROBE - MORE VIOLENT */
        .strobe {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: #fff;
            opacity: 0;
            pointer-events: none;
            z-index: 550;
        }
        .strobe.active {
            animation: strobeViolent 0.03s infinite;
        }
        @keyframes strobeViolent {
            0%, 100% { opacity: 0; }
            50% { opacity: 0.95; }
        }
        
        /* CHROMATIC - MORE INTENSE */
        .chromatic {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            z-index: 560;
            opacity: 0;
            mix-blend-mode: screen;
        }
        .chromatic.active {
            animation: chromaticIntense 0.2s infinite;
            opacity: 0.75;
        }
        @keyframes chromaticIntense {
            0% { 
                background: radial-gradient(circle, rgba(139,0,0,0.5) 0%, transparent 40%);
                transform: translate(-5px, 0);
            }
            50% { 
                background: radial-gradient(circle, rgba(0,139,139,0.5) 0%, transparent 40%);
                transform: translate(5px, 0);
            }
            100% { 
                background: radial-gradient(circle, rgba(139,0,0,0.5) 0%, transparent 40%);
                transform: translate(-5px, 0);
            }
        }
        
        /* WATER/BLOOD DROPS - ENHANCED */
        .water-drop {
            position: fixed;
            width: 3px;
            background: linear-gradient(to bottom, transparent, rgba(42, 74, 90, 0.8), transparent);
            pointer-events: none;
            z-index: 610;
            opacity: 0;
        }
        .water-drop.active {
            animation: dropFallSlow 3s linear forwards;
        }
        @keyframes dropFallSlow {
            0% { 
                opacity: 0;
                top: -10px;
            }
            15% {
                opacity: 0.9;
            }
            100% {
                opacity: 0.4;
                top: 100%;
            }
        }
        
        .blood-drop {
            position: fixed;
            width: 4px;
            background: linear-gradient(to bottom, transparent, rgba(90, 0, 0, 0.95), rgba(90, 0, 0, 0.5));
            pointer-events: none;
            z-index: 620;
            opacity: 0;
        }
        .blood-drop.active {
            animation: bloodDripSlow 4s ease-in forwards;
        }
        @keyframes bloodDripSlow {
            0% { 
                opacity: 0;
                top: -20px;
            }
            12% {
                opacity: 1;
            }
            100% {
                opacity: 0.7;
                top: 100%;
                filter: blur(1.5px);
            }
        }
        
        /* FOG BREATH */
        .breath-fog {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 400px;
            height: 400px;
            background: radial-gradient(circle, rgba(100,100,100,0.08) 0%, transparent 65%);
            border-radius: 50%;
            pointer-events: none;
            opacity: 0;
            z-index: 630;
            filter: blur(30px);
        }
        .breath-fog.active {
            animation: breathFogSlow 5s ease-in-out forwards;
        }
        @keyframes breathFogSlow {
            0% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.4);
            }
            35% {
                opacity: 0.5;
                transform: translate(-50%, -50%) scale(1);
            }
            100% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(1.8);
            }
        }
        
        /* SCREEN CRACK */
        .screen-crack {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            opacity: 0;
            z-index: 640;
            background: 
                linear-gradient(45deg, transparent 48%, rgba(90,90,90,0.25) 49%, rgba(90,90,90,0.25) 51%, transparent 52%),
                linear-gradient(-45deg, transparent 48%, rgba(80,80,80,0.2) 49%, rgba(80,80,80,0.2) 51%, transparent 52%),
                linear-gradient(23deg, transparent 48%, rgba(70,70,70,0.15) 49%, rgba(70,70,70,0.15) 51%, transparent 52%);
        }
        .screen-crack.active {
            animation: crackAppearSlow 0.4s forwards;
        }
        @keyframes crackAppearSlow {
            0% {
                opacity: 0;
                transform: scale(0.85);
            }
            60% {
                opacity: 1;
                transform: scale(1.1);
            }
            100% {
                opacity: 0.4;
                transform: scale(1);
            }
        }
        
        /* WET STAINS */
        .wet-stain {
            position: fixed;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(30,30,50,0.4) 0%, transparent 65%);
            pointer-events: none;
            opacity: 0;
            z-index: 650;
            filter: blur(8px);
        }
        .wet-stain.active {
            animation: stainSpreadSlow 4s ease-out forwards;
        }
        @keyframes stainSpreadSlow {
            0% {
                opacity: 0;
                transform: scale(0);
            }
            35% {
                opacity: 0.7;
            }
            100% {
                opacity: 0.4;
                transform: scale(1);
            }
        }
        
        /* OVERLAYS - OPPRESSIVE */
        .breath-overlay { 
            position: fixed; 
            top: 0; left: 0; 
            width: 100%; height: 100%; 
            background: radial-gradient(circle, transparent 10%, #000 100%); 
            pointer-events: none; 
            animation: breatheOppressive 7s infinite; 
            z-index: 100; 
            opacity: 0.3;
        }
        @keyframes breatheOppressive { 
            0%, 100% { 
                opacity: 0.2; 
                transform: scale(1); 
            } 
            50% { 
                opacity: 0.85; 
                transform: scale(1.05); 
            } 
        }
        
        .vignette { 
            position: fixed; 
            top: 0; left: 0; 
            width: 100%; height: 100%; 
            box-shadow: inset 0 0 500px rgba(0,0,0,0.95); 
            pointer-events: none; 
            z-index: 50; 
            transition: box-shadow 4s; 
        }
        
        .static { 
            position: fixed; 
            top: 0; left: 0; 
            width: 100%; height: 100%; 
            pointer-events: none; 
            opacity: 0.12; 
            z-index: 200; 
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 400 400' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)'/%3E%3C/svg%3E"); 
            animation: staticMoveErratic 0.15s steps(12) infinite; 
            transition: opacity 4s; 
        }
        @keyframes staticMoveErratic { 
            0% { transform: translate(0, 0); } 
            20% { transform: translate(-6%, 6%); } 
            40% { transform: translate(6%, -6%); } 
            60% { transform: translate(-5%, -5%); }
            80% { transform: translate(5%, 5%); } 
            100% { transform: translate(-3%, 3%); } 
        }
        
        .blood-screen { 
            position: fixed; 
            top: 0; left: 0; 
            width: 100%; height: 100%; 
            background: radial-gradient(circle at center, transparent 0%, rgba(90,0,0,0.6) 100%); 
            pointer-events: none; 
            opacity: 0; 
            z-index: 150; 
            transition: opacity 2.5s; 
        }
        .blood-screen.active { opacity: 1; }
        
        .red-flicker { 
            position: fixed; 
            top: 0; left: 0; 
            width: 100%; height: 100%; 
            background: rgba(90, 0, 0, 0.3); 
            pointer-events: none; 
            opacity: 0; 
            z-index: 80; 
        }
        .red-flicker.active { animation: redFlickerIntense 0.06s infinite; }
        @keyframes redFlickerIntense { 
            0%, 100% { opacity: 0; } 
            50% { opacity: 0.35; } 
        }
        
        /* PERIPHERAL HORROR */
        .peripheral-horror {
            position: fixed;
            width: 180px;
            height: 100%;
            pointer-events: none;
            opacity: 0;
            z-index: 130;
            background: radial-gradient(circle, rgba(15,0,0,0.98) 0%, transparent 75%);
        }
        .peripheral-horror.left { left: 0; top: 0; }
        .peripheral-horror.right { right: 0; top: 0; }
        .peripheral-horror.active {
            animation: peripheralFlashIntense 0.15s;
        }
        @keyframes peripheralFlashIntense {
            0%, 100% { opacity: 0; }
            50% { opacity: 0.95; }
        }
        
        /* SHADOWS */
        .shadow { 
            position: fixed; 
            width: 300px; 
            height: 100%; 
            background: radial-gradient(circle, rgba(0,0,0,0.99) 0%, transparent 65%); 
            pointer-events: none; 
            opacity: 0; 
            z-index: 120; 
        }
        .shadow.left { left: 0; top: 0; }
        .shadow.right { right: 0; top: 0; }
        .shadow.active { animation: shadowPassSlow 3s; }
        @keyframes shadowPassSlow { 
            0%, 100% { opacity: 0; } 
            50% { opacity: 0.98; } 
        }
        
        /* GRAIN */
        .grain { 
            position: fixed; 
            top: 0; left: 0; 
            width: 100%; height: 100%; 
            pointer-events: none; 
            opacity: 0; 
            z-index: 210; 
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='grainFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='3' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23grainFilter)' opacity='0.4'/%3E%3C/svg%3E"); 
            animation: grainMoveErratic 0.08s steps(10) infinite; 
            transition: opacity 4s; 
        }
        @keyframes grainMoveErratic { 
            0% { transform: translate(0, 0); } 
            25% { transform: translate(-4%, 4%); } 
            50% { transform: translate(4%, -4%); } 
            75% { transform: translate(-4%, -4%); } 
            100% { transform: translate(4%, 4%); } 
        }
        
        /* WATCHING YOU */
        .watching-overlay {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            opacity: 0;
            z-index: 600;
            background: radial-gradient(circle at var(--x, 50%) var(--y, 50%), 
                transparent 0%, 
                transparent 10%,
                rgba(90,0,0,0.15) 20%,
                rgba(0,0,0,0.95) 50%);
        }
        .watching-overlay.active {
            animation: watchingPulseSlow 5s;
        }
        @keyframes watchingPulseSlow {
            0%, 100% { opacity: 0; }
            50% { opacity: 1; }
        }
        
        /* SCREEN TEAR */
        .screen-tear {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            opacity: 0;
            z-index: 570;
        }
        .screen-tear.active {
            animation: tearIntense 0.6s;
        }
        @keyframes tearIntense {
            0% { 
                opacity: 0;
                transform: translateY(0);
            }
            12% {
                opacity: 1;
                transform: translateY(-25px);
                background: linear-gradient(transparent 46%, #ddd 46%, #ddd 54%, transparent 54%);
            }
            25% {
                transform: translateY(20px);
                background: linear-gradient(transparent 66%, #ddd 66%, #ddd 74%, transparent 74%);
            }
            38% {
                transform: translateY(-15px);
                background: linear-gradient(transparent 26%, #ddd 26%, #ddd 34%, transparent 34%);
            }
            100% {
                opacity: 0;
                transform: translateY(0);
            }
        }
        
        /* TIME DISTORTION */
        .time-distortion {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            opacity: 0;
            z-index: 580;
        }
        .time-distortion.active {
            animation: timeWarpIntense 4s;
        }
        @keyframes timeWarpIntense {
            0%, 100% { 
                opacity: 0;
                filter: blur(0);
            }
            25% {
                opacity: 0.4;
                filter: blur(15px);
            }
            50% { 
                opacity: 0.7;
                filter: blur(8px);
                background: radial-gradient(circle, transparent 30%, rgba(0,0,30,0.6) 100%);
            }
            75% {
                opacity: 0.4;
                filter: blur(20px);
            }
        }
        
        /* SUBLIMINAL */
        .subliminal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: clamp(36px, 9vw, 84px);
            color: rgba(80, 80, 80, 0.08);
            pointer-events: none;
            opacity: 0;
            z-index: 590;
            font-weight: 700;
            letter-spacing: clamp(3px, 1.5vw, 10px);
        }
        .subliminal.active {
            animation: subliminalFlashQuick 0.04s;
        }
        @keyframes subliminalFlashQuick {
            0%, 100% { opacity: 0; }
            50% { opacity: 0.2; }
        }
        
        /* HEARTBEAT */
        .heartbeat {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(90, 0, 0, 0.15);
            pointer-events: none;
            opacity: 0;
            z-index: 85;
        }
        .heartbeat.active {
            animation: heartbeatPulseSlow 1.4s infinite;
        }
        @keyframes heartbeatPulseSlow {
            0%, 100% { opacity: 0; transform: scale(1); }
            12% { opacity: 0.4; transform: scale(1.015); }
            24% { opacity: 0; transform: scale(1); }
            36% { opacity: 0.5; transform: scale(1.02); }
            48% { opacity: 0; transform: scale(1); }
        }
        
        /* REALITY GLITCH */
        .reality-glitch {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            opacity: 0;
            z-index: 595;
            mix-blend-mode: difference;
        }
        .reality-glitch.active {
            animation: realityBreakIntense 0.4s;
        }
        @keyframes realityBreakIntense {
            0%, 100% { 
                opacity: 0;
                background: transparent;
            }
            20% {
                opacity: 0.9;
                background: repeating-linear-gradient(0deg, #8a0000 0px, #8a0000 2px, #008a8a 2px, #008a8a 4px);
            }
            40% {
                opacity: 0.7;
                background: repeating-linear-gradient(90deg, #008a00 0px, #008a00 3px, #8a008a 3px, #8a008a 6px);
            }
            60% {
                opacity: 0.95;
                background: repeating-linear-gradient(45deg, #8a8a00 0px, #8a8a00 2px, #00008a 2px, #00008a 4px);
            }
        }
        
        /* LIVING OBSESSIVE WORDS SYSTEM */
        .obsessive-word { 
            position: fixed; 
            font-family: 'Courier Prime', monospace; 
            font-size: 14px;
            color: #3a3a3a; 
            pointer-events: none; 
            opacity: 0; 
            z-index: 5; 
            letter-spacing: 1px; 
            font-weight: 400;
            transition: all 0.5s ease-out;
            will-change: transform, opacity;
            filter: blur(2px);
        }
        
        .obsessive-word.spawned {
            animation: wordSpawn 2s ease-out forwards;
        }
        
        @keyframes wordSpawn {
            0% {
                opacity: 0;
                transform: scale(0.5) translateY(-20px);
                filter: blur(5px);
            }
            100% {
                opacity: 0.45;
                transform: scale(1) translateY(0);
                filter: blur(0);
            }
        }
        
        .obsessive-word.drift {
            animation: wordDrift 15s ease-in-out infinite;
        }
        
        @keyframes wordDrift {
            0%, 100% {
                transform: translate(0, 0) rotate(0deg);
            }
            25% {
                transform: translate(var(--dx1, 20px), var(--dy1, 15px)) rotate(var(--r1, 3deg));
            }
            50% {
                transform: translate(var(--dx2, -15px), var(--dy2, 25px)) rotate(var(--r2, -2deg));
            }
            75% {
                transform: translate(var(--dx3, 25px), var(--dy3, -20px)) rotate(var(--r3, 4deg));
            }
        }
        
        .obsessive-word.intense {
            color: #6a0000 !important;
            opacity: 0.8 !important;
            font-weight: 700;
            text-shadow: 0 0 12px rgba(106, 0, 0, 0.7);
            animation: wordIntensePulse 2s ease-in-out infinite;
            filter: blur(1.5px);
        }
        
        @keyframes wordIntensePulse {
            0%, 100% {
                transform: scale(1);
                text-shadow: 0 0 10px rgba(106, 0, 0, 0.6);
            }
            50% {
                transform: scale(1.08);
                text-shadow: 0 0 20px rgba(138, 0, 0, 0.9);
            }
        }
        
        .obsessive-word.forming-pattern {
            transition: all 3s cubic-bezier(0.68, -0.55, 0.27, 1.55) !important;
        }
        
        .obsessive-word.blur-pulse {
            animation: blurPulse 4s ease-in-out infinite;
        }
        
        @keyframes blurPulse {
            0%, 100% {
                filter: blur(0);
                opacity: 0.5;
            }
            50% {
                filter: blur(2.5px);
                opacity: 0.3;
            }
        }
        
        /* KEEP OLD .active FOR COMPATIBILITY */
        .obsessive-word.active { 
            animation: wordSpawn 2s forwards; 
        }
        
        /* PATTERN WORDS - СПЕЦИАЛЬНЫЕ СЛОВА ДЛЯ ОБРАЗОВ */
        .pattern-word { 
            position: fixed; 
            font-family: 'Courier Prime', monospace; 
            font-size: 14px;
            color: #6a0000;
            pointer-events: none; 
            opacity: 0; 
            z-index: 15;
            letter-spacing: 1px; 
            font-weight: 700;
            transition: all 3s cubic-bezier(0.68, -0.55, 0.27, 1.55);
            will-change: transform, opacity;
            text-shadow: 0 0 15px rgba(106, 0, 0, 0.8);
            filter: blur(0.5px);
        }

        .pattern-word.visible {
            opacity: 0.9;
            animation: patternPulse 3s ease-in-out infinite;
        }

        .pattern-word.fading-out {
            opacity: 0 !important;
            transform: scale(0.5);
            transition: all 1s ease-in;
        }

        @keyframes patternPulse {
            0%, 100% {
                text-shadow: 0 0 10px rgba(106, 0, 0, 0.7);
                transform: scale(1);
            }
            50% {
                text-shadow: 0 0 25px rgba(138, 0, 0, 1);
                transform: scale(1.1);
            }
        }
        
        /* FORGOTTEN WORDS */
        .forgotten-word { 
            position: fixed; 
            font-family: 'Courier Prime', monospace; 
            font-size: clamp(11px, 2vw, 16px);
            color: #1a1a1a; 
            pointer-events: none; 
            opacity: 0; 
            z-index: 65; 
            letter-spacing: 1px; 
            filter: blur(8px); 
        }
        .forgotten-word.active { animation: forgottenFadeInSlow 4s forwards; }
        @keyframes forgottenFadeInSlow { 
            0% { 
                opacity: 0; 
                filter: blur(15px); 
                transform: scale(0.7); 
            } 
            100% { 
                opacity: 0.4; 
                filter: blur(8px); 
                transform: scale(1); 
            } 
        }
        
        /* EMERGENCY EXIT - SUBTLE */
        #emergency-exit {
            position: fixed;
            bottom: 10px;
            right: 10px;
            padding: clamp(8px, 1.5vw, 12px) clamp(12px, 2.5vw, 20px);
            background: rgba(30, 0, 0, 0.15);
            color: rgba(80, 80, 80, 0.25);
            border: 1px solid rgba(80, 80, 80, 0.15);
            font-family: 'Courier Prime', monospace;
            font-size: clamp(9px, 1.5vw, 11px);
            cursor: pointer;
            z-index: 11000;
            opacity: 0.2;
            transition: all 0.4s;
            min-height: 40px;
            touch-action: manipulation;
        }
        #emergency-exit:hover, #emergency-exit:active {
            opacity: 0.8;
            background: rgba(50, 0, 0, 0.3);
            border-color: rgba(100, 100, 100, 0.4);
        }
        
        /* ===== ЭФФЕКТЫ КАМЕРЫ ===== */
        .camera-zoom {
            animation: cameraZoom 0.5s ease-out !important;
        }
        
        @keyframes cameraZoom {
            0% { transform: translate(-50%, -50%) scale(0.95); }
            100% { transform: translate(-50%, -50%) scale(1); }
        }
        
        .camera-shake {
            animation: cameraShake 0.3s ease-in-out !important;
        }
        
        @keyframes cameraShake {
            0%, 100% { transform: translate(-50%, -50%); }
            10% { transform: translate(-48%, -52%); }
            20% { transform: translate(-52%, -48%); }
            30% { transform: translate(-49%, -51%); }
            40% { transform: translate(-51%, -49%); }
            50% { transform: translate(-50%, -50%); }
            60% { transform: translate(-49%, -52%); }
            70% { transform: translate(-52%, -49%); }
            80% { transform: translate(-48%, -51%); }
            90% { transform: translate(-51%, -48%); }
        }
        
        /* ===== 25-Й КАДР ===== */
        .subliminal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 48px;
            color: rgba(139, 0, 0, 0.3);
            font-weight: 700;
            pointer-events: none;
            z-index: 500;
            opacity: 0;
            animation: subliminalFlash 0.05s;
            font-family: 'Courier Prime', monospace;
        }
        
        @keyframes subliminalFlash {
            0%, 100% { opacity: 0; }
            50% { opacity: 1; }
        }
        
        /* MOBILE OPTIMIZATIONS */
        @media (max-height: 700px) {
            #warning-content {
                justify-content: flex-start;
                padding-top: 30px;
            }
            #warning h1 {
                margin-bottom: 30px;
            }
            #warning .critical {
                margin-top: 25px;
            }
            #warning button {
                margin-top: 35px;
            }
        }
        
        @media (max-width: 600px) {
            .line {
                line-height: 2;
            }
            #content {
                width: 95%;
            }
        }
    </style>
</head>
<body>
    <div id="cursor"></div>
    
    <div id="warning">
        <div id="warning-content">
            <h1>ПРЕДУПРЕЖДЕНИЕ</h1>
            <p style="--delay: 0.5s">Это опыт полного погружения.</p>
            <p style="--delay: 1s">Вы потеряете контроль.</p>
            <p style="--delay: 1.5s">Опыт будет манипулировать вашим восприятием.</p>
            <p style="--delay: 2s">Он войдёт в ваш разум.</p>
            <p style="--delay: 2.5s">Вы не сможете остановить его.</p>
            <p class="critical">⚠ ПРЕДУПРЕЖДЕНИЕ ⚠</p>
            <p class="epilepsy-warning">ИНТЕНСИВНЫЕ СТРОБОСКОПИЧЕСКИЕ ЭФФЕКТЫ</p>
            <p class="epilepsy-warning">НЕ РЕКОМЕНДУЕТСЯ ПРИ ЭПИЛЕПСИИ</p>
            <p style="margin-top: 30px; color: #2a2a2a; --delay: 3s">Используйте наушники</p>
            <p style="color: #2a2a2a; --delay: 3.5s">Выключите свет</p>
            <p class="critical">Готовы принять последствия?</p>
            <p class="subliminal">Всё что произойдёт дальше — ваш выбор. Вас предупредили.</p>
            <button id="enter">ПРИНИМАЮ</button>
        </div>
    </div>

    <div id="experience">
        <div class="blackout"></div>
        <div class="strobe"></div>
        <div class="chromatic"></div>
        <div class="watching-overlay"></div>
        <div class="breath-overlay"></div>
        <div class="vignette"></div>
        <div class="static"></div>
        <div class="blood-screen"></div>
        <div class="red-flicker"></div>
        <div class="grain"></div>
        <div class="heartbeat"></div>
        <div class="peripheral-horror left"></div>
        <div class="peripheral-horror right"></div>
        <div class="shadow left"></div>
        <div class="shadow right"></div>
        <div class="screen-tear"></div>
        <div class="time-distortion"></div>
        <div class="reality-glitch"></div>
        <div class="subliminal"></div>
        <div class="breath-fog"></div>
        <div class="screen-crack"></div>
        <div id="water-drops"></div>
        <div id="blood-drops"></div>
        <div id="wet-stains"></div>
        <div id="obsessive-words"></div>
        <div id="forgotten-words"></div>
        <div id="content"></div>
        <button id="emergency-exit">ВЫХОД</button>
    </div>

    <script>
        // ===== ЗВУКОВАЯ СИСТЕМА =====
        class SoundSystem {
            constructor() {
                this.context = null;
                this.sounds = {};
                this.pendulumTimeout = null;
                this.machineSource = null;
                this.initialized = false;
            }

            async init() {
                if (this.initialized) return;
                
                this.context = new (window.AudioContext || window.webkitAudioContext)();
                
                // Генерируем звуки процедурно
                this.sounds.crunch = this.createCrunchSound();
                this.sounds.creak = this.createCreakSound();
                this.sounds.machine = this.createMachineSound();
                this.sounds.pendulum = this.createPendulumSound();
                this.sounds.scrub = this.createScrubSound();
                
                this.initialized = true;
            }

            createCrunchSound() {
                const buffer = this.context.createBuffer(1, this.context.sampleRate * 0.3, this.context.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < data.length; i++) {
                    data[i] = (Math.random() * 2 - 1) * Math.exp(-i / (this.context.sampleRate * 0.1));
                }
                return buffer;
            }

            createCreakSound() {
                const buffer = this.context.createBuffer(1, this.context.sampleRate * 0.8, this.context.sampleRate);
                const data = buffer.getChannelData(0);
                let phase = 0;
                for (let i = 0; i < data.length; i++) {
                    const freq = 200 + Math.sin(i / 1000) * 100;
                    phase += (2 * Math.PI * freq) / this.context.sampleRate;
                    data[i] = Math.sin(phase) * 0.3 * Math.exp(-i / (this.context.sampleRate * 0.3));
                }
                return buffer;
            }

            createMachineSound() {
                const buffer = this.context.createBuffer(1, this.context.sampleRate * 2, this.context.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < data.length; i++) {
                    const noise = (Math.random() * 2 - 1) * 0.1;
                    const tone = Math.sin(2 * Math.PI * 120 * i / this.context.sampleRate) * 0.15;
                    data[i] = noise + tone;
                }
                return buffer;
            }

            createPendulumSound() {
                const buffer = this.context.createBuffer(1, this.context.sampleRate * 1.2, this.context.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < data.length; i++) {
                    if (i < this.context.sampleRate * 0.05) {
                        data[i] = Math.sin(2 * Math.PI * 800 * i / this.context.sampleRate) * 0.15 * Math.exp(-i / 500);
                    }
                }
                return buffer;
            }

            createScrubSound() {
                const buffer = this.context.createBuffer(1, this.context.sampleRate * 0.5, this.context.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < data.length; i++) {
                    data[i] = (Math.random() * 2 - 1) * 0.2 * Math.exp(-i / (this.context.sampleRate * 0.2));
                }
                return buffer;
            }

            play(soundName, volume = 1.0) {
                if (!this.initialized || !this.sounds[soundName]) return;

                const source = this.context.createBufferSource();
                const gainNode = this.context.createGain();
                
                source.buffer = this.sounds[soundName];
                gainNode.gain.value = volume;
                
                source.connect(gainNode);
                gainNode.connect(this.context.destination);
                source.start(0);
            }

            startPendulum() {
                if (!this.initialized || this.pendulumTimeout) return;
                
                const playTick = () => {
                    this.play('pendulum', 0.15);
                    this.pendulumTimeout = setTimeout(playTick, 1200);
                };
                
                playTick();
            }

            stopPendulum() {
                if (this.pendulumTimeout) {
                    clearTimeout(this.pendulumTimeout);
                    this.pendulumTimeout = null;
                }
            }

            startMachine() {
                if (!this.initialized) return;
                
                const playMachine = () => {
                    this.play('machine', 0.25);
                    setTimeout(playMachine, 2000);
                };
                
                playMachine();
            }
        }

        const soundSystem = new SoundSystem();

        // ===== ФУНКЦИЯ ДЛЯ 25-ГО КАДРА =====
        function showSubliminal(text) {
            const subliminal = document.createElement('div');
            subliminal.className = 'subliminal';
            subliminal.textContent = text;
            document.body.appendChild(subliminal);
            
            setTimeout(() => subliminal.remove(), 50);
        }

        // PERFECTED HYPNOTIC IMMERSION
        const story = [
            'Ты стоишь в дверях.|2000',
            'Перед тобой — <span class="void">лужа</span>.|2000|obsess:лужа|water',
            '<span class="death">Тёмная</span>.|1500',
            'Расползается.|2000|peripheral|wetstain',
            '|4500|blackout:4500|silence|sound:void_hum',
            'Ты всё ещё здесь?|2500|break|subliminal:ЗДЕСЬ',
            'Ты чувствуешь это?|2200|break|cursormove',
            'Твоя рука.|2000|break',
            'Она не твоя.|3000|break|reality',
            'Ты считаешь секунды.|2500',
            'Десять.|1000|sound:tick|heartbeat',
            'Девять.|1000|sound:tick|heartbeat',
            'Восемь.|1000|sound:tick|heartbeat',
            'Семь.|1000|sound:tick|heartbeat',
            'Шесть.|1000|sound:tick|heartbeat',
            'Пять.|1000|sound:tick|heartbeat',
            'Четыре.|1000|sound:tick|heartbeat',
            'Три.|1000|sound:tick|heartbeat',
            'Два.|1000|sound:tick|heartbeat',
            'Один.|3000|sound:tick|heartbeat',
            'Ты входишь.|2500|sound:step|trail|cursormove',
            'Он смотрит на тебя.|2000',
            'Не узнаёт.|2000',
            'В его глазах — <span class="void">страх</span>.|2500|shadow|peripheral',
            'Ты для него <span class="death">чужой</span>.|3000|distorted',
            '|3000|blackout:3000|silence',
            'Посмотри на свои руки.|2500|break|subliminal:РУКИ',
            'Прямо сейчас.|2000|break|cursormove',
            'Они трясутся?|3000|break|watching',
            'Он отступает к стене.|2000',
            'Прикрывает себя руками.|2000',
            'Руки как <span class="death">ветки</span>.|1500',
            'Сухие. <span class="death">Ломкие</span>.|2500|sound:crunch',
            'Ты идёшь к нему.|2000|sound:step|cursormove',
            'Каждый шаг.|1200|sound:step',
            'Ближе.|1200|sound:step|peripheral',
            'Ближе.|1200|sound:step|peripheral',
            'Он <span class="scream">кричит</span>.|2000|double|chromatic|sound:scream|camera:shake',
            'Не словами.|1500',
            '<span class="void">Звуком</span>.|1500',
            '<span class="void">Животным</span>.|3000|shake|screentear',
            '|5000|blackout:5000|silence',
            'Сколько времени прошло?|2500|break|timedistort',
            'Минута?|1200|break',
            'Час?|1200|break',
            'День?|2000|break',
            'Ты уже не помнишь, когда вошёл.|3000|break|subliminal:ЗАБЫЛ',
            'Ты рвёшь с него майку.|2000',
            'Она легко рвётся.|2000|sound:tear',
            'Как <span class="void">бумага</span>.|1500',
            'Снимаешь штаны.|1500',
            'Трусы.|1500',
            'Он <span class="death">голый</span> перед тобой.|3000|freeze',
            'Ты смотришь.|2500|watching',
            '<span class="death">Рёбра. Раз. Два. Три. Четыре. Пять</span>.|3000',
            'Все пять. Можно пересчитать пальцем.|2500',
            'Позвоночник — <span class="death">бугры</span> под кожей.|2000',
            'Ноги — <span class="death">спички</span>.|2000',
            'Живот — <span class="void">яма</span>.|2500',
            'Это был твой <span class="death">отец</span>.|4000|shadow|heartbeat|camera:zoom',
            'Ты помнишь его другим?|3000|break|obsess:помнишь',
            '|3500|blackout:3500|silence',
            'Нет.|2500|break',
            'Ты не помнишь.|3000|break|subliminal:ЗАБВЕНИЕ',
            'Ты тащишь его к душу.|2000|sound:step|cursormove',
            'За локоть.|1500',
            'Он лёгкий.|1500',
            'Невесомый почти.|2000',
            'Ставишь под воду.|2000',
            'Включаешь.|2000',
            '<span class="cold">Холодная</span>.|2000|sound:water|obsess:вода|water',
            'Он вскрикивает.|2000',
            'Рот открыт. <span class="void">Беззубый</span>.|2500',
            'Чёрная дыра вместо рта.|2500|peripheral',
            'Ты ждёшь.|3000|sound:waterambient',
            'Вода течёт по его телу.|2000|obsess:вода|water',
            '<span class="cold">Холодная</span>.|2000',
            'Он дрожит.|2500|sound:breathing',
            'Весь.|1500',
            'Ты стоишь. Смотришь.|3000|watching',
            'Тридцать секунд.|2500',
            'Может, минута.|3000',
            'Время <span class="void">размазалось</span>.|3000|timedistort',
            '|6000|blackout:6000|silence',
            'Твоя спина болит?|3000|break|subliminal:БОЛИТ',
            'От того, как ты сидишь?|2500|break',
            'Ты сутулишься.|2000|break',
            'Как он.|3000|break|distorted',
            'Он дрожит всем телом.|2500|heartbeat',
            'Ты включаешь горячую.|2000',
            'Теплеет.|1500',
            'Он затихает.|3000',
            'Ты берёшь мочалку.|2000',
            'Намыливаешь.|1500',
            'Начинаешь <span class="machine-word">тереть</span>.|2000|sound:scrub|sound:metallic',
            'Спина.|1200',
            'Круговыми движениями.|1500',
            '<span class="machine-word">Сильно</span>.|1500',
            'Его кожа краснеет.|2000|redFlicker',
            'Ты трёшь <span class="machine-word">сильнее</span>.|2000|shake|sound:scrub',
            'Хочешь <span class="void">стереть</span>.|1500',
            'До <span class="death">костей</span>.|3000',
            '<span class="machine-word">Ты трёшь. Трёшь. Трёшь</span>.|2500|obsess:трёшь|sound:scrub',
            '<span class="machine-word">Монотонно</span>.|2000',
            '<span class="machine-word">Скрип. Скрип. Скрип</span>.|3000|obsess:скрип|sound:creak',
            'Как ногти по доске.|2500|reality',
            'Ты моешь его пах.|2000',
            '<span class="machine-word">Каждый день</span> моешь.|2000|obsess:каждый день',
            '<span class="death">Увядшую плоть</span>.|2500',
            'Потому что он обоссался. <span class="machine-word">Снова</span>.|3000|obsess:снова',
            'Задница.|2000',
            'Ты раздвигаешь.|1500',
            'Он дёргается.|1500',
            'Ты держишь крепче.|2000',
            '<span class="machine-word">Моешь</span>.|1500',
            '<span class="filth">Дерьмо. Размазанное. Вонючее</span>.|3000|obsess:грязь',
            'Запах.|2000',
            'Ты чувствуешь его сейчас?|3000|break|subliminal:ЗАПАХ|breathfog',
            'Нет.|2000|break',
            'Но он в твоей голове.|3000|break|peripheral',
            'Вода <span class="filth">коричневая</span> стекает в слив.|3000|water',
            'С твоего <span class="death">отца</span>.|2500|shadow',
            'Ты продолжаешь.|2000',
            '<span class="machine-word">Моешь. Моешь. Моешь</span>.|2500|obsess:моешь|sound:scrub',
            'Не можешь <span class="void">остановиться</span>.|3000|shake|cursormove',
            'Твои руки <span class="machine-word">трут. Трут. Трут</span>.|2500|heartbeat',
            'Автоматически.|2000',
            '<span class="void">Машина из мяса</span>.|3000|distorted',
            '|4000|blackout:4000|silence',
            'Это напоминает тебе что-то?|2500|break',
            'Твою жизнь.|2000|break|watching',
            'Каждый.|1000|break',
            'Гребаный.|1000|break',
            'День.|3000|break|reality|crack',
            'Его кожа <span class="pain">красная</span>.|2000|redFlicker',
            'Почти <span class="pain">кровь</span>.|3000|blood|obsess:кровь|blooddrop',
            '— <span class="pain">Больно</span>.|4000|double',
            'Шёпот. Еле слышный.|2500',
            'Ты слышал?|2500|break|subliminal:БОЛЬНО',
            '<span class="pain">Больно</span>.|3500',
            'Ты смотришь на руки.|2500',
            'Мочалка в <span class="pain">крови</span>.|2500|blood|obsess:кровь|blooddrop',
            'На спине — <span class="pain">кровь. Полосы</span>.|3000|blood|chromatic|blooddrop',
            'Ты <span class="pain">содрал кожу</span>.|2500|blood|blooddrop|sound:metallic',
            '|2500|strobe:1500',
            'Со своего <span class="death">отца</span>.|4500|shake|redFlicker|screentear|blooddrop',
            'Вода смывает <span class="pain">кровь</span>. Розовая.|3000|sound:water|water|blooddrop',
            'Как у новорождённого.|2500',
            'Ты одеваешь его.|2000',
            'Как сломанную <span class="void">куклу</span>.|2500',
            'Голова висит.|2000',
            'Руки не слушаются.|2000',
            'Ведёшь в комнату.|2000|sound:step|cursormove',
            'Сажаешь на диван.|3000',
            'Он смотрит в <span class="void">пустоту</span>.|3000|obsess:пустота',
            'Ты уходишь на кухню.|2000',
            '<span class="machine-word">Моешь руки. Долго</span>.|2500|sound:water|obsess:моешь|water',
            'Его <span class="filth">грязь</span> въелась.|2000|obsess:грязь',
            'В твою кожу. В твою <span class="pain">кровь</span>.|3000|shake',
            'Ты трёшь <span class="machine-word">сильнее</span>.|2000|heartbeat|sound:scrub',
            'Твоя кожа <span class="pain">слезает</span>.|3000|blood|blooddrop',
            'Розовая. Сырая.|2500|redFlicker',
            '|5000|blackout:5000|silence|sound:pressure',
            'Чем ты отличаешься от него?|3000|break|timedistort',
            'Ты.|1500|break',
            'Смотрящий в экран.|2500|break|watching',
            'Наблюдатель.|2000|break',
            'Соучастник.|3000|break|reality',
            'Твоя мышь.|2000|break|cursormove',
            'Движется сама.|3000|break|subliminal:НЕТ КОНТРОЛЯ',
            'Ты смотришь в окно.|2500',
            'Там люди живут.|2000',
            'Они не знают.|2000',
            'Какой <span class="void">ад</span> здесь.|3500|shadow|peripheral',
            '<span class="machine-word">Три года. Каждый день</span>.|3000|obsess:каждый день',
            'Тысяча девяносто пять дней.|3000|timedistort',
            '<span class="void">Лужа</span>. Вода. <span class="filth">Грязь</span>. <span class="pain">Кровь</span>.|3500|obsess:лужа|water|blooddrop',
            'Ты <span class="void">сходишь с ума</span>.|2500|shake|double|redFlicker',
            '<span class="machine-word">Медленно</span>.|2000',
            'Но верно.|2000',
            'Он теряет <span class="void">память</span>.|2000',
            'Ты теряешь <span class="void">себя</span>.|4000|freeze|obsess:теряю',
            'Иногда ночью.|2500|shadow',
            'Ты стоишь над ним.|2000|watching',
            'Думаешь. <span class="death">Подушка</span>.|2500',
            'Просто прижать.|2000',
            'И всё <span class="death">кончится</span>.|3500|freeze',
            'Ты держишь <span class="death">подушку</span>.|2500|heartbeat',
            'Подносишь к его лицу.|2500|peripheral|breathfog',
            'Руки <span class="void">трясутся</span>.|2500|shake',
            'Твои руки.|2000|break|subliminal:ТВОИ РУКИ',
            'Прямо сейчас.|2000|break|cursormove',
            '<span class="scream">Сейчас</span>.|2500',
            '<span class="scream">Сейчас</span>.|2500|redFlicker',
            '<span class="scream">СЕЙЧАС</span>.|4000|shake|redFlicker|screentear',
            '|3000|strobe:1200',
            'Но не делаешь.|2500|freeze',
            'Почему?|2500|break',
            'Страх?|1500|break',
            'Любовь?|1500|break',
            'Или ты уже мёртв внутри?|4500|break|reality',
            'Отходишь.|4000|timedistort',
            'Утром <span class="machine-word">снова</span> — <span class="void">лужа</span>.|2500|sound:machine|obsess:снова|water|wetstain',
            'Он не узнаёт.|2000',
            'Ты входишь.|2500|sound:step|cursormove',
            'И всё <span class="machine-word">сначала</span>.|3500|trail|obsess:сначала',
            'Внутри что-то <span class="pain">ломается</span>.|3000|shake|blood|chromatic|crack',
            'Хруст.|2000|reality|sound:crack',
            'Ты теряешь <span class="void">человечность</span>.|4000|distorted',
            'Ты — <span class="machine-word">машина</span>.|2500|sound:machine',
            'Которая <span class="machine-word">моет. Одевает. Кормит</span>.|3500|obsess:моешь',
            'Ты смотришь в зеркало.|2500|double|watching',
            'Не узнаёшь <span class="void">себя</span>.|2000|sound:distant_voices',
            'Глаза <span class="void">пустые</span>. Как у него.|3500|freeze|obsess:пустота',
            'Кто смотрит оттуда?|3000|break|peripheral',
            'Это ты?|2500|break|subliminal:КТО ТЫ',
            '|7000|blackout:7000|silence',
            'Когда ты в последний раз.|2500|break',
            'Чувствовал что-то?|3000|break|watching',
            'Вспомни.|2500|break',
            'Вспомни сейчас.|3000|break|cursormove',
            'Вы похожи.|2500|timedistort',
            '<span class="death">Отец и сын</span>.|2000',
            'Оба <span class="void">разрушаетесь</span>.|4000|shadow|heartbeat',
            'Параллельно.|2500',
            'Ты берёшь его руку.|2500',
            '<span class="cold">Холодная</span>. <span class="death">Мёртвая</span> почти.|3500',
            'Стиральная <span class="machine-word">машина</span> гудит.|2500|sound:machine',
            'Вода шумит.|2000|sound:water|water',
            '<span class="machine-word">Каждый день</span>.|3500|trail|obsess:каждый день',
            'Ты держишь <span class="death">мёртвую</span> руку.|2500',
            '<span class="death">Живого трупа</span>.|2500|distorted',
            'Который был твоим <span class="death">отцом</span>.|4000',
            'Который учил тебя не плакать.|3500',
            'Ты не плачешь.|2500',
            'Не можешь.|2500',
            'Внутри — <span class="void">пустота</span>.|3000|freeze|obsess:пустота',
            'Как в его <span class="void">глазах</span>.|4000|shake',
            'Вы ждёте <span class="death">смерти</span>.|3500|blood|redFlicker|peripheral|blooddrop',
            'Чьей. Не важно.|2500',
            'Лишь бы <span class="death">кончилось</span>.|4000|double',
            'Но не кончается.|3000|obsess:не кончается',
            'Никогда.|2500|timedistort',
            'Он дышит. Ты дышишь.|3500|sound:breathing|heartbeat',
            '<span class="machine-word">Завтра то же</span>.|2500|obsess:завтра',
            '<span class="void">Лужа</span>. Вода. <span class="pain">Кровь</span>.|3000|blood|water|blooddrop',
            '<span class="machine-word">И дальше. И дальше</span>.|3000|shake|obsess:и дальше',
            'В <span class="void">аду</span>.|2500',
            'Который называется.|2500|freeze|watching',
            '<span class="scream">Любовь. Долг. Семья</span>.|5000|shake|blood|redFlicker|chromatic|crack',
            'Вода течёт.|2500|sound:water|obsess:вода|water',
            '<span class="machine-word">Машина</span> гудит.|2500|sound:machine',
            'И ты ждёшь <span class="death">конца</span>.|3500',
            'Который не приходит.|4000|shadow|obsess:не приходит',
            'Никогда.|3000|reality',
            '|8000|blackout:8000|silence',
            'Ты понял?|3000|break|subliminal:ПОНЯЛ',
            'Это не его история.|3000|break|watching',
            'Это твоя.|2500|break|cursormove',
            'Просто.|2000|break',
            'Ты.|2000|break',
            'Ещё.|2000|break',
            'Не.|2000|break',
            'Знаешь.|3000|break|timedistort',
            'Об этом.|4000|break|reality|peripheral',
            '<span class="void">Никогда</span>.|7000|shake|blood|redFlicker|freeze|chromatic|obsess:никогда|blooddrop|crack',
            '|4000|strobe:2500',
            '|15000|blackout:15000|silence'
        ];

        let audioContext, ambientLayers = [], progressionLevel = 0;
        let obsessiveWords = [], forgottenWords = [];
        let mouseX = 0, mouseY = 0, realMouseX = 0, realMouseY = 0;
        let forcedCursorActive = false, isWatching = false;
        let cursorTrails = [];
        let subliminalMessages = ['ЗАБУДЬ', 'БЕЗЫСХОДНОСТЬ', 'ПОВТОР', 'РАСПАД', 'ПУСТОТА', 'БОЛЬ', 'ЦИКЛ', 'НЕТ ВЫХОДА', 'ПОВИНУЙСЯ', 'СТРАХ', 'ТОНЕШЬ', 'ТЕРЯЕШЬСЯ'];
        let waterDrops = [], bloodDrops = [], wetStains = [];
        let lastActivityTime = Date.now();
        let isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        
        // РАДИКАЛЬНАЯ СИСТЕМА ПСИХОЛОГИЧЕСКОГО УЖАСА - ИСПРАВЛЕННАЯ ВЕРСИЯ
        class LivingWordsSystem {
            constructor() {
                this.words = [];
                this.container = null;
                this.wordBank = [
                    'ЗАБЫЛ', 'ВОДА', 'СМЕРТЬ', 'БОЛЬ', 'СТРАХ', 'ОТЕЦ', 'МАШИНА', 'КРОВЬ',
                    'ПУСТОТА', 'НИКОГДА', 'ПОВТОР', 'РАСПАД', 'ХОЛОД', 'ТРУП', 'ГЛАЗА',
                    'РУКИ', 'КРИК', 'ТЬМА', 'БЕЗУМИЕ', 'ЦИКЛ', 'АД', 'ДЕМЕНЦИЯ', 'ПОТЕРЯН',
                    'БЕЗЫСХОДНОСТЬ', 'УЖАС', 'КОНЕЦ', 'РАЗРУШЕНИЕ', 'ЖИВОЙ ТРУП', 'КАЖДЫЙ ДЕНЬ',
                    'ЛУЖА', 'СЫН', 'ДОЛГ', 'ЛЮБОВЬ', 'СЕМЬЯ', 'НЕ ПОМНИТ', 'ЗАБВЕНИЕ'
                ];
                this.spawnRate = 3000;
                this.minSpawnRate = 200;
                this.intensity = 0;
                this.isActive = false;
                this.patterns = [];
                this.patternWords = [];
            }
            
            init(containerId) {
                this.container = document.getElementById(containerId);
                this.isActive = true;
                this.startSpawning();
            }
            
            startSpawning() {
                if (!this.isActive) return;
                
                const currentRate = Math.max(
                    this.minSpawnRate,
                    this.spawnRate - (this.intensity * 2800)
                );
                
                const wordsToSpawn = Math.floor(1 + this.intensity * 4);
                for (let i = 0; i < wordsToSpawn; i++) {
                    setTimeout(() => this.spawnWord(), i * 100);
                }
                
                setTimeout(() => this.startSpawning(), currentRate);
            }
            
            spawnWord() {
                const word = this.wordBank[Math.floor(Math.random() * this.wordBank.length)];
                const wordEl = document.createElement('div');
                wordEl.className = 'obsessive-word spawned';
                wordEl.textContent = word;
                
                wordEl.style.left = Math.random() * window.innerWidth + 'px';
                wordEl.style.top = Math.random() * window.innerHeight + 'px';
                wordEl.style.fontSize = (10 + Math.random() * 10) + 'px';
                
                wordEl.style.setProperty('--dx1', (Math.random() * 40 - 20) + 'px');
                wordEl.style.setProperty('--dy1', (Math.random() * 40 - 20) + 'px');
                wordEl.style.setProperty('--dx2', (Math.random() * 40 - 20) + 'px');
                wordEl.style.setProperty('--dy2', (Math.random() * 40 - 20) + 'px');
                wordEl.style.setProperty('--dx3', (Math.random() * 40 - 20) + 'px');
                wordEl.style.setProperty('--dy3', (Math.random() * 40 - 20) + 'px');
                wordEl.style.setProperty('--r1', (Math.random() * 6 - 3) + 'deg');
                wordEl.style.setProperty('--r2', (Math.random() * 6 - 3) + 'deg');
                wordEl.style.setProperty('--r3', (Math.random() * 6 - 3) + 'deg');
                
                this.container.appendChild(wordEl);
                this.words.push(wordEl);
                
                setTimeout(() => {
                    wordEl.classList.add('drift');
                    if (Math.random() < 0.3) {
                        wordEl.classList.add('blur-pulse');
                    }
                }, 1000);
                
                if (this.intensity > 0.5 && Math.random() < this.intensity - 0.5) {
                    setTimeout(() => {
                        wordEl.classList.add('intense');
                    }, 2000);
                }
            }
            
            setIntensity(value) {
                this.intensity = Math.max(0, Math.min(1, value));
            }
            
            spawnPatternWord(word, x, y, size = 14, delay = 0) {
                const wordEl = document.createElement('div');
                wordEl.className = 'pattern-word';
                wordEl.textContent = word;
                wordEl.style.fontSize = size + 'px';
                
                const startX = window.innerWidth / 2;
                const startY = window.innerHeight / 2;
                wordEl.style.left = startX + 'px';
                wordEl.style.top = startY + 'px';
                
                this.container.appendChild(wordEl);
                this.patternWords.push(wordEl);
                
                setTimeout(() => {
                    wordEl.style.left = x + 'px';
                    wordEl.style.top = y + 'px';
                    wordEl.classList.add('visible');
                }, delay);
                
                return wordEl;
            }
            
            formEyes() {
                const centerX = window.innerWidth / 2;
                const centerY = window.innerHeight / 2;
                const leftEyeX = centerX - 150;
                const rightEyeX = centerX + 150;
                const eyeY = centerY - 50;
                
                for (let i = 0; i < 20; i++) {
                    const angle = (i / 20) * Math.PI * 2;
                    const radius = 30 + Math.random() * 20;
                    const x = leftEyeX + Math.cos(angle) * radius;
                    const y = eyeY + Math.sin(angle) * radius;
                    
                    const word = this.wordBank[Math.floor(Math.random() * this.wordBank.length)];
                    this.spawnPatternWord(word, x, y, 14, i * 50);
                }
                
                for (let i = 0; i < 20; i++) {
                    const angle = (i / 20) * Math.PI * 2;
                    const radius = 30 + Math.random() * 20;
                    const x = rightEyeX + Math.cos(angle) * radius;
                    const y = eyeY + Math.sin(angle) * radius;
                    
                    const word = this.wordBank[Math.floor(Math.random() * this.wordBank.length)];
                    this.spawnPatternWord(word, x, y, 14, i * 50);
                }
                
                for (let i = 0; i < 10; i++) {
                    const angle = (i / 10) * Math.PI * 2;
                    const radius = 8 + Math.random() * 5;
                    const x = leftEyeX + Math.cos(angle) * radius;
                    const y = eyeY + Math.sin(angle) * radius;
                    this.spawnPatternWord('•', x, y, 20, 1000 + i * 30);
                }
                
                for (let i = 0; i < 10; i++) {
                    const angle = (i / 10) * Math.PI * 2;
                    const radius = 8 + Math.random() * 5;
                    const x = rightEyeX + Math.cos(angle) * radius;
                    const y = eyeY + Math.sin(angle) * radius;
                    this.spawnPatternWord('•', x, y, 20, 1000 + i * 30);
                }
            }
            
            formHorrorSmile() {
                const centerX = window.innerWidth / 2;
                const centerY = window.innerHeight / 2 - 120;
                const faceRadius = Math.min(window.innerWidth * 0.3, 300);
                
                const facePoints = 60;
                for (let i = 0; i < facePoints; i++) {
                    const angle = (i / facePoints) * Math.PI * 2;
                    const radiusVariation = Math.sin(angle * 5) * 15;
                    const radius = faceRadius + radiusVariation;
                    const x = centerX + Math.cos(angle) * radius;
                    const y = centerY + Math.sin(angle) * radius;
                    
                    const word = ['ВОДА', 'ЗАБЫЛ', 'НИКОГДА', 'СМЕРТЬ'][Math.floor(Math.random() * 4)];
                    this.spawnPatternWord(word, x, y, 16, i * 20);
                }
                
                const leftEyeX = centerX - faceRadius * 0.35;
                const leftEyeY = centerY - faceRadius * 0.25;
                const eyeRadius = faceRadius * 0.15;
                
                for (let i = 0; i < 25; i++) {
                    const angle = (i / 25) * Math.PI * 2;
                    const radius = eyeRadius + Math.random() * 10;
                    const x = leftEyeX + Math.cos(angle) * radius;
                    const y = leftEyeY + Math.sin(angle) * radius;
                    
                    this.spawnPatternWord('ПУСТОТА', x, y, 12, 1200 + i * 25);
                }
                
                for (let i = 0; i < 15; i++) {
                    const angle = (i / 15) * Math.PI * 2;
                    const radius = eyeRadius * 0.4;
                    const x = leftEyeX + Math.cos(angle) * radius;
                    const y = leftEyeY + Math.sin(angle) * radius;
                    
                    this.spawnPatternWord('█', x, y, 18, 1500 + i * 20);
                }
                
                const rightEyeX = centerX + faceRadius * 0.35;
                const rightEyeY = centerY - faceRadius * 0.25;
                
                for (let i = 0; i < 25; i++) {
                    const angle = (i / 25) * Math.PI * 2;
                    const radius = eyeRadius + Math.random() * 10;
                    const x = rightEyeX + Math.cos(angle) * radius;
                    const y = rightEyeY + Math.sin(angle) * radius;
                    
                    this.spawnPatternWord('ПУСТОТА', x, y, 12, 1200 + i * 25);
                }
                
                for (let i = 0; i < 15; i++) {
                    const angle = (i / 15) * Math.PI * 2;
                    const radius = eyeRadius * 0.4;
                    const x = rightEyeX + Math.cos(angle) * radius;
                    const y = rightEyeY + Math.sin(angle) * radius;
                    
                    this.spawnPatternWord('█', x, y, 18, 1500 + i * 20);
                }
                
                const smilePoints = 70;
                const smileWidth = faceRadius * 1.4;
                const smileHeight = faceRadius * 0.4;
                
                for (let i = 0; i < smilePoints; i++) {
                    const t = i / smilePoints;
                    const angle = Math.PI * 0.2 + t * Math.PI * 0.6;
                    const baseRadius = smileWidth * 0.6;
                    const wobble = Math.sin(t * Math.PI * 8) * 8;
                    const x = centerX + (t - 0.5) * smileWidth;
                    const y = centerY + smileHeight + Math.sin(angle) * baseRadius * 0.5 + wobble;
                    
                    const word = ['НИКОГДА', 'ЗАБЫЛ', 'ПОВТОР', 'ЦИКЛ'][Math.floor(Math.random() * 4)];
                    this.spawnPatternWord(word, x, y, 14, 2000 + i * 20);
                }
                
                const teethCount = 25;
                for (let i = 0; i < teethCount; i++) {
                    const t = i / teethCount;
                    const angle = Math.PI * 0.2 + t * Math.PI * 0.6;
                    const x = centerX + (t - 0.5) * smileWidth;
                    const y = centerY + smileHeight + Math.sin(angle) * smileWidth * 0.3;
                    
                    this.spawnPatternWord('│', x, y, 20, 2500 + i * 15);
                }
                
                const nosePoints = [
                    {x: centerX, y: centerY - faceRadius * 0.05},
                    {x: centerX - 15, y: centerY + faceRadius * 0.1},
                    {x: centerX + 15, y: centerY + faceRadius * 0.1}
                ];
                
                nosePoints.forEach((point, i) => {
                    this.spawnPatternWord('▼', point.x, point.y, 14, 1800 + i * 50);
                });
                
                for (let i = 0; i < 8; i++) {
                    const x = leftEyeX - 5 + Math.random() * 10;
                    const y = leftEyeY + eyeRadius + i * 25;
                    this.spawnPatternWord('│', x, y, 12, 3000 + i * 100);
                }
                
                for (let i = 0; i < 8; i++) {
                    const x = rightEyeX - 5 + Math.random() * 10;
                    const y = rightEyeY + eyeRadius + i * 25;
                    this.spawnPatternWord('│', x, y, 12, 3000 + i * 100);
                }
                
                const haloWords = ['ЗАБЫЛ', 'ВОДА', 'НИКОГДА', 'КОНЕЦ', 'СМЕРТЬ', 'ПУСТОТА'];
                for (let i = 0; i < 40; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const radius = faceRadius * 1.3 + Math.random() * 50;
                    const x = centerX + Math.cos(angle) * radius;
                    const y = centerY + Math.sin(angle) * radius;
                    
                    const word = haloWords[Math.floor(Math.random() * haloWords.length)];
                    this.spawnPatternWord(word, x, y, 12 + Math.random() * 6, 3500 + i * 30);
                }
            }
            
            clearPatterns() {
                this.patternWords.forEach(word => {
                    word.classList.add('fading-out');
                    setTimeout(() => word.remove(), 1000);
                });
                this.patternWords = [];
            }
            
            makeAllIntense() {
                this.words.forEach(word => {
                    word.classList.add('intense');
                });
            }
            
            formSkull() {
                const centerX = window.innerWidth / 2;
                const centerY = window.innerHeight / 2 - 100;
                const skullSize = Math.min(window.innerWidth * 0.25, 250);
                
                // Верх черепа (овал)
                for (let i = 0; i < 50; i++) {
                    const angle = (i / 50) * Math.PI;
                    const radius = skullSize * (1 - Math.abs(Math.sin(angle)) * 0.2);
                    const x = centerX + Math.cos(angle + Math.PI) * radius;
                    const y = centerY - skullSize * 0.3 + Math.sin(angle + Math.PI) * radius * 0.6;
                    
                    const word = ['СМЕРТЬ', 'ТРУП', 'КОНЕЦ', 'РАСПАД'][Math.floor(Math.random() * 4)];
                    this.spawnPatternWord(word, x, y, 14, i * 15);
                }
                
                // Глазницы (пустые впадины)
                const eyeRadius = skullSize * 0.12;
                const leftEyeX = centerX - skullSize * 0.25;
                const rightEyeX = centerX + skullSize * 0.25;
                const eyeY = centerY - skullSize * 0.15;
                
                for (let i = 0; i < 20; i++) {
                    const angle = (i / 20) * Math.PI * 2;
                    const x1 = leftEyeX + Math.cos(angle) * eyeRadius;
                    const y1 = eyeY + Math.sin(angle) * eyeRadius * 0.8;
                    const x2 = rightEyeX + Math.cos(angle) * eyeRadius;
                    const y2 = eyeY + Math.sin(angle) * eyeRadius * 0.8;
                    
                    this.spawnPatternWord('█', x1, y1, 16, 750 + i * 20);
                    this.spawnPatternWord('█', x2, y2, 16, 750 + i * 20);
                }
                
                // Нос (треугольная впадина)
                const noseY = centerY;
                for (let i = 0; i < 15; i++) {
                    const t = i / 15;
                    const x = centerX + (Math.random() - 0.5) * skullSize * 0.15;
                    const y = noseY - skullSize * 0.08 + t * skullSize * 0.15;
                    this.spawnPatternWord('▼', x, y, 14, 1000 + i * 30);
                }
                
                // Челюсть (зубы)
                const jawY = centerY + skullSize * 0.2;
                for (let i = 0; i < 30; i++) {
                    const t = i / 30;
                    const angle = Math.PI * 0.25 + t * Math.PI * 0.5;
                    const x = centerX + Math.cos(angle) * skullSize * 0.5;
                    const y = jawY + Math.sin(angle) * skullSize * 0.25;
                    
                    this.spawnPatternWord('┃', x, y, 18, 1200 + i * 15);
                }
            }
            
            formSexSymbol() {
                const centerX = window.innerWidth / 2;
                const centerY = window.innerHeight / 2 - 100;
                const size = Math.min(window.innerWidth * 0.2, 200);
                
                // Переплетённые тела (абстрактно)
                const curves = 3;
                for (let curve = 0; curve < curves; curve++) {
                    for (let i = 0; i < 40; i++) {
                        const t = i / 40;
                        const angle = t * Math.PI * 2 + curve * Math.PI * 0.67;
                        const radius = size * (0.5 + Math.sin(t * Math.PI * 3) * 0.3);
                        const x = centerX + Math.cos(angle) * radius;
                        const y = centerY + Math.sin(angle * 1.5) * radius;
                        
                        const word = ['ЛЮБОВЬ', 'ПЛОТЬ', 'ТЕЛО', 'ЖЕЛАНИЕ'][Math.floor(Math.random() * 4)];
                        this.spawnPatternWord(word, x, y, 14, curve * 500 + i * 20);
                    }
                }
                
                // Центральная точка соединения
                for (let i = 0; i < 15; i++) {
                    const angle = (i / 15) * Math.PI * 2;
                    const radius = 30 + Math.random() * 15;
                    const x = centerX + Math.cos(angle) * radius;
                    const y = centerY + Math.sin(angle) * radius;
                    
                    this.spawnPatternWord('•', x, y, 22, 1200 + i * 30);
                }
            }
            
            formDeathSymbol() {
                const centerX = window.innerWidth / 2;
                const centerY = window.innerHeight / 2 - 100;
                const size = Math.min(window.innerWidth * 0.25, 250);
                
                // Крест/Коса смерти
                // Вертикальная линия
                for (let i = 0; i < 35; i++) {
                    const y = centerY - size * 0.5 + i * (size / 35);
                    const x = centerX + (Math.random() - 0.5) * 10;
                    
                    const word = ['СМЕРТЬ', 'КОНЕЦ', 'РАСПАД', 'НИЧТО'][Math.floor(Math.random() * 4)];
                    this.spawnPatternWord(word, x, y, 16, i * 20);
                }
                
                // Горизонтальная линия
                for (let i = 0; i < 30; i++) {
                    const x = centerX - size * 0.4 + i * (size * 0.8 / 30);
                    const y = centerY - size * 0.15 + (Math.random() - 0.5) * 10;
                    
                    const word = ['ПУСТОТА', 'НИЧТО', 'НЕБЫТИЕ', 'ТЬМА'][Math.floor(Math.random() * 4)];
                    this.spawnPatternWord(word, x, y, 16, 700 + i * 20);
                }
                
                // Коса (изогнутая линия)
                for (let i = 0; i < 25; i++) {
                    const t = i / 25;
                    const angle = t * Math.PI * 0.5;
                    const x = centerX + size * 0.3 + Math.cos(angle) * size * 0.4;
                    const y = centerY - size * 0.4 + Math.sin(angle) * size * 0.6;
                    
                    this.spawnPatternWord('╱', x, y, 20, 1200 + i * 25);
                }
            }
            
            rapidImageSequence() {
                // Быстрая смена образов: смайлик → череп → смайлик → секс → смерть → череп → смайлик
                const sequence = [
                    { type: 'skull', duration: 1500 },
                    { type: 'smile', duration: 1200 },
                    { type: 'sex', duration: 1000 },
                    { type: 'death', duration: 1500 },
                    { type: 'skull', duration: 1000 },
                    { type: 'smile', duration: 1200 }
                ];
                
                let totalDelay = 0;
                
                sequence.forEach((item, index) => {
                    setTimeout(() => {
                        // Очищаем предыдущий образ
                        this.clearPatterns();
                        
                        // Формируем новый образ
                        setTimeout(() => {
                            switch(item.type) {
                                case 'skull':
                                    this.formSkull();
                                    break;
                                case 'smile':
                                    this.formHorrorSmile();
                                    break;
                                case 'sex':
                                    this.formSexSymbol();
                                    break;
                                case 'death':
                                    this.formDeathSymbol();
                                    break;
                            }
                        }, 200);
                    }, totalDelay);
                    
                    totalDelay += item.duration;
                });
            }
            
            // НОВЫЙ: Трансформация смайлика (веселый → грустный → череп)
            morphSmile() {
                const centerX = window.innerWidth / 2;
                const centerY = window.innerHeight / 2 - 100;
                const size = Math.min(window.innerWidth * 0.25, 250);
                
                // 1. Начинаем с веселого смайлика
                this.formHorrorSmile();
                
                // 2. Через 2 сек морфим в грустный
                setTimeout(() => {
                    // Добавляем эффект морфинга
                    this.patternWords.forEach(el => {
                        el.style.transition = 'all 1s ease-in-out';
                        el.style.filter = 'blur(5px)';
                        el.style.transform = 'scale(1.2)';
                    });
                    
                    setTimeout(() => {
                        this.clearPatterns();
                        
                        setTimeout(() => {
                            // Формируем грустный смайлик
                            this.formSadSmile();
                        }, 300);
                    }, 500);
                }, 2000);
                
                // 3. Через 5 сек превращаем в череп
                setTimeout(() => {
                    this.patternWords.forEach(el => {
                        el.style.transition = 'all 1s ease-in-out';
                        el.style.filter = 'blur(5px)';
                        el.style.transform = 'scale(1.2)';
                    });
                    
                    setTimeout(() => {
                        this.clearPatterns();
                        
                        setTimeout(() => {
                            this.formSkull();
                        }, 300);
                    }, 500);
                }, 5000);
            }
            
            // НОВЫЙ: Грустный смайлик
            formSadSmile() {
                const centerX = window.innerWidth / 2;
                const centerY = window.innerHeight / 2 - 100;
                const faceRadius = Math.min(window.innerWidth * 0.3, 300);
                
                // Контур лица
                for (let i = 0; i < 60; i++) {
                    const angle = (i / 60) * Math.PI * 2;
                    const x = centerX + Math.cos(angle) * faceRadius;
                    const y = centerY + Math.sin(angle) * faceRadius;
                    this.spawnPatternWord('😢', x, y, 16, i * 15);
                }
                
                // Глаза
                const leftEyeX = centerX - faceRadius * 0.35;
                const rightEyeX = centerX + faceRadius * 0.35;
                const eyeY = centerY - faceRadius * 0.25;
                const eyeRadius = faceRadius * 0.15;
                
                for (let i = 0; i < 25; i++) {
                    const angle = (i / 25) * Math.PI * 2;
                    this.spawnPatternWord('•', leftEyeX + Math.cos(angle) * eyeRadius, eyeY + Math.sin(angle) * eyeRadius, 18, 900 + i * 20);
                    this.spawnPatternWord('•', rightEyeX + Math.cos(angle) * eyeRadius, eyeY + Math.sin(angle) * eyeRadius, 18, 900 + i * 20);
                }
                
                // Грустная улыбка (перевернутая дуга)
                const smilePoints = 50;
                const smileWidth = faceRadius * 1.2;
                const smileY = centerY + faceRadius * 0.3;
                
                for (let i = 0; i < smilePoints; i++) {
                    const t = i / smilePoints;
                    const angle = Math.PI * 0.3 + t * Math.PI * 0.4;
                    const x = centerX + (t - 0.5) * smileWidth;
                    const y = smileY - Math.sin(angle) * faceRadius * 0.3;
                    this.spawnPatternWord('│', x, y, 14, 1500 + i * 15);
                }
            }
            
            // НОВЫЙ: Приближение образа к зрителю
            zoomToViewer() {
                this.patternWords.forEach((word, index) => {
                    setTimeout(() => {
                        const scaleTime = 2000;
                        const startTime = Date.now();
                        
                        const animate = () => {
                            const elapsed = Date.now() - startTime;
                            const progress = Math.min(elapsed / scaleTime, 1);
                            const scale = 1 + progress * 3;
                            
                            word.style.transform = `scale(${scale})`;
                            word.style.opacity = 1 - progress * 0.5;
                            
                            if (progress < 1) {
                                requestAnimationFrame(animate);
                            }
                        };
                        
                        animate();
                    }, index * 8);
                });
            }
        }
        
        // ВИНЬЕТКА С ДИНАМИЧЕСКИМ СЖАТИЕМ - ИСПРАВЛЕННАЯ
        class DynamicVignette {
            constructor() {
                this.element = null;
                this.currentIntensity = 0.4;
            }
            
            init(selector) {
                this.element = document.querySelector(selector);
                if (this.element) {
                    this.element.style.boxShadow = 'inset 0 0 500px rgba(0,0,0,0.4)';
                }
            }
            
            update(progression) {
                if (!this.element) return;
                
                const size = 500 + progression * 2500;
                const darkness = 0.4 + progression * 0.55;
                
                this.element.style.transition = 'box-shadow 3s ease-out';
                this.element.style.boxShadow = `inset 0 0 ${size}px rgba(0,0,0,${darkness})`;
            }
            
            squeeze(intensity = 0.95, duration = 1000) {
                if (!this.element) return;
                
                const size = 200 + (1 - intensity) * 2800;
                const darkness = 0.85 + intensity * 0.15;
                
                this.element.style.transition = `box-shadow ${duration}ms ease-out`;
                this.element.style.boxShadow = `inset 0 0 ${size}px rgba(0,0,0,${darkness})`;
                this.currentIntensity = intensity;
            }
            
            release(duration = 2000) {
                if (!this.element) return;
                
                const size = 800;
                this.element.style.transition = `box-shadow ${duration}ms ease-out`;
                this.element.style.boxShadow = `inset 0 0 ${size}px rgba(0,0,0,0.4)`;
                this.currentIntensity = 0.4;
            }
            
            suffocate(duration = 2000) {
                if (!this.element) return;
                
                this.element.style.transition = `box-shadow ${duration}ms ease-in`;
                this.element.style.boxShadow = 'inset 0 0 3500px rgba(0,0,0,0.98)';
            }
        }
        
        // Инициализация систем
        const livingWords = new LivingWordsSystem();
        const vignetteControl = new DynamicVignette();
        
        const FORGOTTEN = [
            'отец', 'помню', 'забыл', 'кто я', 'где я', 'раньше', 'было', 'имя', 'лицо', 'голос', 
            'давно', 'тогда', 'помнишь', 'стёрлось', 'исчезло', 'потерял', 'не помню', 'узнаю', 
            'был', 'когда', 'там', 'здесь', 'дома', 'мама', 'детство', 'счастье', 'смех', 'свет',
            'любовь', 'надежда', 'будущее', 'прошлое', 'человек', 'живой', 'помощь', 'конец', 'начало',
            'выход', 'спасение', 'жизнь', 'смерть', 'боль', 'страх', 'время', 'дни', 'годы'
        ];

        // REAL mouse tracking
        document.addEventListener('mousemove', (e) => {
            realMouseX = e.clientX;
            realMouseY = e.clientY;
            lastActivityTime = Date.now();
            
            if (!forcedCursorActive) {
                mouseX = realMouseX;
                mouseY = realMouseY;
                const cursor = document.getElementById('cursor');
                if (cursor) {
                    cursor.style.left = mouseX + 'px';
                    cursor.style.top = mouseY + 'px';
                }
            }
            
            if (Math.random() < 0.25 && progressionLevel > 0.3) {
                createCursorTrail();
            }
        });

        document.addEventListener('touchstart', () => {
            lastActivityTime = Date.now();
        });

        document.addEventListener('touchmove', () => {
            lastActivityTime = Date.now();
        });

        // Emergency exit
        document.getElementById('emergency-exit').addEventListener('click', () => {
            if (confirm('Прервать опыт?')) {
                location.reload();
            }
        });

        document.getElementById('enter').addEventListener('click', async () => {
            // IMMEDIATE START - NO DELAY
            document.getElementById('warning').style.display = 'none';
            document.getElementById('experience').style.display = 'block';
            
            // Fullscreen attempt (silent fail on mobile)
            try {
                const elem = document.documentElement;
                if (elem.requestFullscreen) {
                    await elem.requestFullscreen();
                } else if (elem.webkitRequestFullscreen) {
                    elem.webkitRequestFullscreen();
                } else if (elem.msRequestFullscreen) {
                    elem.msRequestFullscreen();
                }
            } catch (err) {}
            
            // Audio initialization
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                if (audioContext.state === 'suspended') {
                    await audioContext.resume();
                }
                const buffer = audioContext.createBuffer(1, 1, 22050);
                const source = audioContext.createBufferSource();
                source.buffer = buffer;
                source.connect(audioContext.destination);
                source.start(0);
                initAtmosphere();
                
                // Инициализация новой звуковой системы
                await soundSystem.init();
                soundSystem.startPendulum();
                // Запускаем гул машины через несколько секунд
                setTimeout(() => {
                    if (soundSystem.initialized) {
                        soundSystem.startMachine();
                    }
                }, 5000);
            } catch (err) {
                console.error('Audio init error:', err);
            }
            
            // ИНИЦИАЛИЗАЦИЯ ЖИВЫХ СИСТЕМ
            try {
                livingWords.init('obsessive-words');
                vignetteControl.init('.vignette');
            } catch (err) {
                console.error('Living systems init error:', err);
            }
            
            // START IMMEDIATELY
            setTimeout(startExperience, 1500);
            setInterval(triggerRandomSubliminal, 12000);
        });

        function createCursorTrail() {
            const trail = document.createElement('div');
            trail.className = 'cursor-trail';
            trail.style.left = mouseX + 'px';
            trail.style.top = mouseY + 'px';
            document.body.appendChild(trail);
            setTimeout(() => trail.remove(), 800);
        }

        function createWaterDrop() {
            const drop = document.createElement('div');
            drop.className = 'water-drop';
            drop.style.left = Math.random() * 100 + '%';
            drop.style.height = (40 + Math.random() * 60) + 'px';
            document.getElementById('water-drops').appendChild(drop);
            drop.classList.add('active');
            setTimeout(() => drop.remove(), 3000);
        }

        function createBloodDrop() {
            const drop = document.createElement('div');
            drop.className = 'blood-drop';
            drop.style.left = Math.random() * 100 + '%';
            drop.style.height = (50 + Math.random() * 90) + 'px';
            document.getElementById('blood-drops').appendChild(drop);
            drop.classList.add('active');
            setTimeout(() => drop.remove(), 4000);
            if (navigator.vibrate && Math.random() < 0.3) {
                navigator.vibrate(120);
            }
        }

        function createWetStain() {
            const stain = document.createElement('div');
            stain.className = 'wet-stain';
            const size = 120 + Math.random() * 250;
            stain.style.width = size + 'px';
            stain.style.height = size + 'px';
            stain.style.left = Math.random() * 100 + '%';
            stain.style.top = Math.random() * 100 + '%';
            document.getElementById('wet-stains').appendChild(stain);
            stain.classList.add('active');
        }

        function triggerBreathFog() {
            const fog = document.querySelector('.breath-fog');
            fog.classList.add('active');
            setTimeout(() => fog.classList.remove('active'), 5000);
        }

        function triggerScreenCrack() {
            const crack = document.querySelector('.screen-crack');
            crack.classList.add('active');
            if (navigator.vibrate) {
                navigator.vibrate([350, 120, 350]);
            }
        }

        function forceCursorMovement(duration = 2500) {
            if (isMobile) return;
            forcedCursorActive = true;
            const cursor = document.getElementById('cursor');
            cursor.classList.add('forced');
            const startX = mouseX;
            const startY = mouseY;
            const targetX = Math.random() * window.innerWidth;
            const targetY = Math.random() * window.innerHeight;
            const startTime = Date.now();
            const animate = () => {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const eased = progress < 0.5 
                    ? 4 * progress * progress * progress 
                    : 1 - Math.pow(-2 * progress + 2, 3) / 2;
                mouseX = startX + (targetX - startX) * eased + (Math.sin(progress * Math.PI * 5) * 40);
                mouseY = startY + (targetY - startY) * eased + (Math.cos(progress * Math.PI * 5) * 40);
                cursor.style.left = mouseX + 'px';
                cursor.style.top = mouseY + 'px';
                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    forcedCursorActive = false;
                    cursor.classList.remove('forced');
                }
            };
            animate();
            if (navigator.vibrate) {
                navigator.vibrate([60, 120, 60, 120, 60]);
            }
        }

        function triggerRandomSubliminal() {
            if (progressionLevel < 0.4) return;
            const msg = subliminalMessages[Math.floor(Math.random() * subliminalMessages.length)];
            const subliminal = document.querySelector('.subliminal');
            subliminal.textContent = msg;
            subliminal.classList.add('active');
            setTimeout(() => subliminal.classList.remove('active'), 40);
        }

        function initAtmosphere() {
            if (!audioContext) return;
            try {
                // DEEPEST INFRASOUND - максимальное физическое давление
                ambientLayers.push(createDrone(12, 0.06, 'lowpass', 40, 28));
                ambientLayers.push(createDrone(13.5, 0.06, 'lowpass', 40, 28));
                ambientLayers.push(createDrone(15, 0.05, 'lowpass', 60, 22));
                ambientLayers.push(createDrone(17, 0.05, 'lowpass', 70, 22));
                ambientLayers.push(createDrone(19, 0.045, 'lowpass', 85, 20));
                
                // Binaural horror - МАКСИМАЛЬНАЯ ИНТЕНСИВНОСТЬ
                ambientLayers.push(createDrone(38, 0.04, 'lowpass', 110, 12));
                ambientLayers.push(createDrone(38.9, 0.04, 'lowpass', 110, 12));
                
                // MAXIMUM Dissonance
                ambientLayers.push(createDrone(90, 0, 'bandpass', 200, 12));
                ambientLayers.push(createDrone(97, 0, 'bandpass', 200, 12));
                ambientLayers.push(createDrone(105, 0, 'bandpass', 230, 10));
                ambientLayers.push(createDrone(112, 0, 'bandpass', 230, 10));
                
                // Tritone - максимальный дискомфорт
                ambientLayers.push(createDrone(210, 0, 'bandpass', 380, 8));
                ambientLayers.push(createDrone(297, 0, 'bandpass', 380, 8));
                
                // METALLIC HELL
                ambientLayers.push(createDrone(650, 0, 'bandpass', 680, 18));
                ambientLayers.push(createDrone(975, 0, 'bandpass', 980, 15));
                
                // High frequency discomfort
                ambientLayers.push(createDrone(440, 0, 'bandpass', 480, 6));
                ambientLayers.push(createDrone(443, 0, 'bandpass', 480, 6));
                
                // CONTINUOUS PRESSURE
                const pressureOsc = audioContext.createOscillator();
                const pressureGain = audioContext.createGain();
                const pressureFilter = audioContext.createBiquadFilter();
                pressureOsc.type = 'sine';
                pressureOsc.frequency.value = 16;
                pressureFilter.type = 'lowpass';
                pressureFilter.frequency.value = 32;
                pressureFilter.Q.value = 20;
                pressureOsc.connect(pressureFilter);
                pressureFilter.connect(pressureGain);
                pressureGain.connect(audioContext.destination);
                pressureGain.gain.setValueAtTime(0, audioContext.currentTime);
                pressureGain.gain.linearRampToValueAtTime(0.1, audioContext.currentTime + 30);
                pressureOsc.start();
                ambientLayers.push({ osc: pressureOsc, gain: pressureGain, filter: pressureFilter });
                
                createShepardTone();
                createRandomScreams();
                createSubsonicPulse();
                createMetallicAmbient();
                createDistantEchoes();
                
                setInterval(() => {
                    ambientLayers.forEach(layer => {
                        if (layer && layer.gain) {
                            const time = audioContext.currentTime;
                            const currentGain = layer.gain.gain.value;
                            const variation = 0.04 * (1 + progressionLevel * 6);
                            layer.gain.gain.cancelScheduledValues(time);
                            layer.gain.gain.setValueAtTime(currentGain, time);
                            layer.gain.gain.linearRampToValueAtTime(
                                currentGain + variation * (Math.random() - 0.5), 
                                time + 1 + Math.random() * 2.5
                            );
                        }
                    });
                }, 1000);
            } catch (err) {}
        }

        function createDrone(freq, initialGain, filterType, filterFreq, Q) {
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            const filter = audioContext.createBiquadFilter();
            osc.type = 'sine';
            osc.frequency.value = freq;
            filter.type = filterType;
            filter.frequency.value = filterFreq;
            filter.Q.value = Q;
            osc.connect(filter);
            filter.connect(gain);
            gain.connect(audioContext.destination);
            gain.gain.setValueAtTime(0, audioContext.currentTime);
            if (initialGain > 0) {
                gain.gain.linearRampToValueAtTime(initialGain, audioContext.currentTime + 20);
            }
            osc.start();
            return { osc, gain, filter, baseFreq: freq, baseGain: initialGain };
        }

        function createShepardTone() {
            const shepardLayers = [];
            for (let i = 0; i < 6; i++) {
                const freq = 50 * Math.pow(2, i);
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                osc.type = 'sine';
                osc.frequency.value = freq;
                osc.connect(gain);
                gain.connect(audioContext.destination);
                const envelope = Math.exp(-Math.pow((i - 3), 2) / 4);
                gain.gain.setValueAtTime(0, audioContext.currentTime);
                osc.start();
                shepardLayers.push({ osc, gain, envelope });
            }
            setInterval(() => {
                shepardLayers.forEach(layer => {
                    const time = audioContext.currentTime;
                    const targetGain = layer.envelope * 0.03 * (1 + progressionLevel * 3.5);
                    layer.gain.gain.linearRampToValueAtTime(targetGain, time + 1);
                    const currentFreq = layer.osc.frequency.value;
                    const newFreq = currentFreq / 1.015;
                    layer.osc.frequency.linearRampToValueAtTime(newFreq, time + 0.5);
                    if (newFreq < 50 * 0.9) {
                        layer.osc.frequency.setValueAtTime(newFreq * 2, time + 0.5);
                    }
                });
            }, 400);
            ambientLayers.push(...shepardLayers);
        }

        function createRandomScreams() {
            setInterval(() => {
                if (progressionLevel < 0.4 || Math.random() > (0.18 + progressionLevel * 0.3)) return;
                const now = audioContext.currentTime;
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                const filter = audioContext.createBiquadFilter();
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(900 + Math.random() * 900, now);
                osc.frequency.exponentialRampToValueAtTime(280 + Math.random() * 300, now + 0.5);
                filter.type = 'bandpass';
                filter.frequency.value = 1200 + Math.random() * 1500;
                filter.Q.value = 18;
                osc.connect(filter);
                filter.connect(gain);
                gain.connect(audioContext.destination);
                const maxGain = 0.1 * Math.pow(progressionLevel, 0.7);
                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(maxGain, now + 0.06);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.5);
                osc.start(now);
                try { osc.stop(now + 0.5); } catch(e) {}
                if (navigator.vibrate && Math.random() < 0.5) {
                    navigator.vibrate([120, 60, 120]);
                }
            }, 4500);
        }

        function createSubsonicPulse() {
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            const filter = audioContext.createBiquadFilter();
            osc.type = 'sine';
            osc.frequency.value = 11;
            filter.type = 'lowpass';
            filter.frequency.value = 45;
            osc.connect(filter);
            filter.connect(gain);
            gain.connect(audioContext.destination);
            gain.gain.setValueAtTime(0, audioContext.currentTime);
            osc.start();
            ambientLayers.push({ osc, gain, filter });
            setInterval(() => {
                if (progressionLevel > 0.6) {
                    const time = audioContext.currentTime;
                    gain.gain.linearRampToValueAtTime(0.06 * progressionLevel, time + 0.1);
                    gain.gain.linearRampToValueAtTime(0, time + 0.35);
                }
            }, 2500);
        }

        function createMetallicAmbient() {
            setInterval(() => {
                if (progressionLevel < 0.3 || Math.random() > 0.3) return;
                const now = audioContext.currentTime;
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                const filter = audioContext.createBiquadFilter();
                osc.type = 'triangle';
                const baseFreq = 750 + Math.random() * 2200;
                osc.frequency.value = baseFreq;
                filter.type = 'bandpass';
                filter.frequency.value = baseFreq;
                filter.Q.value = 28;
                osc.connect(filter);
                filter.connect(gain);
                gain.connect(audioContext.destination);
                const maxGain = 0.06 * progressionLevel;
                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(maxGain, now + 2.5);
                gain.gain.linearRampToValueAtTime(0, now + 9);
                filter.frequency.linearRampToValueAtTime(baseFreq * 0.65, now + 9);
                osc.start(now);
                try { osc.stop(now + 9); } catch(e) {}
            }, 10000);
        }

        function createDistantEchoes() {
            setInterval(() => {
                if (progressionLevel < 0.45 || Math.random() > 0.22) return;
                const now = audioContext.currentTime;
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                const filter = audioContext.createBiquadFilter();
                const delay = audioContext.createDelay();
                const delayGain = audioContext.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(180 + Math.random() * 420, now);
                osc.frequency.exponentialRampToValueAtTime(90 + Math.random() * 220, now + 4.5);
                filter.type = 'bandpass';
                filter.frequency.value = 320;
                filter.Q.value = 18;
                delay.delayTime.value = 0.9;
                delayGain.gain.value = 0.65;
                osc.connect(filter);
                filter.connect(gain);
                filter.connect(delay);
                delay.connect(delayGain);
                delayGain.connect(gain);
                gain.connect(audioContext.destination);
                const maxGain = 0.05 * Math.pow(progressionLevel, 1.3);
                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(maxGain, now + 1.2);
                gain.gain.linearRampToValueAtTime(0, now + 5.5);
                osc.start(now);
                try { osc.stop(now + 5.5); } catch(e) {}
            }, 13000);
        }

        function updateAtmosphere(progress) {
            if (!audioContext) return;
            try {
                const time = audioContext.currentTime;
                // DEEPEST INFRASOUND - нарастает агрессивно
                for (let i = 0; i < 5; i++) {
                    if (ambientLayers[i]) {
                        const infraGain = (0.06 - i * 0.01) + progress * 0.18;
                        ambientLayers[i].gain.gain.linearRampToValueAtTime(infraGain, time + 2);
                    }
                }
                // Binaural - МАКСИМУМ
                if (ambientLayers[5] && ambientLayers[6]) {
                    const bassGain = 0.04 + progress * 0.18;
                    ambientLayers[5].gain.gain.linearRampToValueAtTime(bassGain, time + 2);
                    ambientLayers[6].gain.gain.linearRampToValueAtTime(bassGain, time + 2);
                    const newFreq = 38 - progress * 20;
                    ambientLayers[5].osc.frequency.linearRampToValueAtTime(newFreq, time + 2);
                    ambientLayers[6].osc.frequency.linearRampToValueAtTime(newFreq + 0.9, time + 2);
                }
                // Dissonance layers
                for (let i = 7; i < 11; i++) {
                    if (ambientLayers[i] && progress > 0.15) {
                        const disGain = Math.pow((progress - 0.15) / 0.85, 1.3) * 0.2;
                        ambientLayers[i].gain.gain.linearRampToValueAtTime(disGain, time + 2);
                    }
                }
                // Tritone
                if (ambientLayers[11] && ambientLayers[12] && progress > 0.4) {
                    const tritoneGain = Math.pow((progress - 0.4) / 0.6, 1.8) * 0.25;
                    ambientLayers[11].gain.gain.linearRampToValueAtTime(tritoneGain, time + 2);
                    ambientLayers[12].gain.gain.linearRampToValueAtTime(tritoneGain, time + 2);
                }
                // METALLIC
                if (ambientLayers[13] && ambientLayers[14] && progress > 0.5) {
                    const metallicGain = Math.pow((progress - 0.5) / 0.5, 2.2) * 0.16;
                    ambientLayers[13].gain.gain.linearRampToValueAtTime(metallicGain, time + 2);
                    ambientLayers[14].gain.gain.linearRampToValueAtTime(metallicGain, time + 2);
                }
                // High frequency
                if (ambientLayers[15] && ambientLayers[16] && progress > 0.55) {
                    const detunedGain = Math.pow((progress - 0.55) / 0.45, 1.8) * 0.14;
                    ambientLayers[15].gain.gain.linearRampToValueAtTime(detunedGain, time + 2);
                    ambientLayers[16].gain.gain.linearRampToValueAtTime(detunedGain, time + 2);
                }
            } catch (err) {}
        }

        function increaseIntensity(lineIndex) {
            progressionLevel = lineIndex / story.length;
            updateAtmosphere(progressionLevel);
            
            // Обновляем интенсивность живых слов
            if (typeof livingWords !== 'undefined') {
                livingWords.setIntensity(progressionLevel);
            }
            
            // НОВОЕ: Автоматическое обновление виньетки
            if (typeof vignetteControl !== 'undefined') {
                vignetteControl.update(progressionLevel);
            }
            
            document.querySelector('.static').style.opacity = 0.12 + progressionLevel * 0.55;
            document.querySelector('.breath-overlay').style.animation = 
                `breatheOppressive ${Math.max(0.5, 7 - progressionLevel * 6.5)}s infinite`;
            document.querySelector('.grain').style.opacity = progressionLevel * 0.6;
            
            if (progressionLevel > 0.45 && Math.random() < (progressionLevel - 0.45) * 0.15) {
                triggerWatching();
            }
            if (progressionLevel > 0.35 && Math.random() < (progressionLevel - 0.35) * 0.18) {
                triggerPeripheralHorror();
            }
            if (progressionLevel > 0.25 && Math.random() < (progressionLevel - 0.25) * 0.9) {
                addForgottenWord();
            }
            if (progressionLevel > 0.5 && Math.random() < 0.04) {
                triggerScreenTear();
            }
            
            // НОВОЕ: Автоматическое формирование глаз при 60% прогресса
            if (progressionLevel > 0.6 && progressionLevel < 0.65 && !window.eyesFormed) {
                window.eyesFormed = true;
                setTimeout(() => {
                    livingWords.formEyes();
                }, 2000);
            }
            
            // НОВОЕ: Все слова становятся красными при 85% прогресса
            if (progressionLevel > 0.85 && !window.allIntense) {
                window.allIntense = true;
                livingWords.makeAllIntense();
            }
            
            // НОВОЕ: Жуткий смайлик при 95% прогресса
            if (progressionLevel > 0.95 && !window.smileFormed) {
                window.smileFormed = true;
                setTimeout(() => {
                    livingWords.formHorrorSmile();
                    vignetteControl.suffocate(3000);
                    
                    // Через 3 секунды запускаем череду образов
                    setTimeout(() => {
                        if (typeof livingWords.rapidImageSequence === 'function') {
                            livingWords.rapidImageSequence();
                        }
                    }, 3000);
                }, 1000);
            }
        }

        function addObsessiveWord(word) {
            if (!word || obsessiveWords.length > 60) return;
            const wordEl = document.createElement('div');
            wordEl.className = 'obsessive-word';
            wordEl.textContent = word;
            wordEl.style.left = (2 + Math.random() * 96) + '%';
            wordEl.style.top = (2 + Math.random() * 96) + '%';
            wordEl.style.transform = `rotate(${(Math.random() - 0.5) * 35}deg)`;
            document.getElementById('obsessive-words').appendChild(wordEl);
            setTimeout(() => wordEl.classList.add('active'), 100);
            obsessiveWords.push(wordEl);
        }

        function addForgottenWord() {
            if (forgottenWords.length > 350) return;
            const word = FORGOTTEN[Math.floor(Math.random() * FORGOTTEN.length)];
            const wordEl = document.createElement('div');
            wordEl.className = 'forgotten-word';
            wordEl.textContent = word;
            wordEl.style.left = (1 + Math.random() * 98) + '%';
            wordEl.style.top = (1 + Math.random() * 98) + '%';
            wordEl.style.transform = `rotate(${(Math.random() - 0.5) * 45}deg)`;
            document.getElementById('forgotten-words').appendChild(wordEl);
            setTimeout(() => wordEl.classList.add('active'), 100);
            forgottenWords.push(wordEl);
        }

        function triggerBlackout(duration) {
            const blackout = document.querySelector('.blackout');
            blackout.classList.add('active');
            setTimeout(() => blackout.classList.remove('active'), duration);
        }

        function triggerStrobe(duration) {
            const strobe = document.querySelector('.strobe');
            strobe.classList.add('active');
            setTimeout(() => strobe.classList.remove('active'), duration);
            if (navigator.vibrate) {
                const pattern = [];
                for (let i = 0; i < duration / 80; i++) {
                    pattern.push(50, 30);
                }
                navigator.vibrate(pattern);
            }
        }

        function triggerChromatic() {
            const chromatic = document.querySelector('.chromatic');
            chromatic.classList.add('active');
            setTimeout(() => chromatic.classList.remove('active'), 300);
        }

        function triggerWatching() {
            isWatching = true;
            const watching = document.querySelector('.watching-overlay');
            watching.style.setProperty('--x', (mouseX / window.innerWidth * 100) + '%');
            watching.style.setProperty('--y', (mouseY / window.innerHeight * 100) + '%');
            watching.classList.add('active');
            document.getElementById('cursor').classList.add('watching');
            setTimeout(() => {
                watching.classList.remove('active');
                document.getElementById('cursor').classList.remove('watching');
                isWatching = false;
            }, 5000);
            if (navigator.vibrate) {
                navigator.vibrate([120, 60, 120, 60, 120]);
            }
        }

        function triggerPeripheralHorror() {
            const side = Math.random() < 0.5 ? 'left' : 'right';
            const peripheral = document.querySelector(`.peripheral-horror.${side}`);
            peripheral.classList.add('active');
            setTimeout(() => peripheral.classList.remove('active'), 150);
            if (navigator.vibrate && Math.random() < 0.4) {
                navigator.vibrate(60);
            }
        }

        function triggerScreenTear() {
            const tear = document.querySelector('.screen-tear');
            tear.classList.add('active');
            setTimeout(() => tear.classList.remove('active'), 600);
        }

        function triggerTimeDistortion() {
            const distortion = document.querySelector('.time-distortion');
            distortion.classList.add('active');
            setTimeout(() => distortion.classList.remove('active'), 4000);
        }

        function triggerRealityGlitch() {
            const glitch = document.querySelector('.reality-glitch');
            glitch.classList.add('active');
            setTimeout(() => glitch.classList.remove('active'), 400);
            if (navigator.vibrate) {
                navigator.vibrate([60, 40, 60, 40, 60]);
            }
        }

        async function startExperience() {
            const content = document.getElementById('content');
            try {
                for (let i = 0; i < story.length; i++) {
                    const parts = story[i].split('|');
                    const text = parts[0];
                    const wait = parseInt(parts[1]);
                    const effects = parts.slice(2);
                    increaseIntensity(i);
                    content.innerHTML = '';
                    if (text.trim()) {
                        const div = document.createElement('div');
                        div.className = 'line';
                        div.innerHTML = text;
                        content.appendChild(div);
                        setTimeout(() => div.classList.add('active'), 100);
                        for (const effect of effects) {
                            if (effect === 'break') {
                                div.classList.add('break-wall');
                            }
                            else if (effect === 'glitch') {
                                setTimeout(() => div.classList.add('glitched'), 100);
                                setTimeout(() => div.classList.remove('glitched'), 2000);
                            }
                            else if (effect === 'shake') {
                                content.classList.add('shake');
                            }
                            else if (effect === 'distorted') {
                                setTimeout(() => div.classList.add('distorted'), 100);
                            }
                            else if (effect === 'watching') {
                                triggerWatching();
                            }
                            else if (effect === 'cursormove') {
                                forceCursorMovement(2500);
                            }
                            else if (effect === 'peripheral') {
                                triggerPeripheralHorror();
                            }
                            else if (effect === 'chromatic') {
                                triggerChromatic();
                            }
                            else if (effect === 'screentear') {
                                triggerScreenTear();
                            }
                            else if (effect === 'timedistort') {
                                triggerTimeDistortion();
                            }
                            else if (effect === 'reality') {
                                triggerRealityGlitch();
                            }
                            else if (effect === 'heartbeat') {
                                const hb = document.querySelector('.heartbeat');
                                hb.classList.add('active');
                                setTimeout(() => hb.classList.remove('active'), 3500);
                            }
                            else if (effect === 'water') {
                                for (let j = 0; j < 4; j++) {
                                    setTimeout(() => createWaterDrop(), j * 250);
                                }
                            }
                            else if (effect === 'blooddrop') {
                                for (let j = 0; j < 3; j++) {
                                    setTimeout(() => createBloodDrop(), j * 350);
                                }
                            }
                            else if (effect === 'wetstain') {
                                createWetStain();
                            }
                            else if (effect === 'breathfog') {
                                triggerBreathFog();
                            }
                            else if (effect === 'crack') {
                                triggerScreenCrack();
                            }
                            else if (effect === 'silence') {
                                if (audioContext) {
                                    ambientLayers.forEach(layer => {
                                        if (layer && layer.gain) {
                                            const time = audioContext.currentTime;
                                            const current = layer.gain.gain.value;
                                            layer.gain.gain.linearRampToValueAtTime(current * 0.08, time + 0.5);
                                            setTimeout(() => {
                                                layer.gain.gain.linearRampToValueAtTime(current, time + 2.5);
                                            }, 1000);
                                        }
                                    });
                                }
                            }
                            else if (effect.startsWith('subliminal:')) {
                                const msg = effect.split(':')[1];
                                const subliminal = document.querySelector('.subliminal');
                                subliminal.textContent = msg;
                                subliminal.classList.add('active');
                                setTimeout(() => subliminal.classList.remove('active'), 40);
                            }
                            else if (effect.startsWith('blackout:')) {
                                const duration = parseInt(effect.split(':')[1]);
                                setTimeout(() => triggerBlackout(duration), 100);
                            }
                            else if (effect.startsWith('strobe:')) {
                                const duration = parseInt(effect.split(':')[1]);
                                setTimeout(() => triggerStrobe(duration), 100);
                            }
                            else if (effect === 'shadow') {
                                const side = Math.random() < 0.5 ? 'left' : 'right';
                                const shadowEl = document.querySelector(`.shadow.${side}`);
                                shadowEl.classList.add('active');
                                setTimeout(() => shadowEl.classList.remove('active'), 3000);
                            }
                            else if (effect === 'blood') {
                                div.classList.add('blood');
                                document.querySelector('.blood-screen').classList.add('active');
                                setTimeout(() => document.querySelector('.blood-screen').classList.remove('active'), 4000);
                            }
                            else if (effect === 'redFlicker') {
                                const flickerEl = document.querySelector('.red-flicker');
                                flickerEl.classList.add('active');
                                setTimeout(() => flickerEl.classList.remove('active'), 3000);
                            }
                            else if (effect === 'trail') {
                                setTimeout(() => div.classList.add('text-trail'), 100);
                            }
                            else if (effect === 'double') {
                                setTimeout(() => div.classList.add('double-vision'), 100);
                            }
                            else if (effect === 'freeze') {
                                setTimeout(() => div.classList.add('time-freeze'), 100);
                            }
                            else if (effect.startsWith('obsess:')) {
                                addObsessiveWord(effect.split(':')[1]);
                            }
                            else if (effect.startsWith('sound:')) {
                                playSound(effect.split(':')[1]);
                            }
                            else if (effect === 'smile') {
                                livingWords.formHorrorSmile();
                                vignetteControl.suffocate(3000);
                            }
                            else if (effect === 'eyes') {
                                livingWords.formEyes();
                            }
                            else if (effect === 'squeeze') {
                                vignetteControl.squeeze(0.98, 1500);
                            }
                            else if (effect === 'allintense') {
                                livingWords.makeAllIntense();
                            }
                            else if (effect === 'skull') {
                                livingWords.formSkull();
                            }
                            else if (effect === 'sex') {
                                livingWords.formSexSymbol();
                            }
                            else if (effect === 'death') {
                                livingWords.formDeathSymbol();
                            }
                            else if (effect === 'sequence') {
                                livingWords.rapidImageSequence();
                            }
                            else if (effect.startsWith('camera:')) {
                                const cameraEffect = effect.split(':')[1];
                                if (cameraEffect === 'zoom') {
                                    content.classList.add('camera-zoom');
                                    setTimeout(() => content.classList.remove('camera-zoom'), 500);
                                } else if (cameraEffect === 'shake') {
                                    content.classList.add('camera-shake');
                                    setTimeout(() => content.classList.remove('camera-shake'), 300);
                                }
                            }
                            else if (effect.startsWith('subliminal:')) {
                                const subliminalText = effect.split(':')[1];
                                setTimeout(() => showSubliminal(subliminalText), Math.random() * wait);
                            }
                            else if (effect === 'morph') {
                                livingWords.morphSmile();
                            }
                            else if (effect === 'zoom') {
                                livingWords.zoomToViewer();
                            }
                        }
                        if (effects.includes('shake')) {
                            setTimeout(() => content.classList.remove('shake'), 500);
                        }
                    }
                    await new Promise(resolve => setTimeout(resolve, wait));
                }
                
                // ФИНАЛЬНЫЕ ЭФФЕКТЫ - автоматическая трансформация
                setTimeout(() => {
                    livingWords.morphSmile();
                    setTimeout(() => {
                        livingWords.zoomToViewer();
                    }, 7000);
                }, 2000);
                
                // Fade out
                if (audioContext) {
                    const time = audioContext.currentTime;
                    ambientLayers.forEach(layer => {
                        if (layer && layer.gain) {
                            layer.gain.gain.linearRampToValueAtTime(0, time + 12);
                        }
                    });
                }
                setTimeout(() => {
                    if (audioContext) {
                        ambientLayers.forEach(layer => {
                            if (layer && layer.osc) {
                                try { layer.osc.stop(); } catch(e) {}
                            }
                        });
                    }
                    location.reload();
                }, 15000);
            } catch (err) {}
        }

        function playSound(type) {
            // Сначала проверяем новую звуковую систему
            if (soundSystem.initialized) {
                if (type === 'crunch') {
                    soundSystem.play('crunch', 0.4);
                    return;
                }
                else if (type === 'creak') {
                    soundSystem.play('creak', 0.3);
                    return;
                }
                else if (type === 'machine') {
                    soundSystem.play('machine', 0.25);
                    return;
                }
                else if (type === 'scrub') {
                    soundSystem.play('scrub', 0.35);
                    return;
                }
            }
            
            // Существующая система звуков
            if (!audioContext) return;
            const now = audioContext.currentTime;
            if (type === 'tick') {
                const osc1 = audioContext.createOscillator();
                const osc2 = audioContext.createOscillator();
                const gain = audioContext.createGain();
                const filter = audioContext.createBiquadFilter();
                osc1.type = 'sine';
                osc2.type = 'sine';
                osc1.frequency.setValueAtTime(52, now);
                osc1.frequency.exponentialRampToValueAtTime(32, now + 0.1);
                osc2.frequency.setValueAtTime(104, now);
                osc2.frequency.exponentialRampToValueAtTime(64, now + 0.1);
                filter.type = 'lowpass';
                filter.frequency.value = 140;
                filter.Q.value = 10;
                osc1.connect(filter);
                osc2.connect(filter);
                filter.connect(gain);
                gain.connect(audioContext.destination);
                gain.gain.setValueAtTime(0.4, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.18);
                osc1.start(now);
                osc2.start(now);
                try {
                    osc1.stop(now + 0.18);
                    osc2.stop(now + 0.18);
                } catch(e) {}
                if (navigator.vibrate) {
                    navigator.vibrate(90);
                }
            }
            else if (type === 'step') {
                for (let i = 0; i < 2; i++) {
                    setTimeout(() => {
                        const noiseBuffer1 = audioContext.createBuffer(1, 8192, audioContext.sampleRate);
                        const noiseData1 = noiseBuffer1.getChannelData(0);
                        for (let j = 0; j < 8192; j++) {
                            noiseData1[j] = (Math.random() * 2 - 1) * Math.exp(-j / 1800);
                        }
                        const noise1 = audioContext.createBufferSource();
                        noise1.buffer = noiseBuffer1;
                        const filter1 = audioContext.createBiquadFilter();
                        filter1.type = 'lowpass';
                        filter1.frequency.value = 75 + Math.random() * 35;
                        filter1.Q.value = 4;
                        const gain1 = audioContext.createGain();
                        noise1.connect(filter1);
                        filter1.connect(gain1);
                        gain1.connect(audioContext.destination);
                        const t = audioContext.currentTime;
                        gain1.gain.setValueAtTime(0.5, t);
                        gain1.gain.exponentialRampToValueAtTime(0.01, t + 0.4);
                        noise1.start(t);
                        const noiseBuffer2 = audioContext.createBuffer(1, 4096, audioContext.sampleRate);
                        const noiseData2 = noiseBuffer2.getChannelData(0);
                        for (let j = 0; j < 4096; j++) {
                            noiseData2[j] = (Math.random() * 2 - 1) * (j < 600 ? 1 : Math.exp(-(j - 600) / 900));
                        }
                        const noise2 = audioContext.createBufferSource();
                        noise2.buffer = noiseBuffer2;
                        const filter2 = audioContext.createBiquadFilter();
                        filter2.type = 'bandpass';
                        filter2.frequency.value = 380 + Math.random() * 650;
                        filter2.Q.value = 14;
                        const gain2 = audioContext.createGain();
                        noise2.connect(filter2);
                        filter2.connect(gain2);
                        gain2.connect(audioContext.destination);
                        gain2.gain.setValueAtTime(0.28, t);
                        gain2.gain.exponentialRampToValueAtTime(0.01, t + 0.18);
                        noise2.start(t);
                        const noiseBuffer3 = audioContext.createBuffer(1, 2048, audioContext.sampleRate);
                        const noiseData3 = noiseBuffer3.getChannelData(0);
                        for (let j = 0; j < 2048; j++) {
                            noiseData3[j] = (Math.random() * 2 - 1) * (j < 250 ? 1 : 0);
                        }
                        const noise3 = audioContext.createBufferSource();
                        noise3.buffer = noiseBuffer3;
                        const filter3 = audioContext.createBiquadFilter();
                        filter3.type = 'highpass';
                        filter3.frequency.value = 1400 + Math.random() * 1100;
                        filter3.Q.value = 10;
                        const gain3 = audioContext.createGain();
                        noise3.connect(filter3);
                        filter3.connect(gain3);
                        gain3.connect(audioContext.destination);
                        gain3.gain.setValueAtTime(0.18, t);
                        gain3.gain.exponentialRampToValueAtTime(0.01, t + 0.1);
                        noise3.start(t);
                        const delay = audioContext.createDelay();
                        delay.delayTime.value = 0.1;
                        const delayGain = audioContext.createGain();
                        delayGain.gain.value = 0.35;
                        filter1.connect(delay);
                        delay.connect(delayGain);
                        delayGain.connect(audioContext.destination);
                        if (navigator.vibrate) {
                            navigator.vibrate([110, 35, 70]);
                        }
                    }, i * 600);
                }
            }
            else if (type === 'metallic') {
                const filter1 = audioContext.createBiquadFilter();
                const filter2 = audioContext.createBiquadFilter();
                const gain = audioContext.createGain();
                filter1.type = 'bandpass';
                filter1.frequency.value = 2400 + Math.random() * 2200;
                filter1.Q.value = 18;
                filter2.type = 'highpass';
                filter2.frequency.value = 1150;
                const buffer = audioContext.createBuffer(1, 16384, audioContext.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < 16384; i++) {
                    data[i] = (Math.random() * 2 - 1) * (1 - i / 16384);
                }
                const noise = audioContext.createBufferSource();
                noise.buffer = buffer;
                noise.playbackRate.value = 0.65;
                noise.connect(filter1);
                filter1.connect(filter2);
                filter2.connect(gain);
                gain.connect(audioContext.destination);
                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(0.2, now + 0.18);
                gain.gain.linearRampToValueAtTime(0.14, now + 1.4);
                gain.gain.linearRampToValueAtTime(0, now + 2);
                const lfo = audioContext.createOscillator();
                const lfoGain = audioContext.createGain();
                lfo.frequency.value = 3.8;
                lfoGain.gain.value = 450;
                lfo.connect(lfoGain);
                lfoGain.connect(filter1.frequency);
                noise.start(now);
                lfo.start(now);
                setTimeout(() => {
                    try {
                        noise.stop();
                        lfo.stop();
                    } catch(e) {}
                }, 2000);
                if (navigator.vibrate) {
                    navigator.vibrate([170, 90, 170, 90, 170]);
                }
            }
            else if (type === 'distant_voices') {
                for (let i = 0; i < 3; i++) {
                    setTimeout(() => {
                        const osc1 = audioContext.createOscillator();
                        const osc2 = audioContext.createOscillator();
                        const gain = audioContext.createGain();
                        const filter = audioContext.createBiquadFilter();
                        const delay = audioContext.createDelay();
                        const delayGain = audioContext.createGain();
                        osc1.type = 'sawtooth';
                        osc2.type = 'sine';
                        const baseFreq = 170 + Math.random() * 130;
                        osc1.frequency.setValueAtTime(baseFreq, now);
                        osc2.frequency.setValueAtTime(baseFreq * 1.01, now);
                        filter.type = 'bandpass';
                        filter.frequency.value = 280 + Math.random() * 220;
                        filter.Q.value = 10;
                        delay.delayTime.value = 0.35;
                        delayGain.gain.value = 0.45;
                        osc1.connect(filter);
                        osc2.connect(filter);
                        filter.connect(gain);
                        filter.connect(delay);
                        delay.connect(delayGain);
                        delayGain.connect(gain);
                        gain.connect(audioContext.destination);
                        const t = audioContext.currentTime;
                        gain.gain.setValueAtTime(0, t);
                        gain.gain.linearRampToValueAtTime(0.1, t + 0.6);
                        gain.gain.linearRampToValueAtTime(0.07, t + 2.5);
                        gain.gain.linearRampToValueAtTime(0, t + 3.5);
                        osc1.start(t);
                        osc2.start(t);
                        try {
                            osc1.stop(t + 3.5);
                            osc2.stop(t + 3.5);
                        } catch(e) {}
                    }, i * 1100 + Math.random() * 600);
                }
            }
            else if (type === 'void_hum') {
                const osc1 = audioContext.createOscillator();
                const osc2 = audioContext.createOscillator();
                const osc3 = audioContext.createOscillator();
                const gain = audioContext.createGain();
                const filter = audioContext.createBiquadFilter();
                osc1.type = 'sine';
                osc2.type = 'sine';
                osc3.type = 'triangle';
                osc1.frequency.value = 58;
                osc2.frequency.value = 58.5;
                osc3.frequency.value = 87;
                filter.type = 'lowpass';
                filter.frequency.value = 180;
                filter.Q.value = 14;
                osc1.connect(filter);
                osc2.connect(filter);
                osc3.connect(filter);
                filter.connect(gain);
                gain.connect(audioContext.destination);
                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(0.25, now + 2.5);
                gain.gain.linearRampToValueAtTime(0.2, now + 9);
                gain.gain.linearRampToValueAtTime(0, now + 11);
                filter.frequency.linearRampToValueAtTime(75, now + 11);
                osc1.start(now);
                osc2.start(now);
                osc3.start(now);
                setTimeout(() => {
                    try {
                        osc1.stop();
                        osc2.stop();
                        osc3.stop();
                    } catch(e) {}
                }, 11000);
            }
            else if (type === 'pressure') {
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                const filter = audioContext.createBiquadFilter();
                osc.type = 'sine';
                osc.frequency.value = 17;
                filter.type = 'lowpass';
                filter.frequency.value = 38;
                filter.Q.value = 22;
                osc.connect(filter);
                filter.connect(gain);
                gain.connect(audioContext.destination);
                const lfo = audioContext.createOscillator();
                const lfoGain = audioContext.createGain();
                lfo.frequency.value = 0.35;
                lfoGain.gain.value = 0.18;
                lfo.connect(lfoGain);
                lfoGain.connect(gain.gain);
                gain.gain.setValueAtTime(0.28, now);
                osc.start(now);
                lfo.start(now);
                setTimeout(() => {
                    try {
                        gain.gain.linearRampToValueAtTime(0, audioContext.currentTime + 1.2);
                        setTimeout(() => {
                            osc.stop();
                            lfo.stop();
                        }, 1200);
                    } catch(e) {}
                }, 4500);
                if (navigator.vibrate) {
                    navigator.vibrate([220, 110, 220, 110, 220, 110, 220]);
                }
            }
            else if (type === 'water' || type === 'waterambient') {
                const gain = audioContext.createGain();
                const filter1 = audioContext.createBiquadFilter();
                const filter2 = audioContext.createBiquadFilter();
                filter1.type = 'bandpass';
                filter1.frequency.value = 420 + Math.random() * 380;
                filter1.Q.value = 1.3;
                filter2.type = 'highpass';
                filter2.frequency.value = 170;
                const buffer = audioContext.createBuffer(1, 12288, audioContext.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < 12288; i++) {
                    data[i] = Math.random() * 2 - 1;
                }
                const noise = audioContext.createBufferSource();
                noise.buffer = buffer;
                noise.loop = true;
                noise.connect(filter1);
                filter1.connect(filter2);
                filter2.connect(gain);
                gain.connect(audioContext.destination);
                const duration = type === 'waterambient' ? 7000 : 4500;
                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(0.18, now + 0.7);
                gain.gain.linearRampToValueAtTime(0.14, now + (duration/1000) - 0.6);
                gain.gain.linearRampToValueAtTime(0, now + (duration/1000));
                const lfo = audioContext.createOscillator();
                const lfoGain = audioContext.createGain();
                lfo.frequency.value = 0.8;
                lfoGain.gain.value = 200;
                lfo.connect(lfoGain);
                lfoGain.connect(filter1.frequency);
                noise.start(now);
                lfo.start(now);
                setTimeout(() => {
                    try {
                        noise.stop();
                        lfo.stop();
                    } catch(e) {}
                }, duration);
            }
            else if (type === 'machine') {
                const noiseBuffer1 = audioContext.createBuffer(1, 44100, audioContext.sampleRate);
                const noiseData1 = noiseBuffer1.getChannelData(0);
                for (let i = 0; i < 44100; i++) {
                    noiseData1[i] = (Math.random() * 2 - 1) * 0.85;
                }
                const noise1 = audioContext.createBufferSource();
                noise1.buffer = noiseBuffer1;
                noise1.loop = true;
                const filter1 = audioContext.createBiquadFilter();
                filter1.type = 'lowpass';
                filter1.frequency.value = 115;
                filter1.Q.value = 18;
                const gain1 = audioContext.createGain();
                noise1.connect(filter1);
                filter1.connect(gain1);
                gain1.connect(audioContext.destination);
                gain1.gain.setValueAtTime(0, now);
                gain1.gain.linearRampToValueAtTime(0.2, now + 0.9);
                gain1.gain.setValueAtTime(0.2, now + 3.5);
                gain1.gain.linearRampToValueAtTime(0, now + 4.2);
                const noiseBuffer2 = audioContext.createBuffer(1, 44100, audioContext.sampleRate);
                const noiseData2 = noiseBuffer2.getChannelData(0);
                for (let i = 0; i < 44100; i++) {
                    noiseData2[i] = (Math.random() * 2 - 1) * 0.65;
                }
                const noise2 = audioContext.createBufferSource();
                noise2.buffer = noiseBuffer2;
                noise2.loop = true;
                const filter2 = audioContext.createBiquadFilter();
                filter2.type = 'bandpass';
                filter2.frequency.value = 230;
                filter2.Q.value = 28;
                const gain2 = audioContext.createGain();
                noise2.connect(filter2);
                filter2.connect(gain2);
                gain2.connect(audioContext.destination);
                gain2.gain.setValueAtTime(0, now);
                gain2.gain.linearRampToValueAtTime(0.14, now + 0.9);
                gain2.gain.setValueAtTime(0.14, now + 3.5);
                gain2.gain.linearRampToValueAtTime(0, now + 4.2);
                const lfo1 = audioContext.createOscillator();
                const lfoGain1 = audioContext.createGain();
                lfo1.frequency.value = 0.25;
                lfoGain1.gain.value = 22;
                lfo1.connect(lfoGain1);
                lfoGain1.connect(filter1.frequency);
                const lfo2 = audioContext.createOscillator();
                const lfoGain2 = audioContext.createGain();
                lfo2.frequency.value = 0.4;
                lfoGain2.gain.value = 35;
                lfo2.connect(lfoGain2);
                lfoGain2.connect(filter2.frequency);
                noise1.start(now);
                noise2.start(now);
                lfo1.start(now);
                lfo2.start(now);
                setTimeout(() => {
                    try {
                        noise1.stop();
                        noise2.stop();
                        lfo1.stop();
                        lfo2.stop();
                    } catch(e) {}
                }, 4200);
                if (navigator.vibrate) {
                    const pattern = [];
                    for (let i = 0; i < 9; i++) {
                        pattern.push(160, 220);
                    }
                    navigator.vibrate(pattern);
                }
            }
            else if (type === 'breathing') {
                for (let i = 0; i < 2; i++) {
                    setTimeout(() => {
                        const inhaleBuffer = audioContext.createBuffer(1, 22050, audioContext.sampleRate);
                        const inhaleData = inhaleBuffer.getChannelData(0);
                        for (let j = 0; j < 22050; j++) {
                            const envelope = Math.sin((j / 22050) * Math.PI);
                            inhaleData[j] = (Math.random() * 2 - 1) * envelope * 0.75;
                        }
                        const inhale = audioContext.createBufferSource();
                        inhale.buffer = inhaleBuffer;
                        const inhaleFilter = audioContext.createBiquadFilter();
                        inhaleFilter.type = 'bandpass';
                        inhaleFilter.frequency.value = 240 + Math.random() * 220;
                        inhaleFilter.Q.value = 3.5;
                        const inhaleGain = audioContext.createGain();
                        inhale.connect(inhaleFilter);
                        inhaleFilter.connect(inhaleGain);
                        inhaleGain.connect(audioContext.destination);
                        const t = audioContext.currentTime;
                        inhaleGain.gain.setValueAtTime(0, t);
                        inhaleGain.gain.linearRampToValueAtTime(0.25, t + 1);
                        inhaleGain.gain.linearRampToValueAtTime(0, t + 1.6);
                        inhaleFilter.frequency.linearRampToValueAtTime(360, t + 0.8);
                        inhale.start(t);
                        setTimeout(() => {
                            const exhaleBuffer = audioContext.createBuffer(1, 33075, audioContext.sampleRate);
                            const exhaleData = exhaleBuffer.getChannelData(0);
                            for (let j = 0; j < 33075; j++) {
                                const envelope = Math.sin((j / 33075) * Math.PI);
                                exhaleData[j] = (Math.random() * 2 - 1) * envelope * 0.65;
                            }
                            const exhale = audioContext.createBufferSource();
                            exhale.buffer = exhaleBuffer;
                            const exhaleFilter = audioContext.createBiquadFilter();
                            exhaleFilter.type = 'bandpass';
                            exhaleFilter.frequency.value = 190 + Math.random() * 160;
                            exhaleFilter.Q.value = 2.8;
                            const exhaleGain = audioContext.createGain();
                            exhale.connect(exhaleFilter);
                            exhaleFilter.connect(exhaleGain);
                            exhaleGain.connect(audioContext.destination);
                            const t2 = audioContext.currentTime;
                            exhaleGain.gain.setValueAtTime(0, t2);
                            exhaleGain.gain.linearRampToValueAtTime(0.2, t2 + 0.7);
                            exhaleGain.gain.linearRampToValueAtTime(0, t2 + 2);
                            exhaleFilter.frequency.linearRampToValueAtTime(170, t2 + 1.4);
                            exhale.start(t2);
                            try {
                                exhale.stop(t2 + 2);
                            } catch(e) {}
                        }, 1600);
                        try {
                            inhale.stop(t + 1.6);
                        } catch(e) {}
                    }, i * 4000);
                }
            }
            else if (type === 'scrub') {
                const noiseBuffer = audioContext.createBuffer(1, 22050, audioContext.sampleRate);
                const noiseData = noiseBuffer.getChannelData(0);
                for (let i = 0; i < 22050; i++) {
                    const cycle = Math.floor(i / 2000);
                    const intensity = 0.75 + Math.sin(cycle * 0.5) * 0.25;
                    noiseData[i] = (Math.random() * 2 - 1) * intensity;
                }
                const noise = audioContext.createBufferSource();
                noise.buffer = noiseBuffer;
                noise.playbackRate.value = 0.75 + Math.random() * 0.5;
                const filter1 = audioContext.createBiquadFilter();
                filter1.type = 'highpass';
                filter1.frequency.value = 580 + Math.random() * 450;
                filter1.Q.value = 3.5;
                const filter2 = audioContext.createBiquadFilter();
                filter2.type = 'bandpass';
                filter2.frequency.value = 1900 + Math.random() * 1600;
                filter2.Q.value = 10;
                const gain = audioContext.createGain();
                noise.connect(filter1);
                filter1.connect(filter2);
                filter2.connect(gain);
                gain.connect(audioContext.destination);
                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(0.14, now + 0.1);
                gain.gain.linearRampToValueAtTime(0.1, now + 0.3);
                gain.gain.linearRampToValueAtTime(0.14, now + 0.4);
                gain.gain.linearRampToValueAtTime(0, now + 0.6);
                const lfo = audioContext.createOscillator();
                const lfoGain = audioContext.createGain();
                lfo.frequency.value = 5.5 + Math.random() * 4.5;
                lfoGain.gain.value = 350;
                lfo.connect(lfoGain);
                lfoGain.connect(filter2.frequency);
                noise.start(now);
                lfo.start(now);
                setTimeout(() => {
                    try {
                        noise.stop();
                        lfo.stop();
                    } catch(e) {}
                }, 600);
                if (navigator.vibrate) {
                    navigator.vibrate([90, 50, 90, 50, 90]);
                }
            }
            else if (type === 'tear') {
                const tearBuffer = audioContext.createBuffer(1, 11025, audioContext.sampleRate);
                const tearData = tearBuffer.getChannelData(0);
                for (let i = 0; i < 11025; i++) {
                    const progress = i / 11025;
                    const intensity = Math.pow(progress, 0.3) * (1 - progress);
                    const fiber = Math.sin(i * 0.3) * 0.35;
                    tearData[i] = ((Math.random() * 2 - 1) * 0.75 + fiber) * intensity;
                }
                const tear = audioContext.createBufferSource();
                tear.buffer = tearBuffer;
                tear.playbackRate.value = 0.65 + Math.random() * 0.35;
                const tearFilter1 = audioContext.createBiquadFilter();
                tearFilter1.type = 'highpass';
                tearFilter1.frequency.value = 380;
                tearFilter1.Q.value = 3.5;
                const tearFilter2 = audioContext.createBiquadFilter();
                tearFilter2.type = 'bandpass';
                tearFilter2.frequency.value = 1150;
                tearFilter2.Q.value = 10;
                const tearGain = audioContext.createGain();
                tear.connect(tearFilter1);
                tearFilter1.connect(tearFilter2);
                tearFilter2.connect(tearGain);
                tearGain.connect(audioContext.destination);
                tearGain.gain.setValueAtTime(0.18, now);
                tearGain.gain.linearRampToValueAtTime(0.1, now + 0.18);
                tearGain.gain.exponentialRampToValueAtTime(0.01, now + 0.45);
                tearFilter2.frequency.linearRampToValueAtTime(580, now + 0.45);
                tear.start(now);
                try {
                    tear.stop(now + 0.45);
                } catch(e) {}
                if (navigator.vibrate) {
                    navigator.vibrate([70, 35, 100]);
                }
            }
            else if (type === 'scream') {
                const screamBuffer1 = audioContext.createBuffer(1, 22050, audioContext.sampleRate);
                const screamData1 = screamBuffer1.getChannelData(0);
                for (let i = 0; i < 22050; i++) {
                    const envelope = Math.sin((i / 22050) * Math.PI * 2);
                    const chaos = Math.sin(i * 0.05) * Math.sin(i * 0.012);
                    screamData1[i] = (Math.random() * 2 - 1) * Math.abs(envelope) * (0.85 + chaos * 0.15);
                }
                const scream1 = audioContext.createBufferSource();
                scream1.buffer = screamBuffer1;
                scream1.playbackRate.value = 1.15 + Math.random() * 0.35;
                const screamFilter1 = audioContext.createBiquadFilter();
                screamFilter1.type = 'bandpass';
                screamFilter1.frequency.value = 1750;
                screamFilter1.Q.value = 18;
                const screamGain1 = audioContext.createGain();
                scream1.connect(screamFilter1);
                screamFilter1.connect(screamGain1);
                screamGain1.connect(audioContext.destination);
                screamGain1.gain.setValueAtTime(0, now);
                screamGain1.gain.linearRampToValueAtTime(0.2, now + 0.1);
                screamGain1.gain.linearRampToValueAtTime(0.16, now + 0.35);
                screamGain1.gain.exponentialRampToValueAtTime(0.01, now + 0.7);
                screamFilter1.frequency.exponentialRampToValueAtTime(750, now + 0.7);
                const screamBuffer2 = audioContext.createBuffer(1, 11025, audioContext.sampleRate);
                const screamData2 = screamBuffer2.getChannelData(0);
                for (let i = 0; i < 11025; i++) {
                    const envelope = i < 2200 ? 1 : Math.exp(-(i - 2200) / 2200);
                    screamData2[i] = (Math.random() * 2 - 1) * envelope;
                }
                const scream2 = audioContext.createBufferSource();
                scream2.buffer = screamBuffer2;
                const screamFilter2 = audioContext.createBiquadFilter();
                screamFilter2.type = 'highpass';
                screamFilter2.frequency.value = 2900;
                screamFilter2.Q.value = 10;
                const screamGain2 = audioContext.createGain();
                scream2.connect(screamFilter2);
                screamFilter2.connect(screamGain2);
                screamGain2.connect(audioContext.destination);
                screamGain2.gain.setValueAtTime(0.14, now);
                screamGain2.gain.exponentialRampToValueAtTime(0.01, now + 0.35);
                scream1.start(now);
                scream2.start(now);
                try {
                    scream1.stop(now + 0.7);
                    scream2.stop(now + 0.35);
                } catch(e) {}
                if (navigator.vibrate) {
                    navigator.vibrate([170, 60, 220, 60, 170]);
                }
            }
            else if (type === 'crack') {
                const crackBuffer = audioContext.createBuffer(1, 2205, audioContext.sampleRate);
                const crackData = crackBuffer.getChannelData(0);
                for (let i = 0; i < 2205; i++) {
                    const envelope = i < 120 ? 1 : Math.exp(-(i - 120) / 320);
                    crackData[i] = (Math.random() * 2 - 1) * envelope;
                }
                const crack = audioContext.createBufferSource();
                crack.buffer = crackBuffer;
                const crackFilter1 = audioContext.createBiquadFilter();
                crackFilter1.type = 'highpass';
                crackFilter1.frequency.value = 780;
                crackFilter1.Q.value = 4.5;
                const crackFilter2 = audioContext.createBiquadFilter();
                crackFilter2.type = 'bandpass';
                crackFilter2.frequency.value = 2400 + Math.random() * 1600;
                crackFilter2.Q.value = 14;
                const crackGain = audioContext.createGain();
                crack.connect(crackFilter1);
                crackFilter1.connect(crackFilter2);
                crackFilter2.connect(crackGain);
                crackGain.connect(audioContext.destination);
                crackGain.gain.setValueAtTime(0.4, now);
                crackGain.gain.exponentialRampToValueAtTime(0.01, now + 0.18);
                crack.start(now);
                const thumpBuffer = audioContext.createBuffer(1, 4410, audioContext.sampleRate);
                const thumpData = thumpBuffer.getChannelData(0);
                for (let i = 0; i < 4410; i++) {
                    const envelope = Math.exp(-i / 850);
                    thumpData[i] = (Math.random() * 2 - 1) * envelope * 0.65;
                }
                const thump = audioContext.createBufferSource();
                thump.buffer = thumpBuffer;
                const thumpFilter = audioContext.createBiquadFilter();
                thumpFilter.type = 'lowpass';
                thumpFilter.frequency.value = 140;
                thumpFilter.Q.value = 7;
                const thumpGain = audioContext.createGain();
                thump.connect(thumpFilter);
                thumpFilter.connect(thumpGain);
                thumpGain.connect(audioContext.destination);
                thumpGain.gain.setValueAtTime(0.35, now);
                thumpGain.gain.exponentialRampToValueAtTime(0.01, now + 0.22);
                thump.start(now);
                try {
                    crack.stop(now + 0.18);
                    thump.stop(now + 0.22);
                } catch(e) {}
                if (navigator.vibrate) {
                    navigator.vibrate([130, 35, 90]);
                }
            }
        }

        // Prevent right-click
        document.addEventListener('contextmenu', e => e.preventDefault());
        // Prevent escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && document.getElementById('experience').style.display === 'block') {
                e.preventDefault();
            }
        });
    </script>
</body>
</html>
